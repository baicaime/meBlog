<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Using Software on 白菜</title><link>https://blog.baicai.me/categories/using-software/</link><description>Recent content in Using Software on 白菜</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@baicai.me (白菜)</managingEditor><webMaster>admin@baicai.me (白菜)</webMaster><copyright>baicai.me</copyright><lastBuildDate>Mon, 24 Feb 2025 00:40:55 +0800</lastBuildDate><atom:link href="https://blog.baicai.me/categories/using-software/index.xml" rel="self" type="application/rss+xml"/><item><title>测试服务器能否正常收发邮件</title><link>https://blog.baicai.me/article/2025/test_25/</link><pubDate>Mon, 24 Feb 2025 00:40:55 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2025/test_25/</guid><description>&lt;p>需要收发邮件的话，要注意商家是否开放25端口&lt;/p>
&lt;h3 id="发邮件">发邮件&lt;/h3>
&lt;p>使用&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet smtp.qq.com 25
&lt;/code>&lt;/pre>&lt;p>显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet smtp.qq.com 25
Trying 43.129.255.54...
&lt;/code>&lt;/pre>&lt;p>则无法使用。&lt;/p>
&lt;p>显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet smtp.qq.com 25
Trying 43.129.255.54...
Connected to smtp.qq.com.
Escape character is &amp;#39;^]&amp;#39;.
220 newxmesmtplogicsvrszc5-0.qq.com XMail Esmtp QQ Mail Server.
&lt;/code>&lt;/pre>&lt;p>则可以正常使用。&lt;/p>
&lt;h3 id="使用gmail进行测试也是类似的">使用gmail进行测试也是类似的：&lt;/h3>
&lt;pre tabindex="0">&lt;code>telnet smtp.gmail.com 25
Trying 172.253.117.109...
Connected to smtp.gmail.com.
Escape character is &amp;#39;^]&amp;#39;.
220 smtp.gmail.com ESMTP ca40-20020a056a0206a800b005897bfc2ed3sm7618602pgb.93 - gsmtp
&lt;/code>&lt;/pre>&lt;p>当然，现在Gmail 推荐使用 TLS/SSL 连接，所以也要测试465：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet smtp.gmail.com 465
&lt;/code>&lt;/pre>&lt;p>显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet smtp.gmail.com 465
Trying 173.194.174.108...
Connected to smtp.gmail.com.
Escape character is &amp;#39;^]&amp;#39;.
&lt;/code>&lt;/pre>&lt;p>正常，超时则无法发送。&lt;/p>
&lt;h3 id="收邮件">收邮件&lt;/h3>
&lt;pre tabindex="0">&lt;code>telnet pop.gmail.com 995
&lt;/code>&lt;/pre>&lt;p>显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet pop.gmail.com 995
Trying 64.233.188.108...
Connected to pop.gmail.com.
Escape character is &amp;#39;^]&amp;#39;.
&lt;/code>&lt;/pre>&lt;p>测试：&lt;/p>
&lt;pre tabindex="0">&lt;code>telnet imap.gmail.com 993
&lt;/code>&lt;/pre>&lt;p>显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>Trying 142.251.8.108...
Connected to imap.gmail.com.
Escape character is &amp;#39;^]&amp;#39;.
&lt;/code>&lt;/pre>&lt;p>这两个都要测试，超时则无法收到邮件。&lt;/p></description></item><item><title>Nginx 出现 Too many open files 错误与修复</title><link>https://blog.baicai.me/article/2025/nginx_too_many_open_files/</link><pubDate>Sun, 23 Feb 2025 22:22:39 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2025/nginx_too_many_open_files/</guid><description>&lt;p>最近服务器遭遇间歇性流量攻击，服务器负载不高，却出现无法打开的情况，查看nginx错误日志，出现大量的“Too many open files”错误，大致意思就是说nginx无法打开更多的文件。&lt;/p>
&lt;p>出现这个错误可能是由于系统的ulimit限制和nginx自身的配置有关系。&lt;/p>
&lt;h3 id="什么是ulimit">什么是ulimit?&lt;/h3>
&lt;p>ulimit命令用来限制系统用户对shell资源的访问。&lt;/p>
&lt;p>假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。&lt;/p>
&lt;p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。&lt;/p>
&lt;p>简单来说，ulimit描述符可以对用户打开的文件数量进行限制（不止限制打开文件数量），让单个用户不至于打开较多的文件，导致系统奔溃或者资源不足的情况。
查看ulimit&lt;/p>
&lt;p>既然知道了ulimit是做什么的，首先要先知道系统底层限制到底是多少，ulimit的参数如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>-a：显示目前资源限制的设定；
-c &amp;lt;core文件上限&amp;gt;：设定core文件的最大值，单位为区块；
-d &amp;lt;数据节区大小&amp;gt;：程序数据节区的最大值，单位为KB；
-f &amp;lt;文件大小&amp;gt;：shell所能建立的最大文件，单位为区块；
-H：设定资源的硬性限制，也就是管理员所设下的限制；
-m &amp;lt;内存大小&amp;gt;：指定可使用内存的上限，单位为KB；
-n &amp;lt;文件数目&amp;gt;：指定同一时间最多可开启的文件数；
-p &amp;lt;缓冲区大小&amp;gt;：指定管道缓冲区的大小，单位512字节；
-s &amp;lt;堆叠大小&amp;gt;：指定堆叠的上限，单位为KB；
-S：设定资源的弹性限制；
-t &amp;lt;CPU时间&amp;gt;：指定CPU使用时间的上限，单位为秒；
-u &amp;lt;程序数目&amp;gt;：用户最多可开启的程序数目；
-v &amp;lt;虚拟内存大小&amp;gt;：指定可使用的虚拟内存上限，单位为KB。
&lt;/code>&lt;/pre>&lt;p>由于上述nginx错误是无法打开过多的文件，那么我们直接使用ulimit -n查看同一时间最多可开启的文件数。&lt;/p>
&lt;p>&lt;code>ulimit -n&lt;/code>&lt;/p>
&lt;p>可以看出限制的1024个文件，这就导致nginx尝试打开更多的文件（超出1024个）的时候出现错误“Too many open files”&lt;/p>
&lt;h3 id="修复问题">修复问题&lt;/h3>
&lt;h4 id="修改ulimit限制">修改ulimit限制&lt;/h4>
&lt;p>直接执行命令ulimit -n 65535修改打开文件数，65535指的是需要同一时间最多打开多少个文件，请根据自身情况适当修改。&lt;/p>
&lt;p>ulimit命令修改只对当前的shell有效，退出后失效，如果需要永久生效，需要修改&lt;code>/etc/security/limits.conf&lt;/code>这个文件，在底部加入下面的配置：&lt;/p>
&lt;pre tabindex="0">&lt;code>* soft nproc 65535
* hard nproc 65535
* soft nofile 65535
* hard nofile 65535
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> *：代表全局
soft：代表软件
hard：代表硬件
nproc：是代表最大进程数
nofile：是代表最大文件打开数
&lt;/code>&lt;/pre>&lt;p>修改完毕后，再次执行命令：&lt;code>ulimit -n&lt;/code>可以看到设置已经生效!&lt;/p>
&lt;h4 id="修改nginx打开文件限制">修改nginx打开文件限制&lt;/h4>
&lt;p>修改&lt;code>nginx.conf&lt;/code>在 http 和 events 外层加入一行:
&lt;code>worker_rlimit_nofile 65535;&lt;/code>
worker_rlimit_nofile这个参数的含义是：“为nginx工作进程改变打开最多文件描述符数目的限制。用来在不重启主进程的情况下增加限制。”&lt;/p>
&lt;p>Debian系统 看起来像这样的&lt;/p>
&lt;pre tabindex="0">&lt;code>user www-data;
worker_processes auto;
pid /run/nginx.pid;
###############################################################################################################
# Must be less than LimitNOFILE for systemd
# or /etc/security/limits.conf (non-systemd)
# E.g. if LimitNOFILE is 65535, I set to 30000 (systemd)
# E.g. if &amp;#34;nginx hard nofile 30000&amp;#34; in the /etc/security/limits.conf, I set to 30000 (non-systemd)
###############################################################################################################
worker_rlimit_nofile 30000; #vg
include /etc/nginx/modules-enabled/*.conf;
events {
worker_connections 65535; #vg
multi_accept on; #vg
}
http {
##
# Basic Settings
...
.....
&lt;/code>&lt;/pre>&lt;p>重载nginx配置:
&lt;code>nginx -s reload&lt;/code>&lt;/p>
&lt;h2 id="nginx的其他优化">Nginx的其他优化&lt;/h2>
&lt;p>编辑 &lt;code>/etc/sysctl.conf&lt;/code> 文件，添加或修改
&lt;code>fs.file-max = 70000&lt;/code>&lt;/p>
&lt;p>查看是否生效
&lt;code>sysctl -p&lt;/code>&lt;/p></description></item><item><title>Debian12 系统添加多个IP</title><link>https://blog.baicai.me/article/2025/ifconfig_interfaces/</link><pubDate>Fri, 21 Feb 2025 23:31:24 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2025/ifconfig_interfaces/</guid><description>&lt;p>对于使用 传统的 ifconfig 配置的系统（例如老版本的Ubuntu、Debian等）,直接修改 &lt;code>/etc/network/interfaces&lt;/code> 文件。&lt;/p>
&lt;h3 id="编辑配置文件">编辑配置文件：&lt;/h3>
&lt;p>&lt;code>sudo nano /etc/network/interfaces&lt;/code>&lt;/p>
&lt;h3 id="添加多个ip地址">添加多个IP地址：&lt;/h3>
&lt;p>在相应的网络接口下添加多个IP地址。例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>iface enp30 inet static
address 192.168.0.250
netmask 255.255.255.0
gateway 192.168.0.1
iface enp30 inet static
address 192.168.0.251
netmask 255.255.255.0
&lt;/code>&lt;/pre>&lt;h3 id="重启网络服务">重启网络服务：&lt;/h3>
&lt;p>保存文件并退出后，重启网络服务：&lt;/p>
&lt;p>&lt;code>sudo systemctl restart networking&lt;/code>&lt;/p>
&lt;h3 id="检查配置">检查配置&lt;/h3>
&lt;p>通过以下命令验证多IP地址是否已成功添加：&lt;/p>
&lt;p>&lt;code>ip addr show enp30&lt;/code>&lt;/p>
&lt;p>这将显示 enp30 接口的所有IP地址。你应该能看到你配置的多个IP地址。&lt;/p>
&lt;h2 id="临时配置多个ip地址">临时配置多个IP地址&lt;/h2>
&lt;p>为 enp30 接口添加一个新的IP 192.168.0.251
执行以下命令：
&lt;code>ip addr add 192.168.0.251/24 dev enp30&lt;/code>
这操作是临时的，重启后会丢失。&lt;/p></description></item><item><title>linux测试url的访问速度</title><link>https://blog.baicai.me/article/2025/linux_curl/</link><pubDate>Fri, 21 Feb 2025 18:34:28 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2025/linux_curl/</guid><description>&lt;p>使用curl命令来测试URL的访问速度。&lt;/p>
&lt;p>以下是使用curl测试URL访问速度的步骤：&lt;/p>
&lt;ul>
&lt;li>打开终端或命令行界面。&lt;/li>
&lt;li>输入以下命令：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> curl -o /dev/null -s -w &lt;span style="color:#e6db74">&amp;#34;time_namelookup: %{time_namelookup}\n time_connect: %{time_connect}\n time_pretransfer: %{time_pretransfer}\n time_starttransfer: %{time_starttransfer}\n time_total: %{time_total}\n&amp;#34;&lt;/span> &amp;lt;URL&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请将&lt;code>&amp;lt;URL&amp;gt;&lt;/code>替换为要测试的URL地址。&lt;/p>
&lt;p>执行命令后，curl将会发送请求并返回一些关于请求的统计信息，包括以下内容：&lt;/p>
&lt;ul>
&lt;li>time_namelookup：DNS解析耗时，即将URL解析为IP地址的时间。&lt;/li>
&lt;li>time_connect：建立TCP连接的耗时。&lt;/li>
&lt;li>time_pretransfer：从开始到传输开始之前的耗时。&lt;/li>
&lt;li>time_starttransfer：从开始到第一个字节接收完成的耗时。&lt;/li>
&lt;li>time_total：总耗时，即从开始到请求完成的时间。&lt;/li>
&lt;/ul>
&lt;p>这些时间单位都以秒为单位。&lt;/p>
&lt;p>通过这些统计信息，你可以了解到URL的访问速度和各个阶段的耗时情况。&lt;/p></description></item><item><title>Docker本地镜像的导出、导入 (export,import,save,load)</title><link>https://blog.baicai.me/article/2024/docker_export_import_save_load/</link><pubDate>Fri, 11 Oct 2024 14:53:59 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/docker_export_import_save_load/</guid><description>&lt;p>对于镜像的导出和导入，Docker 提供了两种方案，下面分别进行介绍。&lt;/p>
&lt;h2 id="一使用-export-和-import">一、使用 export 和 import&lt;/h2>
&lt;h3 id="1查看本机的容器">1，查看本机的容器&lt;/h3>
&lt;p>使用 &lt;code>docker ps -a&lt;/code> 命令查看本机所有的容器。&lt;/p>
&lt;h3 id="2导出镜像">2，导出镜像&lt;/h3>
&lt;p>（1）使用 &lt;code>docker export&lt;/code> 命令根据容器 ID 将镜像导出成一个文件。&lt;/p>
&lt;p>&lt;code>docker export 镜像ID &amp;gt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）上面命令执行后，可以看到文件已经保存到当前的终端目录下。&lt;/p>
&lt;h3 id="3导入镜像">3，导入镜像&lt;/h3>
&lt;p>（1）使用 &lt;code>docker import&lt;/code> 命令则可将这个镜像文件导入进来。&lt;/p>
&lt;p>&lt;code>docker import - new_server &amp;lt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）执行 &lt;code>docker images&lt;/code> 命令可以看到镜像确实已经导入进来了。&lt;/p>
&lt;h2 id="二使用-save-和-load">二、使用 save 和 load&lt;/h2>
&lt;h3 id="1查看本机的容器-1">1，查看本机的容器&lt;/h3>
&lt;p>这两个命令是通过镜像来保存、加载镜像文件的。首先我们使用 &lt;code>docker images&lt;/code> 命令查看本机所有的镜像。&lt;/p>
&lt;h3 id="2保存镜像">2，保存镜像&lt;/h3>
&lt;p>（1）下面使用 &lt;code>docker save&lt;/code> 命令根据 ID 将镜像保存成一个文件。&lt;/p>
&lt;p>&lt;code>docker save 镜像ID &amp;gt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）我们还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包：&lt;/p>
&lt;p>&lt;code>docker save -o images.tar postgres mongo&lt;/code>&lt;/p>
&lt;h3 id="3载入镜像">3，载入镜像&lt;/h3>
&lt;p>使用 &lt;code>docker load&lt;/code> 命令则可将这个镜像文件载入进来。&lt;/p>
&lt;p>&lt;code>docker load &amp;lt; server.tar&lt;/code>&lt;/p>
&lt;h2 id="附两种方案的差别">附：两种方案的差别&lt;/h2>
&lt;p>特别注意：两种方法不可混用。&lt;br>
如果使用 &lt;code>import&lt;/code> 导入 &lt;code>save&lt;/code> 产生的文件，虽然导入不提示错误，但是启动容器时会提示失败，会出现类似&amp;quot;docker: Error response from daemon: Container command not found or does not exist&amp;quot;的错误。&lt;/p>
&lt;h3 id="1文件大小不同">1，文件大小不同&lt;/h3>
&lt;p>export 导出的镜像文件体积小于 save 保存的镜像&lt;/p>
&lt;h3 id="2是否可以对镜像重命名">2，是否可以对镜像重命名&lt;/h3>
&lt;p>docker import 可以为镜像指定新名称
docker load 不能对载入的镜像重命名&lt;/p>
&lt;h3 id="3是否可以同时将多个镜像打包到一个文件中">3，是否可以同时将多个镜像打包到一个文件中&lt;/h3>
&lt;p>docker export 不支持
docker save 支持&lt;/p>
&lt;h3 id="4是否包含镜像历史">4，是否包含镜像历史&lt;/h3>
&lt;p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。&lt;/p>
&lt;p>save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。&lt;/p>
&lt;h3 id="5应用场景不同">5，应用场景不同&lt;/h3>
&lt;p>docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。&lt;/p>
&lt;p>docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 docker save 将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。&lt;/p></description></item><item><title>Mac终端查看sqlite3数据库</title><link>https://blog.baicai.me/article/2024/cmd_sqlite/</link><pubDate>Tue, 24 Sep 2024 14:23:50 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/cmd_sqlite/</guid><description>&lt;h3 id="用sqlite命令打开数据库文件">用sqlite命令打开数据库文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sqlite3 db.file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们就进入了数据库操作，下面的命令都只能是sqlite下的命令，如果输入其他命令，都是无效的。&lt;/p>
&lt;p>我们可以输入 .help 先查看下大概的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.help
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="常用的几种简单命令">常用的几种简单命令：&lt;/h3>
&lt;ol>
&lt;li>退出sqlite&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.quit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>查看所有表&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.tables
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>配置情况&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.show
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>设置查询数据排列格式&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.mode list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.mode line
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.mode column
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>是否显示头&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>.headers on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>解决 UFW 和 Docker 的问题</title><link>https://blog.baicai.me/article/2024/debian_ufw_docker/</link><pubDate>Thu, 11 Jul 2024 14:31:38 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/debian_ufw_docker/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>UFW 是一个 iptables 前端，可以非常方便的管理防火墙的规则。但是当安装了 Docker，UFW 无法管理 Docker 发布出来的端口了。&lt;/p>
&lt;p>具体现象是：&lt;/p>
&lt;ol>
&lt;li>在一个对外提供服务的服务器上启用了 UFW，并且默认阻止所有未被允许的传入连接。&lt;/li>
&lt;li>运行了一个 Docker 容器，并且使用 &lt;code>-p&lt;/code> 选项来把该容器的某个端口发布到服务器的所有 IP 地址上。比如：&lt;code>docker run -d --name httpd -p 0.0.0.0:8080:80 httpd:alpine&lt;/code> 将会运行一个 httpd 服务，并且将容器的 &lt;code>80&lt;/code> 端口发布到服务器的 &lt;code>8080&lt;/code> 端口上。&lt;/li>
&lt;li>UFW 将不会阻止所有对 &lt;code>8080&lt;/code> 端口访问的请求，用命令 &lt;code>ufw deny 8080&lt;/code> 也无法阻止外部访问这个端口。&lt;/li>
&lt;/ol>
&lt;p>这个问题其实挺严重的，这意味着本来只是为了在内部提供服务的一个端口被暴露在公共网络上。&lt;/p>
&lt;h2 id="解决-ufw-和-docker-的问题">解决 UFW 和 Docker 的问题&lt;/h2>
&lt;h3 id="撤销原先的修改">撤销原先的修改&lt;/h3>
&lt;p>如果已经按照目前网络上搜索到解决方案修改过了，请先修改回来，包括：&lt;/p>
&lt;ol>
&lt;li>启用 Docker 的 iptables 功能，删除所有类似 &lt;code>--iptables=false&lt;/code> 的修改，包括 &lt;code>/etc/docker/daemon.json&lt;/code> 配置文件。&lt;/li>
&lt;li>UFW 的默认 &lt;code>FORWARD&lt;/code> 规则改回默认的 &lt;code>DROP&lt;/code>，而非 &lt;code>ACCEPT&lt;/code>。&lt;/li>
&lt;li>删除 UFW 配置文件 &lt;code>/etc/ufw/after.rules&lt;/code> 中与 Docker 网络相关的规则。&lt;/li>
&lt;li>如果修改了 Docker 相关的配置文件，重启 Docker。稍后还要修改 UFW 的配置，可以一并重启。&lt;/li>
&lt;/ol>
&lt;p>目前新的解决方案只需要修改一个 UFW 配置文件即可，Docker 的所有配置和选项都保持默认。&lt;/p>
&lt;p>修改 UFW 的配置文件 &lt;code>/etc/ufw/after.rules&lt;/code>，在最后添加上如下规则：&lt;/p>
&lt;pre tabindex="0">&lt;code> # BEGIN UFW AND DOCKER
*filter
:ufw-user-forward - [0:0]
:ufw-docker-logging-deny - [0:0]
:DOCKER-USER - [0:0]
-A DOCKER-USER -j ufw-user-forward
-A DOCKER-USER -j RETURN -s 10.0.0.0/8
-A DOCKER-USER -j RETURN -s 172.16.0.0/12
-A DOCKER-USER -j RETURN -s 192.168.0.0/16
-A DOCKER-USER -p udp -m udp --sport 53 --dport 1024:65535 -j RETURN
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 172.16.0.0/12
-A DOCKER-USER -j RETURN
-A ufw-docker-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &amp;#34;[UFW DOCKER BLOCK] &amp;#34;
-A ufw-docker-logging-deny -j DROP
COMMIT
# END UFW AND DOCKER
&lt;/code>&lt;/pre>&lt;p>然后重启 UFW，&lt;code>sudo systemctl restart ufw&lt;/code>。现在外部就已经无法访问 Docker 发布出来的任何端口了，但是容器内部以及私有网络地址上可以正常互相访问，而且容器也可以正常访问外部的网络。&lt;strong>可能由于某些未知原因，重启 UFW 之后规则也无法生效，请重启服务器。&lt;/strong>&lt;/p>
&lt;p>如果希望允许外部网络访问 Docker 容器提供的服务，比如有一个容器的服务端口是 &lt;code>80&lt;/code>。那就可以用以下命令来允许外部网络访问这个服务：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto tcp from any to any port 80
&lt;/code>&lt;/pre>&lt;p>这个命令会允许外部网络访问所有用 Docker 发布出来的并且内部服务端口为 &lt;code>80&lt;/code> 的所有服务。&lt;/p>
&lt;p>如果有多个容器的服务端口为 80，但只希望外部网络访问某个特定的容器。比如该容器的私有地址为 &lt;code>172.17.0.2&lt;/code>，就用类似下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto tcp from any to 172.17.0.2 port 80
&lt;/code>&lt;/pre>&lt;p>如果一个容器的服务是 UDP 协议，假如是 DNS 服务，可以用下面的命令来允许外部网络访问所有发布出来的 DNS 服务：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any to any port 53
&lt;/code>&lt;/pre>&lt;p>同样的，如果只针对一个特定的容器，比如 IP 地址为 &lt;code>172.17.0.2&lt;/code>：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any to 172.17.0.2 port 53
&lt;/code>&lt;/pre>&lt;h3 id="解释">解释&lt;/h3>
&lt;p>在新增的这段规则中，下面这段规则是为了让私有网络地址可以互相访问。通常情况下，私有网络是比公共网络更信任的。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j RETURN -s 10.0.0.0/8
-A DOCKER-USER -j RETURN -s 172.16.0.0/12
-A DOCKER-USER -j RETURN -s 192.168.0.0/16
&lt;/code>&lt;/pre>&lt;p>下面的规则是为了可以用 UFW 来管理外部网络是否允许访问 Docker 容器提供的服务，这样我们就可以在一个地方来管理防火墙的规则了。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j ufw-user-forward
&lt;/code>&lt;/pre>&lt;p>例如，我们要阻止一个 IP 地址为 172.17.0.9 的容器内的所有对外连接，也就是阻止该容器访问外部网络，使用下列命令&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route deny from 172.17.0.9 to any
&lt;/code>&lt;/pre>&lt;p>下面的规则阻止了所有外部网络发起的连接请求，但是允许内部网络访问外部网络。对于 TCP 协议，是阻止了从外部网络主动建立 TCP 连接。对于 UDP，是阻止了所有小于端口 &lt;code>32767&lt;/code> 的访问。为什么是这个端口的？由于 UDP 协议是无状态的，无法像 TCP 那样阻止发起建立连接请求的握手信号。在 GNU/Linux 上查看文件 &lt;code>/proc/sys/net/ipv4/ip_local_port_range&lt;/code> 可以看到发出 TCP/UDP 数据后，本地源端口的范围，默认为 &lt;code>32768 60999&lt;/code>。当从一个运行的容器对外访问一个 UDP 协议的服务时，本地端口将会从这个端口范围里面随机选择一个，服务器将会把数据返回到这个随机端口上。所以，我们可以假定所有容器内部的 UDP 协议的监听端口都小余 &lt;code>32768&lt;/code>，不允许外部网络主动连接小余 &lt;code>32768&lt;/code> 的 UDP 端口。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0/12
-A DOCKER-USER -j RETURN
&lt;/code>&lt;/pre>&lt;p>如果一个容器在接受数据的时候，端口号没有遵循操作系统的设定，也就是说最小端口号要小余 &lt;code>32768&lt;/code>。比如运行了一个 Dnsmasq 的容器，Dnsmasq 用于接受数据的最小端口号默认是 &lt;code>1024&lt;/code>。那可以用下面的命令来允许 Dnsmasq 这个容器使用一个更大的端口范围来接受数据。&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any port 53 to any port 1024:65535
&lt;/code>&lt;/pre>&lt;p>因为 DNS 是一个非常常见的服务，所以已经有一条规则用于允许使用一个更大的端口范围来接受 DNS 数据包&lt;/p>
&lt;h3 id="选择-ufw-user-forward-而不是-ufw-user-input-的原因">选择 &lt;code>ufw-user-forward&lt;/code> 而不是 &lt;code>ufw-user-input&lt;/code> 的原因&lt;/h3>
&lt;h4 id="使用-ufw-user-input">使用 &lt;code>ufw-user-input&lt;/code>&lt;/h4>
&lt;p>优点：&lt;/p>
&lt;p>使用的 UFW 命令比较简单，也比较容易理解&lt;/p>
&lt;p>比如，允许公众网络访问一个已经发布出来的容器端口 &lt;code>8080&lt;/code>，使用命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow 8080
&lt;/code>&lt;/pre>&lt;p>缺点：&lt;/p>
&lt;p>不仅仅是暴露了已经发布的容器端口，也暴露了主机上的端口。&lt;/p>
&lt;p>比如，如果在主机上运行了一个端口为 &lt;code>8080&lt;/code> 的服务。命令 &lt;code>ufw allow 8080&lt;/code> 允许了公共网络访问这个服务，也允许了访问所有已经发布的容器端口为 &lt;code>8080&lt;/code> 的服务。但是我们可能只是希望保留主机上的这个服务，或者是运行在容器里面的服务，而不是两个同时暴露。&lt;/p>
&lt;p>为了避免这个问题，我们可能需要使用类似下面的命令来管理已经发布的容器端口：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow proto tcp from any to 172.16.0.3 port 8080
&lt;/code>&lt;/pre>&lt;h4 id="使用-ufw-user-forward">使用 &lt;code>ufw-user-forward&lt;/code>&lt;/h4>
&lt;p>优点：&lt;/p>
&lt;p>不会因为同一条命令而同时暴露主机和容器里面的服务。&lt;/p>
&lt;p>比如，如果我们希望暴露所有容器端口为 &lt;code>8080&lt;/code> 的服务，使用下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow 8080
&lt;/code>&lt;/pre>&lt;p>现在公共网络可以访问所有容器端口为 &lt;code>8080&lt;/code> 的已经发布的服务，但是运行在主机上的 &lt;code>8080&lt;/code> 服务仍然不会被公开。如果我们希望公开主机上的 &lt;code>8080&lt;/code> 端口，可以执行下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow 8080
&lt;/code>&lt;/pre>&lt;h4 id="结论">结论&lt;/h4>
&lt;p>如果我们正在使用老版本，我们可以使用 &lt;code>ufw-user-input&lt;/code>。但是要小心避免把不该暴露的服务暴露出去。&lt;/p>
&lt;p>如果正在使用支持 &lt;code>ufw route&lt;/code> 命令的新版本，我们最好使用 &lt;code>ufw-user-forward&lt;/code>，并且使用 &lt;code>ufw route&lt;/code> 来管理与容器相关的防火墙规则。&lt;/p></description></item><item><title>docker 映射某个范围内的端口列表</title><link>https://blog.baicai.me/article/2024/docker_ports/</link><pubDate>Sat, 09 Mar 2024 00:01:19 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/docker_ports/</guid><description>&lt;p>在Dockerfile、命令行或docker-compose.yml中，都可以使用类似于8080-8090:8080-8090的格式，来映射多个端口&lt;/p>
&lt;h3 id="docker-composeyml">docker-compose.yml&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3.6&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">web&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx:1.18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 将会映射8080到8090这个范围内的端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">8080-8090&lt;/span>:&lt;span style="color:#ae81ff">8080-8090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./www:/www&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="命令行">命令行&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -p 8080-8090:8080-8090 nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dockerfile">Dockerfile&lt;/h3>
&lt;pre tabindex="0">&lt;code>Dockerfile
EXPOSE 8080-8090
&lt;/code>&lt;/pre></description></item><item><title>使用adb命令和电脑互传文件</title><link>https://blog.baicai.me/article/2024/adb_push_pull/</link><pubDate>Mon, 04 Mar 2024 22:44:37 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/adb_push_pull/</guid><description>&lt;h3 id="电脑传文件到手机">电脑传文件到手机&lt;/h3>
&lt;p>把当前目录下的&lt;code>test.tex&lt;/code>文件传到手机 &lt;code>/sdcard/test&lt;/code>目录中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb push test.txt /sdcard/test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="手机文件传到电脑">手机文件传到电脑&lt;/h3>
&lt;p>把 &lt;code>/sdcard/test/&lt;/code> 目录下的&lt;code>test.txt&lt;/code>文件传到本机当前目录&lt;code>test&lt;/code>目录中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb pull /sdcard/test/test.txt ./test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看手机文件目录">查看手机文件目录&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#进入到根目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>adb shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查看所有目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#进入到sdcard目录，安卓手机的文件管理一般都这这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd sdcard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#然后查看要传输哪些文件到哪个文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>查找子域名解析: 子域名探测方法大全</title><link>https://blog.baicai.me/article/2024/find_subdomain/</link><pubDate>Mon, 05 Feb 2024 18:58:56 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/find_subdomain/</guid><description>&lt;h2 id="子域名探测">子域名探测&lt;/h2>
&lt;p>通过收集子域名信息来进行渗透是目前常见的一种手法。
子域名信息收集可以通过手工，也可以通过工具，还可以通过普通及漏洞搜索引擎来进行分析。
在挖SRC漏洞时，子域名信息的收集至关重要！&lt;/p>
&lt;h2 id="为什么要进行子域名探测">为什么要进行子域名探测？&lt;/h2>
&lt;p>子域名探测可以帮我们发现渗透测试中更多的服务，这将增加发现漏洞的可能性&lt;br>
查找一些用户上较少，被人遗忘的子域名，其上运行的应用程序可能会使我们发现关键漏洞&lt;br>
通常，同一组织的不同域名/应用程序中存在相同的漏洞&lt;br>
子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中&lt;/p>
&lt;h2 id="子域名探测方法大全">子域名探测方法大全&lt;/h2>
&lt;p>在线接口&lt;br>
暴力枚举&lt;br>
搜索引擎&lt;br>
Certificate Transparency（证书透明）&lt;br>
Subject Alternate Name (SAN) - 主题备用名称&lt;br>
Public datasets（公开数据集）&lt;br>
信息泄露&lt;br>
内容解析（HTML，JavaScript，文件）&lt;br>
DNS解析&lt;br>
区域传送&lt;br>
DNS aggregators（DNS聚合器）&lt;br>
DNS Cache Snooping（域名缓存侦测）&lt;br>
Alterations &amp;amp; permutations（换置 &amp;amp; 排序）&lt;br>
DNSSEC(Domain Name System Security Extensions)，DNS安全扩展，DNSSEC区域漫步&lt;br>
CSP HTTP首部&lt;br>
SPF记录&lt;br>
虚拟主机爆破&lt;br>
ASN发现&lt;br>
爬虫 Scraping（抓取）&lt;/p>
&lt;h3 id="在线接口">在线接口&lt;/h3>
&lt;pre tabindex="0">&lt;code>https://crt.sh/
https://censys.io/
https://transparencyreport.google.com/https/certificates
https://dnsdumpster.com/
https://hackertarget.com/find-dns-host-records/
https://x.threatbook.cn/
https://www.virustotal.com/gui/home/search
https://site.ip138.com/baidu.com/domain.htm
https://www.t1h2ua.cn/tools/
http://tool.chinaz.com/subdomain/
&lt;/code>&lt;/pre>&lt;h3 id="暴力枚举">暴力枚举&lt;/h3>
&lt;p>Layer子域名爆破机 Layer是windows下的一款子域名探测工具，其工作原理是利用子域名字典进行爆破，使用简单容易上手。&lt;/p>
&lt;p>Amass 工具描述：爆破, google, VirusTotal, alt names&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go install github.com/OWASP/Amass/...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>amass -d target.com -o $outfile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Knock 工具描述：AXFR, virustotal, 爆破&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt-get install python-dnspython git clone https://xxx.com/guelfoweb/knock.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd knock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nano knockpy/config.json &lt;span style="color:#75715e"># &amp;lt;- set your virustotal API_KEY python setup.py install&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="搜索引擎">搜索引擎&lt;/h3>
&lt;p>Google&lt;br>
intitle=公司名称&lt;br>
过滤掉 -site:www.target.com&lt;br>
我们可以在Google搜索中使用 site:运算符来查找一个域的所有子域名&lt;br>
谷歌还额外支持减号运算符 site:*.wikimedia.org -www -store -jobs -uk 以排除我们不感兴趣的子域名&lt;/p>
&lt;p>Bing&lt;br>
Bing搜索引擎也支持一些高级搜索运算符。&lt;br>
与Google一样，Bing也支持site:运算符，可以帮助您检查除Google搜索之外的其他结果。&lt;br>
发现子域名: site:target.com&lt;/p>
&lt;p>百度&lt;br>
intitle=公司名称&lt;/p>
&lt;p>钟馗之眼&lt;/p>
&lt;pre tabindex="0">&lt;code>https://www.zoomeye.org/ site=target.com
&lt;/code>&lt;/pre>&lt;p>duckduckgo&lt;/p>
&lt;pre tabindex="0">&lt;code>https://duckduckgo.com site:target.com
&lt;/code>&lt;/pre>&lt;h3 id="certificate-transparency-证书透明">Certificate Transparency （证书透明）&lt;/h3>
&lt;h5 id="ssltls证书">SSL/TLS证书&lt;/h5>
&lt;p>证书透明度(Certificate Transparency)是证书授权机构的一个项目，证书授权机构会将每个SSL/TLS证书发布到公共日志中。&lt;br>
一个SSL/TLS证书通常包含域名、子域名和邮件地址。&lt;br>
查找某个域名所属证书的最简单的方法就是使用搜索引擎搜索一些公开的CT日志。&lt;/p>
&lt;p>在线查询：&lt;/p>
&lt;pre tabindex="0">&lt;code>https://crt.sh/
https://censys.io/
https://developers.facebook.com/tools/ct/
https://google.com/transparencyreport/https/ct/
https://transparencyreport.google.com/https/certificates
&lt;/code>&lt;/pre>&lt;p>CTFR 工具描述：滥用证书透明记录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/UnaPibaGeek/ctfr.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd ctfr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip3 install -r requirements.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 ctfr.py -d target.com -o $outfile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Censys_subdomain_enum.py&lt;br>
工具描述：提取子域名，从Censys的SSL/TLS证书中收集子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install censys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/appsecco/the-art-of-subdomain-enumeration.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python censys_enumeration.py target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Cloudflare_enum.py&lt;br>
工具描述：从Cloudflare提取子域名 dns聚合器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install censys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/appsecco/the-art-of-subdomain-enumeration.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cloudflare_subdomain_enum.py your@cloudflare.email target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Crt_enum_web.py&lt;br>
工具描述：解析https://crt.sh/页面的子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install psycopg2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/appsecco/the-art-of-subdomain-enumeration.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 crtsh_enum_web.py target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>San_subdomain_enum.py&lt;br>
工具描述：SSL/TLS证书中的SAN获取子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/appsecco/the-art-of-subdomain-enumeration.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./san_subdomain_enum.py target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="subject-alternate-name-san-主题备用名称">Subject Alternate Name （SAN）-主题备用名称&lt;/h4>
&lt;p>SAN(Subject Alternate Name)主题备用名称，主题备用名称证书简单来说，在需要多个域名，将其用于各项服务时，可使用SAN证书。&lt;br>
允许在安全证书中使用subjectAltName字段将多种值与证书关联，这些值被称为主题备用名称。名称可包括：IP地址、DNS名称等。&lt;/p>
&lt;p>San_subdomain_enum.py&lt;br>
工具描述：SSL/TLS证书中的SAN获取子域名 如上。&lt;/p>
&lt;h4 id="public-datasets-公开数据集">Public datasets （公开数据集）&lt;/h4>
&lt;p>有些项目收集了全互联网范围内的扫描数据，并将其提供给研究人员和安全社区。&lt;br>
该项目发布的数据集是子域名信息的宝库。&lt;br>
虽然在这个庞大的数据集中找到子域名就像大海捞针，但却值得我们去一试。&lt;/p>
&lt;p>Rapid7 Forward DNS dataset (Project Sonar)&lt;br>
工具描述：来自rapid7 sonar项目的公共数据集&lt;/p>
&lt;p>数据聚合网站&lt;/p>
&lt;pre tabindex="0">&lt;code>https://opendata.rapid7.com/
&lt;/code>&lt;/pre>&lt;h3 id="信息泄漏">信息泄漏&lt;/h3>
&lt;p>信息泄露&lt;br>
首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。&lt;/p>
&lt;p>文件泄漏&lt;br>
crossdomain.xml(跨域策略文件cdx) robots.txt&lt;/p>
&lt;p>Git仓库泄露&lt;/p>
&lt;p>从流量中分析提取&lt;/p>
&lt;h3 id="内容解析htmljavascript文件">内容解析（HTML，JavaScript，文件）&lt;/h3>
&lt;p>BiLE-suite&lt;br>
工具描述：HTML解析，反向dns解析&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>aptitude install httrack
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://github.com/sensepost/BiLE-suite.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>perl BiLE.pl target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Second Order&lt;br>
工具描述：第二阶段域名扫描 通过HTML提取子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go get xxx.com/mhmdiaa/second-order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp ~/go/src/xxx.com/mhmdiaa/second-order/config.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~/go/src/xxx.com/mhmdiaa/second-order/config-subs-enum.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编辑修改LogCrawledURLs为True&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>second-order -base https://target.com -config config.json -output target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dns解析">DNS解析&lt;/h3>
&lt;p>在线查询:&lt;/p>
&lt;pre tabindex="0">&lt;code>VirusTotal(https://www.virustotal.com/)
ViewDNS(https://viewdns.info/)
DNSdumpster(https://dnsdumpster.com/)
&lt;/code>&lt;/pre>&lt;p>BiLE-suite&lt;br>
工具描述：HTML解析，反向dns解析 如上。&lt;/p>
&lt;p>Massdns&lt;br>
工具描述：dns解析&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/blechschmidt/massdns.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd massdns/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解析域名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/bin/massdns -r lists/resolvers.txt -t AAAA -w results.txt domains.txt -o S -w output.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>爆破域名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./scripts/subbrute.py wordlist.txt target.com | ./bin/massdns -r lists/resolvers.txt -t A -o S -w output.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CT解析：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./scripts/ct.py target.com | ./bin/massdns -r lists/resolvers.txt -t A -o S -w output.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="区域传送">区域传送&lt;/h3>
&lt;p>域传送是一种DNS事务，DNS服务器将其全部或部分域文件的副本传递给另一个DNS服务器。&lt;br>
如果未安全地配置域传输送，则任何人都可以对指定名称的服务器启动域传送并获取域文件的副本。&lt;br>
根据设计，域文件包含有关域和保存在域中的大量主机信息。&lt;/p>
&lt;p>Windows：&lt;br>
1.nslookup命令进入交互式shell&lt;br>
2.server命令 参数设定查询将要使用的DNS服务器&lt;br>
3.ls命令列出某个域中的所有域名&lt;/p>
&lt;p>Linux：&lt;br>
Dig&lt;br>
工具描述：dns区域传送，dns反向解析，dns解析&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dig +multi AXFR target.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dig +multi AXFR $ns_server target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dns-aggregators-dns聚合器">DNS aggregators （DNS聚合器）&lt;/h3>
&lt;p>Cloudflare_enum.py&lt;br>
工具描述：从Cloudflare提取子域名 dns聚合器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install censys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://xxx.com/appsecco/the-art-of-subdomain-enumeration.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cloudflare_subdomain_enum.py your@cloudflare.email&lt;span style="color:#f92672">[&lt;/span>4&lt;span style="color:#f92672">]&lt;/span> target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dns-cache-snooping-域名缓存侦测">DNS Cache Snooping （域名缓存侦测）&lt;/h3>
&lt;p>域名缓存侦测（DNS Cache Snooping）技术&lt;br>
在企业网络中，通常都会配置DNS服务器，为网络内的主机提供域名解析服务。&lt;br>
这些DNS不仅解析自己的私有域名，还会用递归方式，请求公网的DNS解析第三方域名，如baidu.com之类。&lt;br>
为了提升性能，通常会使用缓存记录，记录解析过的域名，尤其是第三方域名。&lt;br>
域名缓存侦测（DNS Cache Snooping）技术就是向这些服务器发送域名解析请求，但要求不使用递归模式。&lt;br>
这样DNS只能解析私有域名和缓存中保存的域名。&lt;br>
借助该项技术，渗透测试人员就知道哪些域名是否被过请求过。&lt;br>
例如，测试人员可以提交某安全软件更新所使用的域名，如果有记录，说明该网络使用该种安全软件。&lt;/p>
&lt;h3 id="alterations--permutations-换置--排序">Alterations &amp;amp; permutations (换置 &amp;amp; 排序)&lt;/h3>
&lt;p>AltDNS&lt;br>
工具描述：通过换置&amp;amp;排序技术发现子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://xxx.com/infosec-au/altdns.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd altdns
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install -r requirements.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./altdns.py -i subdomains.txt -o data_output -w words.txt -r -s results_output.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dnssecdomain-name-system-security-extensionsdns安全扩展dnssec区域漫步">DNSSEC(Domain Name System Security Extensions),DNS安全扩展，DNSSEC区域漫步&lt;/h3>
&lt;p>由于DNSSEC处理不存在域名的方式，您可以&amp;quot;遍历&amp;quot;DNSSEC域并枚举该域中的所有域名。&lt;/p>
&lt;p>Ldns-walk&lt;br>
工具描述：DNSSEC zone walking, 如果DNSSEC NSEC开启，可以获得全部域名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>aptitude install ldnsutils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldns-walk target.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldns-walk @nsserver.com target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果DNSSEC NSEC开启，可以获得全部域名。&lt;/p>
&lt;h3 id="csp-http-首部">CSP HTTP 首部&lt;/h3>
&lt;p>Domains-from-csp&lt;br>
工具描述：从CSP头提取子域名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/yamakira/domains-from-csp.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install click
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python csp_parser.py $URL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python csp_parser.py $URL -r
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="spf记录">SPF记录&lt;/h3>
&lt;p>SPF是通过域名的TXT记录来进行设置的，SPF记录列出了所有被授权代表域名发送电子邮件的主机&lt;/p>
&lt;p>Assets-from-spf&lt;br>
工具描述：SPF域名记录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/yamakira/assets-from-spf.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip install click ipwhois
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python assets_from_spf.py target.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="虚拟主机爆破">虚拟主机爆破&lt;/h3>
&lt;p>vhost-brute&lt;br>
工具描述：虚拟主机爆破&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>aptitude install php-curl git clone https://github.com/gwen001/vhost-brute.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Virtual-host-discovery&lt;br>
工具描述：虚拟主机爆破&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/jobertabma/virtual-host-discovery.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ruby scan.rb --ip&lt;span style="color:#f92672">=&lt;/span>1.1.1.1 --host&lt;span style="color:#f92672">=&lt;/span>target.com --output output.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="asn发现">ASN发现&lt;/h3>
&lt;p>通过域名查询到 ASN，再通过 ASN 查询到所属的所有 ip 范围&lt;/p>
&lt;h3 id="爬虫-scraping抓取">爬虫 Scraping（抓取）&lt;/h3>
&lt;h4 id="泛解析问题">泛解析问题&lt;/h4>
&lt;p>目前最好的解决方式是通过先获取一个绝对不存在域名的响应内容，再遍历获取每个字典对应的子域名的响应内容，通过和不存在域名的内容做相似度比对，来枚举子域名，但这样的实现是以牺牲速度为代价&lt;/p>
&lt;h3 id="tools">Tools&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>工具也有很多厉害的，平时我一般使用 OneForALL + ESD + JSfinder 来进行搜集，（ESD 可以加载 layer 的字典，很好用）
&lt;code>https://github.com/shmilylty/OneForAll&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>强大的快速子域枚举工具
&lt;code>https://github.com/aboul3la/Sublist3r&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Knock子域名获取，可用于查找子域名接管漏洞
&lt;code>https://github.com/guelfoweb/knock&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一款便捷高效的子域名爆破工具
&lt;code>https://github.com/yanxiu0614/subdomain3&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go语言开发的子域名枚举工具
&lt;code>https://github.com/caffix/amass&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>继承于Sublist3r项目的模块化体系结构
&lt;code>https://github.com/Ice3man543/subfinder&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>带有网页截图功能的子可视化域名枚举工具
&lt;code>https://github.com/janniskirschner/horn3t&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lijiejie开发的一款使用广泛的子域名爆破枚举工具
&lt;code>https://github.com/lijiejie/subDomainsBrute&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>猪猪侠开发的一款域名收集全面、精准的子域名枚举工具
&lt;code>https://github.com/ring04h/wydomain&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="子域名监控">子域名监控&lt;/h3>
&lt;p>&lt;code>https://github.com/LangziFun/LangSrcCurise&lt;/code>&lt;/p>
&lt;p>&lt;code>https://www.freebuf.com/sectool/198396.html&lt;/code>&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/m8ucI1bDxILM8wLU6pLmoQ">1&lt;/a>
&lt;a href="https://xz.aliyun.com/t/3478">2&lt;/a>
&lt;a href="https://blog.csdn.net/qq_39293438/article/details/104829825">3&lt;/a>
&lt;a href="https://info.menandmice.com/blog/bid/73645/Take-your-DNSSEC-with-a-grain-of-salt">4&lt;/a>&lt;/p></description></item><item><title>开启 Telegram 的邮箱登录</title><link>https://blog.baicai.me/article/2023/telegram_email_login/</link><pubDate>Tue, 26 Dec 2023 15:00:23 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/telegram_email_login/</guid><description>&lt;h2 id="telegram的邮箱登录是什么-有什么用">Telegram的邮箱登录是什么? 有什么用?&lt;/h2>
&lt;p>邮箱登录就是通过电子邮件获取验证码来登录Telegram账户, 此功能可以在把验证码发送到Telegram客户端的情况下同时向邮箱发送一份验证码, 而不是通过短信发送验证码. 极大减少了Telegram官方的短信费用支出. 对于使用接码的用户来说, 再也不怕没客户端也没手机号的情况下收不到验证码了!&lt;/p>
&lt;h2 id="如何开启telegram邮箱登录">如何开启Telegram邮箱登录?&lt;/h2>
&lt;p>&lt;code>注意 账号绑定的手机号需要可以接收短信验证码, 否则无法设置邮箱登录&lt;/code>&lt;/p>
&lt;p>根据&lt;a href="https://core.telegram.org/api/auth">官方文档&lt;/a>来看,&lt;/p>
&lt;ul>
&lt;li>auth.sentCodeTypeSetUpEmailRequired: if the user logins often enough, Telegram will ask the user to verify an email that will be used to send the login code.&lt;/li>
&lt;li>当你的登录频率足够高时, Telegram服务器会要求客户端设置邮箱登录&lt;/li>
&lt;/ul>
&lt;h3 id="具体方法">具体方法&lt;/h3>
&lt;ul>
&lt;li>使用Telegram官方移动客户端登录, 登录时选择 Tap to get a code via SMS&lt;/li>
&lt;li>短信验证码和Telegram客户端验证码一致, 任选其一输入即可, 不需要输入2FA密码, 直接返回重新刷&lt;/li>
&lt;/ul>
&lt;p>如果过程中出现 &lt;code>Too many attemps, please try again later&lt;/code> 则需要休息一段时间再刷&lt;/p>
&lt;p>直到出现让你选择登录邮箱的提示界面&lt;/p>
&lt;p>根据提示输入完成邮箱验证码后会向你的账号绑定手机号码发送短信验证码, 输入完即可开启邮箱登录 (2FA可以不输入)&lt;/p>
&lt;h2 id="如何判断有没有开启邮箱登录">如何判断有没有开启邮箱登录?&lt;/h2>
&lt;p>在设置-隐私与安全界面，可看到已设置的“登录邮箱”&lt;/p>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;p>&lt;a href="https://telegra.ph/Telegram%E7%9A%84%E9%82%AE%E7%AE%B1%E7%99%BB%E5%BD%95-12-26">Telegram的邮箱登录&lt;/a>&lt;br>
&lt;a href="https://core.telegram.org/api/auth#email-verification">User Authorization&lt;/a>&lt;/p></description></item><item><title>通过 ADB 卸载系统自带应用(无需Root),精简系统app</title><link>https://blog.baicai.me/article/2023/adb_pm_uninstall/</link><pubDate>Tue, 05 Dec 2023 13:31:02 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/adb_pm_uninstall/</guid><description>&lt;h3 id="准备-adb-使用条件">准备 ADB 使用条件&lt;/h3>
&lt;p>要使用 ADB（Android 调试桥），你需要按照以下步骤操作：&lt;/p>
&lt;p>下载并安装 ADB 工具：&lt;/p>
&lt;pre>&lt;code>在计算机上安装 Android SDK 或者仅安装 ADB 工具。你可以从 Android 官方网站或者其他可信赖的来源获取它们。
如果你使用 macOS 或 Linux，你可以通过终端使用系统包管理器或 Homebrew 安装 ADB。
如果你使用 Windows，你可以下载 Android Studio，它包含了 ADB 工具。
&lt;/code>&lt;/pre>
&lt;p>连接 Android 设备：&lt;/p>
&lt;pre>&lt;code>使用 USB 线将 Android 设备连接到计算机上。
在 Android 设备上打开开发者选项。这通常需要在设备设置中多次点击“关于手机” -&amp;gt; “版本号”或者类似的选项。一旦开启，返回设置菜单并找到“开发者选项”。
在“开发者选项”中，启用“USB 调试”。
&lt;/code>&lt;/pre>
&lt;p>打开命令提示符（Windows）/终端（macOS、Linux）：&lt;/p>
&lt;pre>&lt;code>运行以下命令以确保 ADB 正确识别设备：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb devices
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这应该显示已连接设备的列表。&lt;/p>
&lt;h3 id="使用-adb-列出已经安装的应用程序">使用 ADB 列出已经安装的应用程序&lt;/h3>
&lt;p>打开命令提示符（Windows）/终端（macOS、Linux）：&lt;/p>
&lt;pre>&lt;code>在命令提示符/终端中输入以下命令来列出已安装的应用程序：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb shell pm list packages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你想筛选出包含特定关键词的应用程序，可以使用以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb shell pm list packages | grep keyword
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 &amp;ldquo;keyword&amp;rdquo; 替换为你想要搜索的关键词。
比如魅族的手机&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb shell pm list packages | grep com.meizu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-adb-在-android-设备上卸载普通应用程序">使用 ADB 在 Android 设备上卸载普通应用程序&lt;/h3>
&lt;p>打开命令提示符（Windows）/终端（macOS、Linux）：&lt;/p>
&lt;pre>&lt;code>在命令提示符/终端中输入以下命令来卸载应用程序：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> adb uninstall package_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>将 package_name 替换为你想要卸载的应用程序的包名。你可以通过之前提到的 adb shell pm list packages 命令来获取应用程序的包名列表。
&lt;/code>&lt;/pre>
&lt;p>示例：&lt;/p>
&lt;pre>&lt;code>假设你想卸载名为 &amp;quot;com.example.app&amp;quot; 的应用程序，命令将如下所示：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> adb uninstall com.example.app
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>确认卸载：&lt;/p>
&lt;pre>&lt;code>执行命令后，ADB 会尝试卸载该应用程序。等待一段时间，命令提示符/终端会显示成功或失败的信息。
&lt;/code>&lt;/pre>
&lt;p>这个指令卸载系统自带应用可以能会遇到 &lt;code>Failure [DELETE_FAILED_INTERNAL_ERROR]&lt;/code> 错误提示&lt;/p>
&lt;h3 id="使用-adb-在-android-设备上卸载系统自带应用程序">使用 ADB 在 Android 设备上卸载系统自带应用程序&lt;/h3>
&lt;p>清除应用程序数据：&lt;/p>
&lt;pre>&lt;code>在卸载应用之前，尝试先清除该应用的数据。使用以下命令：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> adb shell pm clear package_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>将 package_name 替换为应用程序的包名。
&lt;/code>&lt;/pre>
&lt;p>强制停止应用程序：&lt;/p>
&lt;pre>&lt;code>如果应用程序正在运行，尝试通过 ADB 强制停止应用程序再进行卸载：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb shell am force-stop package_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 package_name 替换为应用程序的包名。&lt;/p>
&lt;p>确保设备有足够的存储空间来完成卸载操作。有时设备存储空间不足可能会导致卸载失败。&lt;/p>
&lt;p>使用 ADB shell 运行命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> package_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 package_name 替换为要卸载的系统应用的包名。&lt;/p>
&lt;h4 id="列出魅族自带的部分应用程序">列出魅族自带的部分应用程序&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#列出包名前缀为 com.meizu 应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$adb shell pm list packages | grep com.meizu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.documentsui
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.hometools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.launcher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.desktopbackup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.account.pay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.powersave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.mzsimcontacts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.filemanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.directservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.compaign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.splitloccontroller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.backup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.net.map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.wallet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.feedback
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.camera
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.providers.forcetouch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.mstore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.net.search
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.perfui
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.sceneinfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.telecom
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.notepaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.calculator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.yellowpage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.safe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.reader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.toolbox
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.connectivitysettings
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.childrenlauncher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.gamecenter.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.mznfcpay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.account
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.ebook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.music
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.video
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.gallery
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.alphame
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.dataservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.systemwallpaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flymecommunication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.mall
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.voiceassistant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.cloud
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.mcare
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.share
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.easylauncher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.battery
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.mzsyncservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.privacy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.datamigration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.location
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.service.find
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.customizecenter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.gamecenter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.experiencedatasync
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.callsetting
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.netcontactservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.media.life
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package:com.meizu.flyme.weather
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="卸载魅族自带的部分应用程序">卸载魅族自带的部分应用程序&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$adb shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#语音助手&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.voiceassistant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#天气预报&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.weather
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#备份与恢复&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.backup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#手机云备份&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.desktopbackup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#换机助手&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.datamigration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#福利中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.compaign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#钱包&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.wallet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.mznfcpay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#全球虚拟流量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.flyme.roamingpay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#地图&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.net.map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#快应用引擎&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.directservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#云号码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.netcontactservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#生活服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.life
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#游戏中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.gamecenter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.gamecenter.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#音乐&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.music
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#视频&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.video
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#读书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.ebook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#新闻资讯&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.reader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#便签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.notepaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#应用商店&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.mstore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.flyme.meizu.store
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#系统更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#魅族服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.mcare
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.mall
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#用户帮助&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.feedback
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#搜索&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.net.search
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#文件管理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.filemanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#动态壁纸&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.vlife.mxlock.wallpaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#输入法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.sohu.inputmethod.sogou
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#浏览器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.browser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 家庭守护&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.sceneinfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#京东&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.jingdong.app.mall
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#天猫&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.tmall.wireless
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#微博&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.sina.weibo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#高德地图&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.autonavi.minimap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#今日头条&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.ss.android.article.news
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#去哪儿&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.Qunar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#喜马拉雅&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.ximalaya.ting.android
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#趣视频&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#拼多多&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.xunmeng.pinduoduo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#百度搜索&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.baidu.searchbox
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#微博&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.sina.weibolite
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#flyme实验室&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flymelab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#好看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.baidu.haokan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#淘宝&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.taobao.taobao
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#搜狗输入法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.sohu.inputmethod.sogou.meizu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#唯品会&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.achievo.vipshop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#部分系统应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#计步器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.net.pedometer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#支付中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.account.pay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#个人助理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.assistant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#智能识屏&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.picker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#工具箱&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.toolbox
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#系统壁纸&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.systemwallpaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#动态主题服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.ibimuyu.lockscreen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#下载&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.providers.downloads.ui
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#动态壁纸 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.activeviewlivewallpaper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#主题美化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.customizecenter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#onemind&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.alphame
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#以下部分不建议删除应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.hometools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.providers.downloads
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.calculator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.yellowpage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.safe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.printspooler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.media.gallery
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.cloud
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.share
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.location
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.email
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.mzsyncservice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.android.wallpaperbackup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.mmfvideo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.flyme.telecom.usagedata.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#谨慎删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.account
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pm uninstall -k --user &lt;span style="color:#ae81ff">0&lt;/span> com.meizu.flyme.service.find
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="附注">附注：&lt;/h3>
&lt;p>安装 APK 文件：
将要安装的 APK 文件复制到计算机上，并记住它的路径。
在命令提示符/终端中，使用以下命令安装 APK 文件到设备：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>adb install /path/to/your/app.apk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请将 &lt;code>/path/to/your/app.apk&lt;/code> 替换为实际 APK 文件的路径。&lt;/p>
&lt;h3 id="flyme9-应用列表">Flyme9 应用列表&lt;/h3>
&lt;pre tabindex="0">&lt;code>全球流量 com.flyme.roamingpay
旅行助手com.android.cts.priv.ctsshim
应用沙盒com.meizu.pps 不建议删除
计步器 com.meizu.net.pedometer
电话和短信存储 com.android.providers.telephony 不建议删除
日历存储com.android.providers.calendar 不建议删除
媒体存储设备 com.android.providers.media 不建议删除
mbn测试 com.qualcomm.qit.modemtestmode 不建议删除
系统桌面 com.meizu.flyme.launcher 不建议删除
支付中心 com.meizu.account.pay
时钟 com.andriod.alarmclock
html查看程序 com.android.htmlviewer 不建议删除
语音设置com.iflytek.speechsuite
mms短信服务 com.android.mms.service 不建议删除
下载管理器com.android.providers.downloads 不建议删除
文件管理 com.meizu.filemanager 不建议删除
通讯录counnunity.fairphone.mycontacts 不建议删除
魅族浏览器 com.android.browser
快应用引擎 com.meizu.flyme.directservice
福利中心 com.meizu.compaign
录音机 com.android.soundrecorder
软件包权限帮助程序com.android.defcontainer 不建议删除
备份和恢复com.meizu.backup
下载com.android.providers.downloads.ui 不建议删除
系统更新com.meizu.flyme.update
无线网络助手com.meizu.wifiadmin 不建议删除
证书安装程序com.android.certinstaller 不建议删除
个人助理com.meizu.assistant
钱包com.meizu.flyme.wallet
用户帮助com.meizu.feedback
相机com.meizu.media.camera 不建议删除
设备信息com.qti.qualcomm.deviceinfo 不建议删除
信息com.android.mms 不建议删除
应用商店com.meizu.mstore 不建议删除
mtp主机com.android.mtp 不建议删除
usim卡应用com.android.stk
搜索com.meizu.net.search
性能监视器com.meizu.perfui
智能识屏 com.meizu.picker
家庭守护com.meizu.sceneinfo
便笺com.meizu.notepaper
计算器com.flyme.caculator
日历com.android.calendar
手机管家com.meizu.safe 不建议删除
新闻资讯com.meizu.media.reader
工具箱com.flyme.toolbox
网络设置com.connectivitysettings 不建议删除
设置存储com.android.providers.settings 不建议删除
打印处理服务com.android.printspooler
通话com.android.incallui 不建议删除
输入设备com.android.inputdevices · 不建议删除
系统公共组件com.meizu.flyme.sdkstage 不建议删除
系统界面助手com.flyme.systemuiex 不建议删除
默认打印服务com.android.bips
魅族游戏框架com.meizu.gamecenter.service
动态主题服务com.ibimuyu.lockscreen 不建议删除
xdivert设置com.qti.xdivert
musicfx com.android.musicfx
通话控制com.android.server.telecom 不建议删除
魅族支付com.meizu.mznfcpay
密钥连com.android.keychain
电话com.android.dialer 不建议删除
系统界面工具com.flyme.systemuitools 不建议删除
flyme账号com.meizu.account 不建议删除 删除后进不了自带的系统设置
软件包安装程序com.android.packageinstaller 不建议删除
音乐com.meizu.media.music
视频com.meizu.media.video
运营商默认应用com.android.carrierdefaultapp
文本转语音组件com.svox.pico
图库com.meizu.media.gallery
onemind com.meizu.alphame
工作资料设置com.android.managedprovisioning 不建议删除
platformfx com.meizu.dateservice 不建议删除
网络管理com.flyme.netadmin 不建议删除
远程协助com.meizu.remotecooperation
工程模式com.meizu.telephonyengineermode
系统壁纸com.meizu.systemwallpaper
sms推送com.android.smspush 不建议删除
语音助手com.meizu.voiceassistant
推送服务com.meizu.cloud 不建议删除
魅族虚拟卡本地注册虚拟网络插件com.flyme.virtual.softsim 删除后无法使用全球流量功能
蓝牙分享com.meizu.share 不建议删除
魅族商城com.flyme.meizu.store
超大字体简易模式com.meizu.flyme.easylauncher
图像服务com.meizu.media.imageservice 不建议删除
存储空间管理器com.android.stooragemanager 不建议删除
人脸识别com.meizu.facerecognition
com.google.andriod.onetimeinitialzer
设置com.android.settings 不建议删除
电量管理com.meizu.battery
flyme云服务com.meizu.mzsyncservice
动态壁纸 com.meizu.activeviewlivewallpaper
换机助手com.meizu.datemigration
位置服务com.qualcomm.location 不建议删除
网络位置服务com.meizu.location 不建议删除
动态主题服务com.vlife.mxlock.wallpaper
桌面壁纸备份 com.android.wallpaperbackup
系统输入法com.meizu.flyme.input 不建议删除
查找手机服务com.meizu.flyme.service.find
电话服务com.android.phone 不建议删除
存储已屏蔽的号码com.android.providers.blockednumber 不建议删除
用户字典com.android.providers.userdictionary
急救信息com.android.emergency 不建议删除
主题美化com.meizu.customizecenter
flyme实验室com.meizu.flymelab
一体化位置信息com.android.location.fused 不建议删除
游戏中心com.meizu.flyme.gamecenter
系统界面com.android.systemui 不建议删除
崩溃数据上传 com.meizu.experiencedatasync
电话设置com.meizu.callsetting 不建议删除
关机闹钟com.qualcomm.qti.poweroffalarm 不建议删除
号码云服务com.meizu.netcontactservice
生活助手com.meizu.media.life
联系人存储com.android.providers.contacts 不建议删除
天气com.meizu.flyme.weather
支付宝com.eg.android.AlipayGphone
电话服务com.flyme.telecom.usagedate.service 不建议删除
com.qualcomm.qti.perfdump 不建议删除
com.android.webview 不建议删除
com.android.backupconfirm
书签com.android.bookmarkprovider
com.android.flyme.bridge.softsim
com.meizu.privacy
com.meizu.flyme.hometools 不建议删除
小区广播com.android.cellbroadcastreceiver 不建议删除
无线网络助手 com.meizu.wifiadmin 不建议删除
读书 com.meizu.media.ebook
邮件 com.android.email
趣视频 com.flyme.videoclips
新闻资讯 com.meizu.media.reader
换机助手 com.meizu.datamigration
语音设置 com.iflytek.speechsuite
魅族服务 com.meizu.mcare
开机引导 com.meizu.setup
极限模式 com.meizu.powersave 不建议删除
Aicy建议 com.meizu.suggestion
锁屏画报 com.meizu.net.nativelockscreen
伪基站拦截 com.meizu.mzbasestationsafe
打印服务处理 com.android.printspooler 不建议删除
html查看程序 com.android.htmlviewer
通话记录备份 com.android.calllogbackup
虚拟sim卡用的com.qualcomm.uimremoteclient
自带黑色主题com.android.systemui.theme.dark
无线电服务com.dsi.ant.server
&lt;/code>&lt;/pre></description></item><item><title>Kubernetes 停止和移除 pod</title><link>https://blog.baicai.me/article/2023/delete_pod/</link><pubDate>Mon, 20 Nov 2023 16:02:50 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/delete_pod/</guid><description>&lt;h2 id="停止和移除pod">停止和移除pod&lt;/h2>
&lt;h3 id="按名称删除pod">按名称删除pod&lt;/h3>
&lt;p>按名称删除kubia-gpu pod：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete po kubia-gpu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在删除pod的过程中，实际上我们在指示Kubernetes终止该pod中的所有容器。Kubernetes向进程发送一个SIGTERM信号并等待一定的秒数（默认为30），使其正常关闭。如果它没有及时关闭，则通过SIGKILL终止该进程。因此，为了确保你的进程总是正常关闭，进程需要正确处理SIGTERM信号。&lt;/p>
&lt;h4 id="提示">提示&lt;/h4>
&lt;p>还可以通过指定多个空格分隔的名称来删除多个pod（例如：kubectl delete po pod1 pod2）。&lt;/p>
&lt;h3 id="使用标签选择器删除pod">使用标签选择器删除pod&lt;/h3>
&lt;p>停止 kubia-manual 和 kubia-manual-v2 pod 。这两个pod都包含标签 &lt;code>creation_method=manual&lt;/code> ，因此可以通过使用一个标签选择器来删除它们：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete po -l creation_method&lt;span style="color:#f92672">=&lt;/span>manual
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过删除整个命名空间来删除pod">通过删除整个命名空间来删除pod&lt;/h3>
&lt;p>以下命令删除custom-namespace：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete ns custom-namespace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除命名空间中的所有pod但保留命名空间">删除命名空间中的所有pod，但保留命名空间&lt;/h3>
&lt;p>查看 pods&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pods
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过使用&amp;ndash;all选项告诉Kubernetes删除当前命名空间中的所有pod：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete po --all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除命名空间中的几乎所有资源">删除命名空间中的（几乎）所有资源&lt;/h3>
&lt;p>通过使用单个命令删除当前命名空间中的所有资源，可以删除ReplicationCcontroller和pod，以及我们创建的所有service：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete all --all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令中的第一个all指定正在删除所有资源类型，而&amp;ndash;all选项指定将删除所有资源实例，而不是按名称指定它们（我们在运行前一个删除命令时已经使用过此选项）。&lt;/p>
&lt;h4 id="注意">注意&lt;/h4>
&lt;p>使用all关键字删除所有内容并不是真的完全删除所有内容。一些资源会被保留下来，并且需要被明确指定删除。&lt;/p>
&lt;p>删除资源时，kubectl将打印它删除的每个资源的名称。&lt;/p>
&lt;h4 id="注意-1">注意&lt;/h4>
&lt;p>&lt;code>kubectl delete all --all&lt;/code> 命令也会删除名为kubernetes的Service，但它应该会在几分钟后自动重新创建。&lt;/p>
&lt;h2 id="kubectl-命令演示">kubectl 命令演示&lt;/h2>
&lt;h3 id="kubectl-展示搜索出的pod列表含pod所在的namespace">kubectl 展示搜索出的pod列表（含pod所在的namespace）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get pod -A |grep &amp;lt;podname&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get pod -A |grep dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubernetes-dashboard dashboard-metrics-scraper-5657497c4c-j5kr8 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 113m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubernetes-dashboard kubernetes-dashboard-78f87ddfc-tlmjv 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 113m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kubectl-删除pod命令">kubectl 删除pod命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete pod &amp;lt;podname&amp;gt; -n &amp;lt;namespace&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在进行删除pod命令时，会发现pod并未被真正删除，原因是k8s误认为我们要删除的pod异常挂了，会启用容灾机制，导致重新在拉起一个新的pod。
故，我们想要正常且彻底的删除一个pod，必须要先破坏掉他的容灾机制，即删除deployment机制。&lt;/p>
&lt;h3 id="查看deployment信息">查看deployment信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl get deployment -n &amp;lt;namespace&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@debian ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get deployment --all-namespaces&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE NAME READY UP-TO-DATE AVAILABLE AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system coredns 2/2 &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> 4h7m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubernetes-dashboard dashboard-metrics-scraper 1/1 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 117m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubernetes-dashboard kubernetes-dashboard 1/1 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 117m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除deployment配置">删除deployment配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete deployment &amp;lt;deployment名&amp;gt; -n &amp;lt;namespace&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl delete deployment kubernetes-dashboard -n kubernetes-dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deployment.apps &lt;span style="color:#e6db74">&amp;#34;kubernetes-dashboard&amp;#34;&lt;/span> deleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl delete deployment dashboard-metrics-scraper -n kubernetes-dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deployment.apps &lt;span style="color:#e6db74">&amp;#34;dashboard-metrics-scraper&amp;#34;&lt;/span> deleted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="然后进行删除pod命令即可我删除deployment后再次查询pod发现上面的pod已经开始自行删除了这步可酌情处理">然后进行删除pod命令即可，我删除deployment后，再次查询pod发现，上面的pod已经开始自行删除了（这步可酌情处理）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete pod &amp;lt;podname&amp;gt; -n &amp;lt;namespace&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># delete pod dashboard-metrics-scraper-5657497c4c-j5kr8 -n kubernetes-dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pod &lt;span style="color:#e6db74">&amp;#34;dashboard-metrics-scraper-5657497c4c-j5kr8&amp;#34;&lt;/span> deleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 附一个我这边删除deployment后pod自行删除的情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@node ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># kubectl get pod -A|grep dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docker的 privileged 选项解析（特权模式：赋予容器几乎与主机相同的权限）</title><link>https://blog.baicai.me/article/2023/docker_privileged/</link><pubDate>Fri, 17 Nov 2023 22:52:38 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_privileged/</guid><description>&lt;h3 id="runtime-privilege-and-linux-capabilities">Runtime privilege and Linux capabilities&lt;/h3>
&lt;p>参考官方文档：&lt;a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker run reference&lt;/a>&lt;/p>
&lt;p>By default, Docker containers are &amp;ldquo;unprivileged&amp;rdquo; and cannot, for example, run a Docker daemon inside a Docker container. This is because by default a container is not allowed to access any devices, but a &amp;ldquo;privileged&amp;rdquo; container is given access to all devices (see the documentation on cgroups devices).&lt;/p>
&lt;p>The &amp;ndash;privileged flag gives all capabilities to the container. When the operator executes docker run &amp;ndash;privileged, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with &amp;ndash;privileged is available on the &lt;a href="https://www.docker.com/blog/docker-can-now-run-within-docker/">Docker Blog&lt;/a>.&lt;/p>
&lt;h2 id="docker-容器的安全性">Docker 容器的安全性&lt;/h2>
&lt;h3 id="linux-namespace-和-capabilities">Linux Namespace 和 Capabilities&lt;/h3>
&lt;p>Docker使用Linux namespace和capabilities来实现容器隔离和限制权限。&lt;/p>
&lt;pre>&lt;code>Linux Namespace：Docker利用namespace技术，使得每个容器都有其自己的进程、网络、挂载、用户ID等独立的空间。这保证了容器与容器之间以及容器与主机之间的隔离性。
Capabilities：Linux capabilities允许将传统的root权限分割成多个不同的能力，例如CAP_NET_ADMIN能力允许操作网络配置，CAP_CHOWN能力允许改变文件所有权。Docker默认情况下会赋予容器一些必要的capabilities，但不包括全部的能力，从而降低了被攻击的风险。
&lt;/code>&lt;/pre>
&lt;p>Docker 通过 &amp;ndash;cap-add 和 &amp;ndash;cap-drop 两个参数，可以灵活地添加或删除容器的 capabilities。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --cap-add&lt;span style="color:#f92672">=&lt;/span>SYS_PTRACE --rm -it alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面 &lt;code>--cap-add=SYS_PTRACE&lt;/code> 的意思就是：给容器添加 SYS_PTRACE 权限，允许容器内的进程可以 ptrace 和 debug 其他进程。&lt;/p>
&lt;h3 id="docker限制和权限">Docker限制和权限&lt;/h3>
&lt;p>在默认情况下，Docker对容器的权限进行了严格的限制，只提供了有限的capabilities。此外，许多系统级别的操作（例如挂载文件系统、修改内核参数等）都是被禁止的。这种安全模型使得Docker可以在不牺牲安全性的前提下，实现轻量级的虚拟化。&lt;/p>
&lt;p>然而，在某些情况下，我们可能需要赋予容器更多的权限。例如，如果我们需要在容器中运行一些需要特权的服务（如网络设备管理、硬件设备接口等），那么默认的权限可能就不够用了。这时候，&lt;code>--privileged=true&lt;/code> 选项就派上了用场。&lt;/p>
&lt;h4 id="docker的privilegedtrue选项">Docker的–privileged=true选项&lt;/h4>
&lt;p>当使用&amp;ndash;privileged=true选项运行容器时，Docker会赋予容器几乎与主机相同的权限。
具体来说，这个选项做了以下两件事情：&lt;/p>
&lt;pre tabindex="0">&lt;code> 给容器添加了所有的capabilities
允许容器访问主机的所有设备
&lt;/code>&lt;/pre>&lt;h4 id="privilegedtrue的风险">&amp;ndash;privileged=true的风险&lt;/h4>
&lt;p>尽管 &lt;code>--privileged=true&lt;/code> 选项为容器提供了强大的功能，但它也带来了一些严重的安全隐患。由于privileged容器具有几乎与主机相同的权限，所以如果容器被恶意代码控制，那么攻击者就可以轻易地突破容器的边界，对主机进行任意操作。&lt;/p>
&lt;p>因此，我们需要谨慎地使用 &lt;code>--privileged=true&lt;/code> 选项，只在真正需要的情况下才启用它。在可能的情况下，我们应该尽量使用其他更细粒度的权限控制手段，例如通过&lt;code>--cap-add&lt;/code>或&lt;code>--device&lt;/code>参数来分别添加必要的capabilities或设备访问权限。&lt;/p>
&lt;h4 id="细粒度的权限控制手段">细粒度的权限控制手段&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加单个capability&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --rm --cap-add NET_ADMIN -it alpine sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加设备访问权限&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --device&lt;span style="color:#f92672">=&lt;/span>/dev/sda:/dev/xvdc -it alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="docker-compose-参考">docker-compose 参考&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">baicai_image&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">debian&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;baicai_image&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run -c /app/config.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./config.json:/app/config.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;80:80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">privileged&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cap_add&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">NET_ADMIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_MODULE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_PTRACE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_ADMIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">NET_RAW&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cap_drop&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">ALL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="附注-在docker-debian容器中安装pstop等命令">附注: 在Docker Debian容器中安装ps、top等命令&lt;/h3>
&lt;p>debian镜像默认没有包括进程管理相关工具，在实际使用时可能有些麻烦，如果需要也可以自己安装，使用如下命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> apt install -y procps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Debian 彻底卸载 LibreOffice</title><link>https://blog.baicai.me/article/2023/debian_remove_libreoffice/</link><pubDate>Mon, 09 Oct 2023 10:15:40 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/debian_remove_libreoffice/</guid><description>&lt;p>LibreOffice是一款非常优秀的开源且免费的办公软件。但我用不到，为了优化更新系统的速度，所以这就卸载了，这不就几条命令的事。&lt;/p>
&lt;p>下面的指令对所有基于 Debian 发行版（Debian, Ubuntu, Kubuntu, Xubuntu, buntu, Sidux, Knoppix, Linux Mint, Damn Small Linux, Crunchbag 等）都适用。&lt;/p>
&lt;h3 id="彻底卸载-libreoffice">彻底卸载 LibreOffice&lt;/h3>
&lt;p>终端中输入命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#不要漏掉通配符“?”，否则无法清除/卸载全部 LibreOffice 软件包&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get purge libreoffice?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#不要漏掉通配符“?”，否则无法清除/卸载全部 LibreOffice 软件包&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo aptitude purge libreoffice?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#不要漏掉通配符“*”，否则无法清除/卸载全部 LibreOffice 软件包&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get remove --purge libreoffice*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后清理残留：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get clean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get autoremove
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="附注不完全卸载">附注（不完全卸载）：&lt;/h3>
&lt;p>卸载libreoffice表格&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt remove libreoffice-calc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>卸载libreoffice绘图&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt remove libreoffice-draw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>卸载libreoffice幻灯片&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt remove libreoffice-impress
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>卸载libreoffice word文档工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt remove libreoffice-writer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>清理残留&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt autoremove
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="libreoffice简介来自官网">LibreOffice简介（来自官网）：&lt;/h3>
&lt;p>LibreOffice 是一款功能强大的办公软件，默认使用开放文档格式 (OpenDocument Format , ODF), 并支持 *.docx, *.xlsx, *.pptx 等其他格式。&lt;/p>
&lt;p>它包含了 Writer, Calc, Impress, Draw, Base 以及 Math 等组件，可用于处理文本文档、电子表格、演示文稿、绘图以及公式编辑。&lt;/p>
&lt;p>它可以运行于 Windows, GNU/Linux 以及 macOS 等操作系统上，并具有一致的用户体验。&lt;/p></description></item><item><title>通过 WireGuard 搭建 VPN 访问家里内网</title><link>https://blog.baicai.me/article/2023/using_wireguard/</link><pubDate>Sun, 08 Oct 2023 15:19:08 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/using_wireguard/</guid><description>&lt;p>家里网络没有公网 IP，因此需要一台具有公网 IP 的服务器作为 WireGuard 网络的“server”。家中需要有一台设备作为 WireGuard 网络中的节点。我们将使用手机，在 4G 网络下检查 VPN 是否搭建成功。&lt;/p>
&lt;h2 id="ip-段选择">IP 段选择&lt;/h2>
&lt;p>WireGuard 组网需要使用一个不与你的任何设备的网络相冲突的 IP 地址段。像 192.0.2.0/24 、198.51.100.0/24 、203.0.113.0/24 这些分配为用于文档和示例中的“TEST-NET”，这些地址段通常不会被你需要连接的其他网络所使用。&lt;/p>
&lt;p>在下面的配置中，我会分别将 192.0.2.1、192.0.2.2、192.0.2.3 分配给公网服务器、家中的 Mac 和 iPhone。&lt;/p>
&lt;h2 id="在服务器上配置-wireguard">在服务器上配置 WireGuard&lt;/h2>
&lt;p>要使用 WireGuard，首先需要确保 Linux 内核支持。可使用 &lt;code>modinfo wireguard&lt;/code> 命令检查是否内置了 WireGuard。也可用过 &lt;code>uname -r&lt;/code> 检查内核版本是否为 5.6 以上。&lt;/p>
&lt;h3 id="安装-wireguard">安装 wireguard&lt;/h3>
&lt;p>Debian&lt;/p>
&lt;pre tabindex="0">&lt;code>apt install wireguard
&lt;/code>&lt;/pre>&lt;p>其他系统参考：&lt;a href="https://www.wireguard.com/install/">install&lt;/a>&lt;/p>
&lt;h3 id="完成服务器端的配置">完成服务器端的配置&lt;/h3>
&lt;p>在正确安装 wireguard 后，你可以通过如下命令快速创建一组公钥和私钥。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ wg genkey | tee peer_A.key | wg pubkey &amp;gt; peer_A.pub &amp;amp;&amp;amp; cat peer_A.key &amp;amp;&amp;amp; cat peer_A.pub
&lt;/code>&lt;/pre>&lt;p>创建 &lt;code>/etc/wireguard/wg0.conf&lt;/code> 并填配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(your server private key here)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ListenPort&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PreUp = echo WireGuard PreUp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostUp = iptables -I INPUT -p udp --dport 51820 -j ACCEPT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostDown = iptables -D INPUT -p udp --dport 51820 -j ACCEPT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ipv4 局域网够用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -A FORWARD -i wg0 -j ACCEPT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -D FORWARD -i wg0 -j ACCEPT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ipv4防火墙放行转发和NAT(访问公共网络)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ipv4防火墙放行转发和NAT(访问公共网络) 扩展防火墙规则(节点之间双向互联)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostUp = iptables -I FORWARD -i wg0 -j ACCEPT; iptables -I FORWARD -o wg0 -j ACCEPT; iptables -I INPUT -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -D INPUT -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#PreDown = echo WireGuard PreDown&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Mac at home&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(Mac public key here)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.2/32, 192.168.1.0/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># iPhone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(iPhone public key here)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 WireGuard 中，你需要手动给各个设备分配 IP，并确保每个设备都有唯一的 IP。Interface 包含了当前设备的设置，对于“服务端”来说，ListenPort 是必须的。下面的每一个 Peer 段代表了能连接到本设备的一个其他设备。&lt;/p>
&lt;p>配置文件保存后，我们可以使用 &lt;code>wg-quick up wg0&lt;/code> 来启用配置文件。wg-quick 会自动配置路由表，无需我们手动设置。&lt;/p>
&lt;p>记得放行 51820 UDP 端口。&lt;/p>
&lt;p>&lt;a href="https://blog.baicai.me/article/2023/oracle_vps_iptables/">iptables 配置参考&lt;/a>&lt;/p>
&lt;h2 id="家中mac端的配置">家中Mac端的配置&lt;/h2>
&lt;p>创建 &lt;code>/etc/wireguard/wg0.conf&lt;/code> 并填配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(private key of Mac)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.2/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">DNS&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1.1.1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(public key of server)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.0/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">(server ip address):51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PersistentKeepalive&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，我们将公网服务器作为唯一的 Peer，通过设置 PersistentKeepalive 来进行连接的保活。这里 AllowedIPs 的作用是确保来自于我们 WireGuard 子网网段来的流量能被本机的 WireGuard 虚拟网卡进行处理。&lt;/p>
&lt;h2 id="iphone-配置">iphone 配置&lt;/h2>
&lt;p>安装 WireGuard &lt;a href="https://itunes.apple.com/us/app/wireguard/id1441195209?ls=1&amp;amp;mt=8"> Download from App Store&lt;/a>&lt;/p>
&lt;p>这个配置可以参考应用商店的截屏。&lt;/p>
&lt;h2 id="设置开机启动">设置开机启动&lt;/h2>
&lt;p>如果你的系统使用systemd,如ubuntu，设置wireguard开机启动命令如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable wg-quick@wg0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启用服务器peer端转发">启用服务器Peer端转发&lt;/h2>
&lt;p>打开 &lt;code>/etc/sysctl.conf&lt;/code> 修改&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
&lt;/code>&lt;/pre>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#39;net.ipv4.ip_forward=1&amp;#39;&lt;/span> &amp;gt;&amp;gt; /etc/sysctl.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#39;net.ipv6.conf.all.forwarding=1&amp;#39;&lt;/span> &amp;gt;&amp;gt; /etc/sysctl.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sysctl -p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附注">附注&lt;/h2>
&lt;h3 id="保留地址段">保留地址段&lt;/h3>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80">保留IP地址&lt;/a>&lt;/p>
&lt;h3 id="小插曲">小插曲&lt;/h3>
&lt;p>当遇到错误提示：&lt;/p>
&lt;pre tabindex="0">&lt;code>/usr/bin/wg-quick: line 31: resolvconf: command not found [WireGuard | Debian]
&lt;/code>&lt;/pre>&lt;p>可以创建软链接解决&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ln -s /usr/bin/resolvectl /usr/local/bin/resolvconf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当遇到错误提示：&lt;/p>
&lt;pre tabindex="0">&lt;code>[SELF-SOLVED] Unit dbus-org.freedesktop.resolve1.service not found
&lt;/code>&lt;/pre>&lt;p>可以通过启动 systemd-resolved 服务解决&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start systemd-resolved.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable systemd-resolved.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置详解">配置详解&lt;/h3>
&lt;p>WireGuard 使用 INI 语法作为其配置文件格式。配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 &lt;code>/etc/wireguard/wg0.conf&lt;/code>。&lt;/p>
&lt;p>配置文件的命名形式必须为 &lt;code>${WireGuard 接口的名称}.conf&lt;/code>。通常情况下 WireGuard 接口名称以 &lt;code>wg&lt;/code> 为前缀，并从 &lt;code>0&lt;/code> 开始编号，但你也可以使用其他名称，只要符合正则表达式 &lt;code>^[a-zA-Z0-9_=+.-]{1,15}$&lt;/code> 就行。&lt;/p>
&lt;p>你可以选择使用 &lt;code>wg&lt;/code> 命令来手动配置 VPN，但一般建议使用 &lt;code>wg-quick&lt;/code>，它提供了更强大和用户友好的配置体验，可以通过配置文件来管理配置。&lt;/p>
&lt;h4 id="interface">[Interface]&lt;/h4>
&lt;p>定义本地 VPN 配置。例如：&lt;/p>
&lt;p>1.本地节点是客户端，只路由自身的流量，只暴露一个 IP。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Name = phone.example-vpn.dev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.5/32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;private key for phone.example-vpn.dev&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本地节点是中继服务器，它可以将流量转发到其他对等节点（peer），并公开整个 VPN 子网的路由。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Interface]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Name = public-server1.example-vpn.tld&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ListenPort&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PrivateKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;private key for public-server1.example-vpn.tld&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">DNS&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1.1.1.1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="-name"># Name&lt;/h4>
&lt;p>这是 INI 语法中的标准注释，用于展示该配置部分属于哪个节点。这部分配置会被 WireGuard 完全忽略，对 VPN 的行为没有任何影响。&lt;/p>
&lt;h4 id="address">Address&lt;/h4>
&lt;p>定义本地节点应该对哪个地址范围进行路由。如果是常规的客户端，则将其设置为节点本身的单个 IP（使用 CIDR 指定，例如 192.0.2.3/32）；如果是中继服务器，则将其设置为可路由的子网范围。
例如：&lt;/p>
&lt;p>常规客户端，只路由自身的流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>中继服务器，可以将流量转发到其他对等节点（peer）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以指定多个子网或 IPv6 子网：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24,2001:DB8::/64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="listenport">ListenPort&lt;/h4>
&lt;p>当本地节点是中继服务器时，需要通过该参数指定端口来监听传入 VPN 连接，默认端口号是 51820。常规客户端不需要此选项。&lt;/p>
&lt;h4 id="privatekey">PrivateKey&lt;/h4>
&lt;p>本地节点的私钥，所有节点（包括中继服务器）都必须设置。不可与其他服务器共用。&lt;/p>
&lt;p>私钥可通过命令 &lt;code>wg genkey &amp;gt; example.key&lt;/code> 来生成。&lt;/p>
&lt;h4 id="dns">DNS&lt;/h4>
&lt;p>通过 DHCP 向客户端宣告 DNS 服务器。客户端将会使用这里指定的 DNS 服务器来处理 VPN 子网中的 DNS 请求，但也可以在系统中覆盖此选项。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#如果不配置则使用系统默认 DNS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#可以指定单个 DNS：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">DNS&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1.1.1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#也可以指定多个 DNS：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">DNS&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">1.1.1.1,8.8.8.8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="table">Table&lt;/h4>
&lt;p>定义 VPN 子网使用的路由表，默认不需要设置。该参数有两个特殊的值需要注意：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Table&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">off : 禁止创建路由
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Table = auto（默认值） : 将路由添加到系统默认的 table 中，并启用对默认路由的特殊处理。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如：&lt;code>Table = 1234&lt;/code>&lt;/p>
&lt;h4 id="mtu">MTU&lt;/h4>
&lt;p>定义连接到对等节点（peer）的 MTU（Maximum Transmission Unit，最大传输单元），默认不需要设置，一般由系统自动确定。&lt;/p>
&lt;h4 id="preup">PreUp&lt;/h4>
&lt;p>启动 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。&lt;/p>
&lt;p>例如：
添加路由：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PreUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">ip rule add ipproto tcp dport 22 table 1234&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="postup">PostUp&lt;/h4>
&lt;p>启动 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;pre>&lt;code>从文件或某个命令的输出中读取配置值：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">wg set %i private-key /etc/wireguard/wg0.key &amp;lt;(some command here)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>添加一行日志到文件中：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">echo &amp;#34;$(date +%s) WireGuard Started&amp;#34; &amp;gt;&amp;gt; /var/log/wireguard.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>调用 WebHook：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">curl https://events.example.dev/wireguard/started&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>添加路由：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">ip rule add ipproto tcp dport 22 table 1234&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>添加 iptables 规则，启用数据包转发：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>强制 WireGuard 重新解析对端域名的 IP 地址：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">resolvectl domain %i &amp;#34;~.&amp;#34;; resolvectl dns %i 192.0.2.1; resolvectl dnssec %i yes&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="predown">PreDown&lt;/h4>
&lt;p>停止 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;pre>&lt;code>添加一行日志到文件中：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PreDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">echo &amp;#34;$(date +%s) WireGuard Going Down&amp;#34; &amp;gt;&amp;gt; /var/log/wireguard.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="postdown">PostDown&lt;/h4>
&lt;p>停止 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。
例如：&lt;/p>
&lt;pre>&lt;code>添加一行日志到文件中：
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostDown&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">echo &amp;#34;$(date +%s) WireGuard Down&amp;#34; &amp;gt;&amp;gt; /var/log/wireguard.log&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="peer">[Peer]&lt;/h4>
&lt;p>定义能够为一个或多个地址路由流量的对等节点（peer）的 VPN 设置。对等节点（peer）可以是将流量转发到其他对等节点（peer）的中继服务器，也可以是通过公网或内网直连的客户端。&lt;/p>
&lt;p>中继服务器必须将所有的客户端定义为对等节点（peer），除了中继服务器之外，其他客户端都不能将位于 NAT 后面的节点定义为对等节点（peer），因为路由不可达。对于那些只为自己路由流量的客户端，只需将中继服务器作为对等节点（peer），以及其他需要直接访问的节点。&lt;/p>
&lt;p>配置示例：&lt;/p>
&lt;p>对等节点（peer）是路由可达的客户端，只为自己路由流量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Name = public-server2.example-vpn.dev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">public-server2.example-vpn.dev:51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;public key for public-server2.example-vpn.dev&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.2/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是位于 NAT 后面的客户端，只为自己路由流量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Name = home-server.example-vpn.dev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">home-server.example-vpn.dev:51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;public key for home-server.example-vpn.dev&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是中继服务器，用来将流量转发到其他对等节点（peer）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[Peer]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Name = public-server1.example-vpn.tld&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">public-server1.example-vpn.tld:51820&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PublicKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;public key for public-server1.example-vpn.tld&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 路由整个 VPN 子网的流量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PersistentKeepalive&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">25&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="endpoint">Endpoint&lt;/h4>
&lt;p>指定远端对等节点（peer）的公网地址。如果对等节点（peer）位于 NAT 后面或者没有稳定的公网访问地址，就忽略这个字段。通常只需要指定中继服务器的 Endpoint，当然有稳定公网 IP 的节点也可以指定。例如：&lt;/p>
&lt;p>通过 IP 指定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">123.124.125.126:51820&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过域名指定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Endpoint&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">public-server1.example-vpn.tld:51820&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="allowedips">AllowedIPs&lt;/h4>
&lt;p>允许该对等节点（peer）发送过来的 VPN 流量中的源地址范围。同时这个字段也会作为本机路由表中 wg0 绑定的 IP 地址范围。如果对等节点（peer）是常规的客户端，则将其设置为节点本身的单个 IP；如果对等节点（peer）是中继服务器，则将其设置为可路由的子网范围。可以使用 , 来指定多个 IP 或子网范围。该字段也可以指定多次。&lt;/p>
&lt;p>当决定如何对一个数据包进行路由时，系统首先会选择最具体的路由，如果不匹配再选择更宽泛的路由。例如，对于一个发往 192.0.2.3 的数据包，系统首先会寻找地址为 192.0.2.3/32 的对等节点（peer），如果没有再寻找地址为 192.0.2.1/24 的对等节点（peer），以此类推。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>对等节点（peer）是常规客户端，只路由自身的流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是中继服务器，可以将流量转发到其他对等节点（peer）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是中继服务器，可以转发所有的流量，包括外网流量和 VPN 流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">0.0.0.0/0,::/0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是中继服务器，可以路由其自身和其他对等节点（peer）的流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32,192.0.2.4/32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对等节点（peer）是中继服务器，可以路由其自身的流量和它所在的内网的流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AllowedIPs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">192.0.2.3/32,192.168.1.1/24&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="publickey">PublicKey&lt;/h4>
&lt;p>对等节点（peer）的公钥，所有节点（包括中继服务器）都必须设置。可与其他对等节点（peer）共用同一个公钥。&lt;/p>
&lt;p>公钥可通过命令 &lt;code>wg pubkey &amp;lt; example.key &amp;gt; example.key.pub&lt;/code> 来生成，其中 example.key 是上面生成的私钥。&lt;/p>
&lt;h4 id="persistentkeepalive">PersistentKeepalive&lt;/h4>
&lt;p>如果连接是从一个位于 NAT 后面的对等节点（peer）到一个公网可达的对等节点（peer），那么 NAT 后面的对等节点（peer）必须定期发送一个出站 ping 包来检查连通性，如果 IP 有变化，就会自动更新Endpoint。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>本地节点与对等节点（peer）可直连：该字段不需要指定，因为不需要连接检查。&lt;/p>
&lt;p>对等节点（peer）位于 NAT 后面：该字段不需要指定，因为维持连接是客户端（连接的发起方）的责任。&lt;/p>
&lt;p>本地节点位于 NAT 后面，对等节点（peer）公网可达：需要指定该字段 PersistentKeepalive = 25，表示每隔 25 秒发送一次 ping 来检查连接。&lt;/p>
&lt;h3 id="共享一个-peersconf-文件">共享一个 peers.conf 文件&lt;/h3>
&lt;p>如果某个 peer 的公钥与本地接口的私钥能够配对，那么 WireGuard 会忽略该 &lt;code>peer&lt;/code>。利用这个特性，我们可以在所有节点上共用同一个 &lt;code>peer&lt;/code> 列表，每个节点只需要单独定义一个 &lt;code>[Interface]&lt;/code> 就行了，即使列表中有本节点，也会被忽略。具体方式如下：&lt;/p>
&lt;p>每个对等节点（peer）都有一个单独的 &lt;code>/etc/wireguard/wg0.conf&lt;/code> 文件，只包含 &lt;code>[Interface]&lt;/code> 部分的配置。&lt;/p>
&lt;p>每个对等节点（peer）共用同一个 &lt;code>/etc/wireguard/peers.conf&lt;/code> 文件，其中包含了所有的 peer。&lt;/p>
&lt;p>Wg0.conf 文件中需要配置一个 PostUp 钩子，内容为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PostUp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">wg addconf /etc/wireguard/peers.conf&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>K3s 快速入门指南:构建多云环境下的K3S集群</title><link>https://blog.baicai.me/article/2023/quick_start/</link><pubDate>Thu, 28 Sep 2023 20:29:29 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/quick_start/</guid><description>&lt;p>K3s 是轻量级的 Kubernetes。server最低只需要512M内存即可运行。&lt;/p>
&lt;p>不同账号甚至不同云服务商， 内网是不通的。所以要想办法实现跨公网的容器网络通信，保障任意一台节点上的pod能访问任意节点上的pod和service，和正常的kubernetes集群体验一致。&lt;/p>
&lt;p>参考入门指南和多云解决方案，重新整理&lt;/p>
&lt;p>目标：实现混合云(腾讯云服务器+甲骨文服务器+微软Azure服务器)境下的K3S集群&lt;/p>
&lt;h3 id="server安装">Server安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 局域网方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://get.k3s.io | sh -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 多云安装方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://get.k3s.io | sh -s - --node-external-ip&lt;span style="color:#f92672">=&lt;/span>Server公网地址 --flannel-backend&lt;span style="color:#f92672">=&lt;/span>wireguard-native
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>中国用户，可以使用以下方法加速安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 局域网方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR&lt;span style="color:#f92672">=&lt;/span>cn sh -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 多云安装方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR&lt;span style="color:#f92672">=&lt;/span>cn sh -s - --node-external-ip&lt;span style="color:#f92672">=&lt;/span>Server公网地址 --flannel-backend&lt;span style="color:#f92672">=&lt;/span>wireguard-native --flannel-external-ip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行此安装后：&lt;/p>
&lt;pre tabindex="0">&lt;code>K3s 服务将被配置为在节点重启后或进程崩溃或被杀死时自动重启。
将安装其他实用程序，包括 ```kubectl```、```crictl```、```ctr```、```k3s-killall.sh``` 和 ```k3s-uninstall.sh```。
kubeconfig 文件将写入到 ```/etc/rancher/k3s/k3s.yaml```，由 K3s 安装的 kubectl 将自动使用该文件。
&lt;/code>&lt;/pre>&lt;h3 id="安装其他-agent-节点">安装其他 Agent 节点&lt;/h3>
&lt;p>安装其他 Agent 节点并将它们添加到集群，请使用 K3S_URL 和 K3S_TOKEN 环境变量运行安装脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 局域网方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://get.k3s.io | K3S_URL&lt;span style="color:#f92672">=&lt;/span>https://myserver:6443 K3S_TOKEN&lt;span style="color:#f92672">=&lt;/span>mynodetoken sh -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 多云安装方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://get.k3s.io | K3S_URL&lt;span style="color:#f92672">=&lt;/span>https://Server公网地址:6443 K3S_TOKEN&lt;span style="color:#f92672">=&lt;/span>mynodetoken sh -s - --node-external-ip&lt;span style="color:#f92672">=&lt;/span>Agent公网地址
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 局域网方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR&lt;span style="color:#f92672">=&lt;/span>cn K3S_URL&lt;span style="color:#f92672">=&lt;/span>https://myserver:6443 K3S_TOKEN&lt;span style="color:#f92672">=&lt;/span>mynodetoken sh -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 多云安装方案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR&lt;span style="color:#f92672">=&lt;/span>cn K3S_URL&lt;span style="color:#f92672">=&lt;/span>https://Server公网地址:6443 K3S_TOKEN&lt;span style="color:#f92672">=&lt;/span>mynodetoken sh -s - --node-external-ip&lt;span style="color:#f92672">=&lt;/span>Agent公网地址
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>备注：
&lt;code>K3S_URL&lt;/code> 参数会导致安装程序将 K3s 配置为 Agent 而不是 Server。K3s Agent 将注册到在 URL 上监听的 K3s Server。&lt;code>K3S_TOKEN&lt;/code> 使用的值存储在 Server 节点上的 &lt;code>/var/lib/rancher/k3s/server/node-token&lt;/code> 中。
每台主机必须具有唯一的主机名。如果你的计算机没有唯一的主机名，请传递 K3S_NODE_NAME 环境变量，并为每个节点提供一个有效且唯一的主机名。&lt;/p>
&lt;h3 id="在本机访问k3s集群">在本机访问k3s集群&lt;/h3>
&lt;p>安装kubectl&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>brew install kubectl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>复制 Server 中 &lt;code>/etc/rancher/k3s/k3s.yaml&lt;/code> 的内容&lt;/p>
&lt;p>写入本机的&lt;code>~/.kube/config&lt;/code>文件.&lt;/p>
&lt;p>参考scp复制指令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>scp server:/etc/rancher/k3s/k3s.yaml ~/.kube/config
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试指令">测试指令&lt;/h3>
&lt;p>查看节点状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS ROLES AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm-4-10-debian Ready &amp;lt;none&amp;gt; 35m v1.27.6+k3s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm-4-9-debian Ready control-plane,master 39m v1.27.6+k3s1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查跨网通讯：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get pod -A -o wide
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system local-path-provisioner-957fdf8bc-gcgj4 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 38m 10.42.0.5 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system coredns-77ccd57875-vsxmt 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 38m 10.42.0.6 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system helm-install-traefik-crd-sv9jh 0/1 Completed &lt;span style="color:#ae81ff">0&lt;/span> 38m 10.42.0.4 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system metrics-server-5f8b4ffd8-zd4db 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 38m 10.42.0.3 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system helm-install-traefik-jp8sk 0/1 Completed &lt;span style="color:#ae81ff">2&lt;/span> 38m 10.42.0.2 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system svclb-traefik-0782c5d1-wr5kd 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 37m 10.42.0.7 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system traefik-64f55bb67d-4lr2g 1/1 Running &lt;span style="color:#ae81ff">0&lt;/span> 37m 10.42.0.8 vm-4-9-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system svclb-traefik-0782c5d1-444jv 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 34m 10.42.1.2 vm-4-10-debian &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看节点资源使用情况：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl top node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME CPU&lt;span style="color:#f92672">(&lt;/span>cores&lt;span style="color:#f92672">)&lt;/span> CPU% MEMORY&lt;span style="color:#f92672">(&lt;/span>bytes&lt;span style="color:#f92672">)&lt;/span> MEMORY%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm-4-9-debian 24m 2% 1369Mi 69%
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm-4-10-debian &amp;lt;unknown&amp;gt; &amp;lt;unknown&amp;gt; &amp;lt;unknown&amp;gt; &amp;lt;unknown&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看POD资源使用情况:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl top pod -A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAMESPACE NAME CPU&lt;span style="color:#f92672">(&lt;/span>cores&lt;span style="color:#f92672">)&lt;/span> MEMORY&lt;span style="color:#f92672">(&lt;/span>bytes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system coredns-77ccd57875-vsxmt 1m 20Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system local-path-provisioner-957fdf8bc-gcgj4 1m 14Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system metrics-server-5f8b4ffd8-zd4db 3m 24Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system svclb-traefik-0782c5d1-wr5kd 0m 0Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kube-system traefik-64f55bb67d-4lr2g 1m 33Mi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到此k3s集群部署完成， 如果有更多的主机，可以重复agent的配置步骤进行添加。&lt;/p>
&lt;h3 id="k3s-server-节点的入站规则">K3s Server 节点的入站规则&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">协议&lt;/th>
&lt;th style="text-align: center">端口&lt;/th>
&lt;th style="text-align: center">源&lt;/th>
&lt;th style="text-align: center">目标&lt;/th>
&lt;th style="text-align: left">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">TCP&lt;/td>
&lt;td style="text-align: center">2379-2380&lt;/td>
&lt;td style="text-align: center">Servers&lt;/td>
&lt;td style="text-align: center">Servers&lt;/td>
&lt;td style="text-align: left">只有具有嵌入式 etcd 的 HA 需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">TCP&lt;/td>
&lt;td style="text-align: center">6443&lt;/td>
&lt;td style="text-align: center">Agents&lt;/td>
&lt;td style="text-align: center">Servers&lt;/td>
&lt;td style="text-align: left">K3s supervisor 和 Kubernetes API Server&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UDP&lt;/td>
&lt;td style="text-align: center">8472&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: left">只有 Flannel VXLAN 需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">TCP&lt;/td>
&lt;td style="text-align: center">10250&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: left">Kubelet 指标&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UDP&lt;/td>
&lt;td style="text-align: center">51820&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: left">只有使用 IPv4 的 Flannel Wireguard 才需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UDP&lt;/td>
&lt;td style="text-align: center">51821&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: center">所有节点&lt;/td>
&lt;td style="text-align: left">只有使用 IPv6 的 Flannel Wireguard 才需要&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>所有出站流量通常都是允许的。&lt;/p>
&lt;h3 id="参考">参考：&lt;/h3>
&lt;p>&lt;a href="https://docs.k3s.io/zh/quick-start">快速入门指南&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://docs.k3s.io/zh/installation/network-options#%E5%B5%8C%E5%85%A5%E5%BC%8F-k3s-%E5%A4%9A%E4%BA%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">嵌入式 k3s 多云解决方案&lt;/a>&lt;/p></description></item><item><title>Telegram 界面自定义翻译</title><link>https://blog.baicai.me/article/2023/translations/</link><pubDate>Thu, 21 Sep 2023 00:01:03 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/translations/</guid><description>&lt;h3 id="语言包的获取方法">语言包的获取方法&lt;/h3>
&lt;p>进入官网翻译界面 &lt;a href="https://translations.telegram.org">https://translations.telegram.org&lt;/a>&lt;/p>
&lt;p>点击 &amp;ldquo;Start Translating&amp;rdquo;&lt;/p>
&lt;p>选择 对应语言 比如 简体中文 进入网址&lt;/p>
&lt;p>&lt;a href="https://translations.telegram.org/zh-hans/">https://translations.telegram.org/zh-hans/&lt;/a>&lt;/p>
&lt;p>底部有 &amp;ldquo;Sharing Link&amp;rdquo; 在 telegram 中打开这个网址 就可以换界面语言了。&lt;/p>
&lt;p>自定义界面语言的话，选择上面的 客户端类型，根据提示 编辑对应翻译内容 即可。&lt;/p>
&lt;h3 id="telegram-中文语言包">Telegram 中文语言包&lt;/h3>
&lt;p>&lt;a href="https://t.me/setlanguage/zh-hans-beta">https://t.me/setlanguage/zh-hans-beta&lt;/a>&lt;/p></description></item><item><title>搭建反向代理服务：Telegram Bot Api 反向代理搭建</title><link>https://blog.baicai.me/article/2023/reverse-proxy/</link><pubDate>Wed, 20 Sep 2023 12:06:18 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/reverse-proxy/</guid><description>&lt;p>上面一篇通过nginx和cloudflare workers 搭建的反向代理。&lt;/p>
&lt;p>这一篇通过更简单的代码重下搭建个。&lt;/p>
&lt;h2 id="通过-cloudflare-workers-搭建反向代理服务">通过 Cloudflare Workers 搭建反向代理服务&lt;/h2>
&lt;p>创建 Cloudflare workers 的步骤都是一样的，代码不一样。&lt;/p>
&lt;h3 id="创建一个worker">创建一个Worker&lt;/h3>
&lt;p>在首页选择Workers，若从未创建过则初始化，选择免费套餐，然后创建一个Worker。&lt;/p>
&lt;h3 id="编辑worker内容">编辑Worker内容&lt;/h3>
&lt;p>进入worker，点击快速编辑，将代码改为下方内容，其中hostname改为你自己的，然后点击保存部署，并可改名为例如cdn的worker。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这就是需要代理的网址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">hostname&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://example.domain&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// const hostname = &amp;#34;http://192.168.0.1&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// const hostname = &amp;#34;https://your.domain&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// const hostname = &amp;#34;https://your.domain/api/path&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">handleRequest&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Request&lt;/span>(&lt;span style="color:#a6e22e">hostname&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">pathname&lt;/span>,&lt;span style="color:#a6e22e">request&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fetch&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">event&lt;/span> =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">respondWith&lt;/span>(&lt;span style="color:#a6e22e">handleRequest&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">request&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="为域名添加dns">为域名添加DNS&lt;/h3>
&lt;p>添加路由，配置&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cn.you.domain/*" data-lang="cn.you.domain/*">&lt;/code>&lt;/pre>&lt;p>指向步骤1创建的 Worker，到此等待DNS生效即可。&lt;/p>
&lt;h2 id="通过-vercel-搭建反向代理服务">通过 Vercel 搭建反向代理服务&lt;/h2>
&lt;p>在github中新建个项目
创建一个文件，命名为 vercel.json 文件内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;routes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/.*&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://example.domain&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入 vercel 后台 部署这个项目 配置好自定义域名，即可使用。&lt;/p>
&lt;p>通用代理 json 内容 参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;routes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/redirect&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">308&lt;/span>, &lt;span style="color:#f92672">&amp;#34;headers&amp;#34;&lt;/span>: { &lt;span style="color:#f92672">&amp;#34;Location&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://example.domain/&amp;#34;&lt;/span> } },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/custom-page&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;headers&amp;#34;&lt;/span>: {&lt;span style="color:#f92672">&amp;#34;cache-control&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;s-maxage=1000&amp;#34;&lt;/span>}, &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/index.html&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/api&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/my-api.js&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/users&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;methods&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>], &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/users-api.js&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/users/(?&amp;lt;id&amp;gt;[^/]*)&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/users-api.js?id=$id&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/legacy&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">404&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;src&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/.*&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;dest&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://example.domain/&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通过nginx-对网站进行反向代理">通过Nginx 对网站进行反向代理&lt;/h2>
&lt;h3 id="创建配置文件">创建配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nano /etc/nginx/conf.d/tgapi.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输入一下内容并保存&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">server {
listen 80;
server_name tgapi.domain;
location / {
return 444;
}
location ~* ^/bot {
resolver 8.8.8.8;
proxy_buffering off;
proxy_pass https://example.domain$request_uri;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Telegram Bot Api 反向代理搭建</title><link>https://blog.baicai.me/article/2023/nginx_tgapi_proxy/</link><pubDate>Tue, 19 Sep 2023 22:28:07 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/nginx_tgapi_proxy/</guid><description>&lt;p>由于一些原因，配置epusdt需要使用tg反向代理地址才能使用！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-env" data-lang="env">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#telegram代理url(大陆地区服务器可使用一台国外服务器做反代tg的url)，如果运行的本来就是境外服务器，则无需填写&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tg_proxy&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>两种实现方案，根据个人喜好选择使用或发挥&lt;/p>
&lt;h2 id="nginx反代telegram-api">Nginx反代Telegram Api&lt;/h2>
&lt;h3 id="安装nginx">安装nginx&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建配置文件">创建配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nano tgapi.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输入一下内容并保存&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">server {
listen 80;
server_name tgapi.domain;
location / {
return 444;
}
location ~* ^/bot {
resolver 8.8.8.8;
proxy_buffering off;
proxy_pass https://api.telegram.org$request_uri;
}
}
&lt;/code>&lt;/pre>&lt;h3 id="加载配置">加载配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl reload nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo nginx -s reload
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试访问">测试访问&lt;/h3>
&lt;p>输入以下命令行,BOT_TOKEN换成自己机器人token。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl https://tgapi.domain/bot&amp;lt;BOT_TOKEN&amp;gt;/getMe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看的机器人信息，就说明可以使用了。&lt;/p>
&lt;h3 id="配置-epusdt-telegram代理url">配置 epusdt telegram代理url&lt;/h3>
&lt;p>epusdt 配置(.env)参考&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-env" data-lang="env">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#telegram代理url(大陆地区服务器可使用一台国外服务器做反代tg的url)，如果运行的本来就是境外服务器，则无需填写&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tg_proxy&lt;span style="color:#f92672">=&lt;/span>https://tgapi.domain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-配置-nginx-参考-docker-composeyam-内容">docker 配置 nginx 参考 docker-compose.yam 内容&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;80:80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx:bookworm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./conf.d:/etc/nginx/conf.d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./log:/var/log/nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">extra_hosts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;host.docker.internal:host-gateway&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-cloudflare-worker-代理-telegram-bot-api">使用 Cloudflare Worker 代理 Telegram Bot Api&lt;/h2>
&lt;p>使用前提&lt;/p>
&lt;ol>
&lt;li>一个托管在cloudflare的域名&lt;/li>
&lt;li>k开启cloudflare的免费worker服务&lt;/li>
&lt;/ol>
&lt;h3 id="首先登录cloudflare以后点击左侧的workers-和-pages">首先登录Cloudflare以后点击左侧的Workers 和 Pages&lt;/h3>
&lt;p>点击 &lt;code>创建应用程序&lt;/code>-&lt;code>创建 worker&lt;/code>&lt;/p>
&lt;p>&lt;code>名称&lt;/code> 随意填写，点击 &lt;code>部署&lt;/code>&lt;/p>
&lt;p>创建完成后，点击刚创建的Worker，再点击 &lt;code>快速编辑&lt;/code>&lt;/p>
&lt;p>在左侧删除原有的代码，填入下面给出的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Helper functions to check if the request uses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * corresponding method.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Method&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">method&lt;/span>) =&amp;gt; (&lt;span style="color:#a6e22e">req&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">method&lt;/span>.&lt;span style="color:#a6e22e">toLowerCase&lt;/span>() &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>.&lt;span style="color:#a6e22e">toLowerCase&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Get&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Method&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;get&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Post&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Method&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;post&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">regExp&lt;/span>) =&amp;gt; (&lt;span style="color:#a6e22e">req&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">pathname&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">regExp&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">regExp&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The regex to get the bot_token and api_method from request URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * as the first and second backreference respectively.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">URL_PATH_REGEX&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">/^\/bot(?&amp;lt;bot_token&amp;gt;[^/]+)\/(?&amp;lt;api_method&amp;gt;[a-z]+)/i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Router handles the logic of what handler is matched given conditions
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * for each request
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Router&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">routes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handle&lt;/span>(&lt;span style="color:#a6e22e">conditions&lt;/span>, &lt;span style="color:#a6e22e">handler&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">routes&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">conditions&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handler&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>, &lt;span style="color:#a6e22e">handler&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handle&lt;/span>([&lt;span style="color:#a6e22e">Get&lt;/span>, &lt;span style="color:#a6e22e">Path&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>)], &lt;span style="color:#a6e22e">handler&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>, &lt;span style="color:#a6e22e">handler&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handle&lt;/span>([&lt;span style="color:#a6e22e">Post&lt;/span>, &lt;span style="color:#a6e22e">Path&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>)], &lt;span style="color:#a6e22e">handler&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">all&lt;/span>(&lt;span style="color:#a6e22e">handler&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handler&lt;/span>([], &lt;span style="color:#a6e22e">handler&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">route&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">route&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>.&lt;span style="color:#a6e22e">handler&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">description&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;No matching route found&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">error_code&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">404&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Response&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">stringify&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ok&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">error_code&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">status&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">error_code&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">statusText&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">description&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">headers&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;content-type&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * It returns the matching route that returns true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * for all the conditions if any.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">routes&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>((&lt;span style="color:#a6e22e">r&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conditions&lt;/span> &lt;span style="color:#f92672">||&lt;/span> (Array.&lt;span style="color:#a6e22e">isArray&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conditions&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conditions&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;function&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conditions&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">conditions&lt;/span>.&lt;span style="color:#a6e22e">every&lt;/span>((&lt;span style="color:#a6e22e">c&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">c&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Sends a POST request with JSON data to Telegram Bot API
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * and reads in the response body.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param {Request} request the incoming request
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">handler&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Extract the URl method from the request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">url&lt;/span>, ...&lt;span style="color:#a6e22e">_request&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">request&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">pathname&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>, &lt;span style="color:#a6e22e">search&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Leave the first match as we are interested only in backreferences.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">bot_token&lt;/span>, &lt;span style="color:#a6e22e">api_method&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">URL_PATH_REGEX&lt;/span>).&lt;span style="color:#a6e22e">groups&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Build the URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">api_url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://api.telegram.org/bot&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">bot_token&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">api_method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Get the response from API.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#a6e22e">api_url&lt;/span>, &lt;span style="color:#a6e22e">_request&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">text&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Response&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">_request&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">headers&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Content-Type&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Handles the incoming request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param {Request} request the incoming request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">handleRequest&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Router&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#a6e22e">URL_PATH_REGEX&lt;/span>, (&lt;span style="color:#a6e22e">req&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">handler&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#a6e22e">URL_PATH_REGEX&lt;/span>, (&lt;span style="color:#a6e22e">req&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">handler&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">route&lt;/span>(&lt;span style="color:#a6e22e">request&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Hook into the fetch event.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;fetch&amp;#39;&lt;/span>, (&lt;span style="color:#a6e22e">event&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">respondWith&lt;/span>(&lt;span style="color:#a6e22e">handleRequest&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">request&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>保存并部署&lt;/code>&lt;/p>
&lt;p>回到管理后台首页，点击左侧的&lt;code>网站&lt;/code>，在右侧点击&lt;code>你已托管在Cloudflare的域名&lt;/code>&lt;/p>
&lt;p>选择该域名下的 &lt;code>Workers 路由&lt;/code>&lt;/p>
&lt;p>选择&lt;code>添加路由&lt;/code>&lt;/p>
&lt;p>&lt;code>路由&lt;/code> 填写你想要用的二级域名，比如：&lt;code>tgapi.domain/*&lt;/code> 注意后面必须是&lt;code>/*&lt;/code>结尾，&lt;code>Worker&lt;/code>选择刚才创建的服务，&lt;code>保存&lt;/code>就可以了。&lt;/p></description></item><item><title>甲骨文Vps iptables 开放端口设置</title><link>https://blog.baicai.me/article/2023/oracle_vps_iptables/</link><pubDate>Mon, 18 Sep 2023 10:20:17 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/oracle_vps_iptables/</guid><description>&lt;p>在甲骨文的网页后台先开放端口&lt;/p>
&lt;h2 id="iptables-开放所有端口">iptables 开放所有端口&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo iptables -P INPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo iptables -P FORWARD ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo iptables -P OUTPUT ACCEPT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo iptables -F
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="oracle自带的镜像默认设置了iptable规则关闭它">Oracle自带的镜像默认设置了Iptable规则，关闭它&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get purge netfilter-persistent &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo reboot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试端口是否已经开放&lt;/p>
&lt;h2 id="附注">附注：&lt;/h2>
&lt;h3 id="强制删除规则">强制删除规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /etc/iptables &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo reboot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除oracle-cloud-agent防止甲骨文监控">删除oracle-cloud-agent，防止甲骨文监控&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>snap remove oracle-cloud-agent
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="检查防火墙服务状态">检查防火墙服务状态&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl status iptables.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl status netfilter-persistent.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="远程检测端口开放状态">远程检测端口开放状态&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap ip或域名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附注2开放指定端口">附注2(开放指定端口):&lt;/h2>
&lt;h3 id="iptables-开放指定端口">iptables 开放指定端口&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> iptables -I INPUT -p tcp --dport &lt;span style="color:#ae81ff">80&lt;/span> -j ACCEPT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>中间的 80 为所需要开放的端口，tcp 为传输协议&lt;/p>
&lt;h4 id="保存规则">保存规则&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> iptables-save
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述命令我们就完成了开放指定的端口，但是如果此时服务器重启，上述规则就没有了，所以我们需要对规则进行一下持久化操作&lt;/p>
&lt;h3 id="安装-iptables-persistent">安装 iptables-persistent&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo apt-get install iptables-persistent
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="持久化规则">持久化规则&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo netfilter-persistent save
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo netfilter-persistent reload
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docker 搭建MTProto协议上网</title><link>https://blog.baicai.me/article/2023/docker_mtg/</link><pubDate>Thu, 07 Sep 2023 18:00:43 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_mtg/</guid><description>&lt;p>系统环境：
Debian系（其他系只需要更换apt为对应系统的软件包管理工具名称即可）&lt;/p>
&lt;h2 id="安装docker">安装Docker&lt;/h2>
&lt;h3 id="安装docker相关工具">安装Docker相关工具&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt -y upgrade &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y docker docker.io docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动docker">启动docker&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl enable docker &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo systemctl start docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="验证是否安装成功">验证是否安装成功&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run hello-world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mtg-v2版本-docker运行">mtg v2版本 docker运行&lt;/h2>
&lt;h3 id="生成密钥">生成密钥&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker pull baicailin/mtg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker run --rm baicailin/mtg generate-secret --hex trade.aliexpress.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#会看到一串ee开头的密钥，形如：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eexxx44f3762c8a97d14f89df8c0174726164652e616c69657870726573732e636f6d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="写入简单配置">写入简单配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;secret = \&amp;#34;把上面一步生成的密钥填进来\&amp;#34;&amp;#34;&lt;/span> &amp;gt;config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;bind-to = \&amp;#34;0.0.0.0:443\&amp;#34;&amp;#34;&lt;/span> &amp;gt;&amp;gt;config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="运行docker镜像命令">运行docker镜像命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -d -v $PWD/config.toml:/config.toml -p 443:443 --name baicai_mtg --restart&lt;span style="color:#f92672">=&lt;/span>unless-stopped baicailin/mtg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-compose-启动可代替上面这个命令启动方式">docker-compose 启动（可代替上面这个命令启动方式）&lt;/h3>
&lt;p>一键启动 docker-compose.yaml 文件参考&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mtg_v2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">baicailin/mtg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mtg_v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run /config.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./config.toml:/config.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;443:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成mtproto协议服务配置">生成MTProto协议服务配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker exec mtg_v2 /mtg access /config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mtg_v1-版本支持adtag-赞助选项运行">mtg_v1 版本(支持adtag 赞助选项)运行&lt;/h2>
&lt;p>生成密钥&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker run --rm baicailin/mtg:1 generate-secret tls -c bing.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eedf71035a8ed48a623d8e83e66aec4d0562696e672e636f6d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-compose-启动可代替上面这个命令启动方式-1">docker-compose 启动（可代替上面这个命令启动方式）&lt;/h3>
&lt;p>一键启动 docker-compose.yaml 文件参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mtg_v1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">baicailin/mtg:1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mtg_v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># deploy:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># resources:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># limits:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># cpus: 0.50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># memory: 256M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># reservations:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># memory: 128M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run eedf71035a8ed48a623d8e83e66aec4d0562696e672e636f6d adtag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_DEBUG: &amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_BIND: &amp;#34;0.0.0.0:3128&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_IPV4: &amp;#34;公网ip:端口&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_IPV6: &amp;#34;公网ip:端口&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_STATS_BIND: &amp;#34;127.0.0.1:3129&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># network_mode: host &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;1443:3128&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;1444:3129&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行参数中的 &lt;code>adtag&lt;/code> 可以通过tg机器人 &lt;code>@MTProxybot&lt;/code> 创建获得&lt;/p>
&lt;h3 id="查看mtproto协议服务配置">查看MTProto协议服务配置&lt;/h3>
&lt;p>在mtg v1 docker-compose.yml文件目录下运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker-compose logs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>docker golang:alpine CGO 制作镜像的正确姿势</title><link>https://blog.baicai.me/article/2023/docker_golang_alpine_cgo_build/</link><pubDate>Mon, 04 Sep 2023 23:23:09 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_golang_alpine_cgo_build/</guid><description>&lt;p>当程序需要引入C/C++库（比如支持Sqlite数据库）的时候，编译环境需要打开CGO，否则打包完成后的程序就不能顺利运行（数据库初始化失败）。&lt;/p>
&lt;p>这时就需要安装 build-base 配置编译环境。&lt;/p>
&lt;p>参考 Dockerfile 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM golang:alpine as builder
ENV CGO_ENABLED=1
WORKDIR /app
COPY . .
RUN apk add --no-cache --update git build-base
RUN go mod tidy \
&amp;amp;&amp;amp; go build -o api_client_linux ./cmd/api_client/
FROM alpine:latest as runner
ENV TZ=Asia/Shanghai
RUN apk --no-cache add ca-certificates tzdata libc6-compat libgcc libstdc++
WORKDIR /app
COPY --from=builder /app/api_client_linux .
VOLUME /app/conf
EXPOSE 8080
ENTRYPOINT [&amp;#34;./api_client_linux&amp;#34; ,&amp;#34;-c&amp;#34;,&amp;#34;/app/conf/config.yaml&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>运行镜像我们也使用 Alpine ，由于 Alpine 极为精简，并没有常用的时区、证书等，会导致不可预料的错误。所以我们需要安装这些东西：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">包名&lt;/th>
&lt;th style="text-align: left">用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">ca-certificates:&lt;/td>
&lt;td style="text-align: left">CA证书，使用TLS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">tzdata:&lt;/td>
&lt;td style="text-align: left">时区配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">libc6-compat:&lt;/td>
&lt;td style="text-align: left">C 标准库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">libgcc:&lt;/td>
&lt;td style="text-align: left">GCC 相关库，CGO编译程序依赖&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">libstdc++:&lt;/td>
&lt;td style="text-align: left">C++ 标准库&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Linux 命令</title><link>https://blog.baicai.me/article/2023/linux_cmd_list/</link><pubDate>Mon, 10 Apr 2023 17:53:52 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/linux_cmd_list/</guid><description>&lt;h2 id="基本命令">基本命令&lt;/h2>
&lt;pre>&lt;code>uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本
dmidecode -q 显示硬件系统部件
(SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作系统信息
arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
hdparm -i /dev/hda 罗列一个磁盘的架构特性
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作
cat /proc/cpuinfo 显示CPU info的信息
cat /proc/interrupts 显示中断
cat /proc/meminfo 校验内存使用
cat /proc/swaps 显示哪些swap被使用
cat /proc/version 显示内核的版本
cat /proc/net/dev 显示网络适配器及统计
cat /proc/mounts 显示已加载的文件系统
lspci -tv 罗列 PCI 设备
lsusb -tv 显示 USB 设备
date 显示系统日期
cal 2007 显示2007年的日历表
date 041217002007.00 设置日期和时间 - 月日时分年.秒
clock -w 将时间修改保存到 BIOS
&lt;/code>&lt;/pre>
&lt;h2 id="关机">关机&lt;/h2>
&lt;pre>&lt;code>shutdown -h now 关闭系统(1)
init 0 关闭系统(2)
telinit 0 关闭系统(3)
shutdown -h hours:minutes &amp;amp; 按预定时间关闭系统
shutdown -c 取消按预定时间关闭系统
shutdown -r now 重启(1)
reboot 重启(2)
logout 注销
&lt;/code>&lt;/pre>
&lt;h2 id="文件和目录">文件和目录&lt;/h2>
&lt;pre>&lt;code>cd /home 进入 '/ home' 目录'
cd .. 返回上一级目录
cd ../.. 返回上两级目录
cd 进入个人的主目录
cd ~user1 进入个人的主目录
cd - 返回上次所在的目录
pwd 显示工作路径
ls 查看目录中的文件
ls -F 查看目录中的文件
ls -l 显示文件和目录的详细资料
ls -a 显示隐藏文件
ls *[0-9]* 显示包含数字的文件名和目录名
tree 显示文件和目录由根目录开始的树形结构(1)
lstree 显示文件和目录由根目录开始的树形结构(2)
mkdir dir1 创建一个叫做 'dir1' 的目录'
mkdir dir1 dir2 同时创建两个目录
mkdir -p /tmp/dir1/dir2 创建一个目录树
rm -f file1 删除一个叫做 'file1' 的文件'
rmdir dir1 删除一个叫做 'dir1' 的目录'
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容
rm -rf dir1 dir2 同时删除两个目录及它们的内容
mv dir1 new_dir 重命名/移动 一个目录
cp file1 file2 复制一个文件
cp dir/* . 复制一个目录下的所有文件到当前工作目录
cp -a /tmp/dir1 . 复制一个目录到当前工作目录
cp -a dir1 dir2 复制一个目录
ln -s file1 lnk1 创建一个指向文件或目录的软链接
ln file1 lnk1 创建一个指向文件或目录的物理链接
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)
file file1 outputs the mime type of the file as text
iconv -l 列出已知的编码
iconv -f fromEncoding -t toEncoding inputFile &amp;gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.
find . -maxdepth 1 -name *.jpg -print -exec convert &amp;quot;{}&amp;quot; -resize 80x60 &amp;quot;thumbs/{}&amp;quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)
&lt;/code>&lt;/pre>
&lt;h2 id="文件搜索">文件搜索&lt;/h2>
&lt;pre>&lt;code>find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 'user1' 的文件和目录
find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件
find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限
find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备
locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令
whereis halt 显示一个二进制文件、源码或man的位置
which halt 显示一个二进制文件或可执行文件的完整路径
&lt;/code>&lt;/pre>
&lt;h2 id="挂载一个文件系统">挂载一个文件系统&lt;/h2>
&lt;pre>&lt;code>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出
fuser -km /mnt/hda2 当设备繁忙时强制卸载
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用
mount /dev/fd0 /mnt/floppy 挂载一个软盘
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享
&lt;/code>&lt;/pre>
&lt;h2 id="磁盘空间">磁盘空间&lt;/h2>
&lt;pre>&lt;code>df -h 显示已经挂载的分区列表
ls -lSr |more 以尺寸大小排列文件和目录
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)
dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)
&lt;/code>&lt;/pre>
&lt;h2 id="用户和群组">用户和群组&lt;/h2>
&lt;pre>&lt;code>groupadd group_name 创建一个新用户组
groupdel group_name 删除一个用户组
groupmod -n new_group_name old_group_name 重命名一个用户组
useradd -c &amp;quot;Name Surname &amp;quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &amp;quot;admin&amp;quot; 用户组的用户
useradd user1 创建一个新用户
userdel -r user1 删除一个用户 ( '-r' 排除主目录)
usermod -c &amp;quot;User FTP&amp;quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性
passwd 修改口令
passwd user1 修改一个用户的口令 (只允许root执行)
chage -E 2005-12-31 user1 设置用户口令的失效期限
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组
&lt;/code>&lt;/pre>
&lt;h2 id="文件的权限使用设置权限使用-用于取消">文件的权限，使用“+”设置权限，使用“-”用于取消&lt;/h2>
&lt;pre>&lt;code>chattr +a file1 只允许以追加方式读写文件
chattr +c file1 允许这个文件能被内核自动压缩/解压
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接
chattr +s file1 允许一个文件被安全地删除
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件
lsattr 显示特殊的属性
&lt;/code>&lt;/pre>
&lt;h2 id="文件的特殊属性-使用--设置权限使用---用于取消">文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消&lt;/h2>
&lt;pre>&lt;code>chattr +a file1 只允许以追加方式读写文件
chattr +c file1 允许这个文件能被内核自动压缩/解压
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接
chattr +s file1 允许一个文件被安全地删除
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件
lsattr 显示特殊的属性
&lt;/code>&lt;/pre>
&lt;h2 id="打包和压缩文件">打包和压缩文件&lt;/h2>
&lt;pre>&lt;code>bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件
bzip2 file1 压缩一个叫做 'file1' 的文件
gunzip file1.gz 解压一个叫做 'file1.gz'的文件
gzip file1 压缩一个叫做 'file1'的文件
gzip -9 file1 最大程度压缩
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'
rar x file1.rar 解压rar包
unrar x file1.rar 解压rar包
tar -cvf archive.tar file1 创建一个非压缩的 tarball
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件
tar -tf archive.tar 显示一个包中的内容
tar -xvf archive.tar 释放一个包
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包
zip file1.zip file1 创建一个zip格式的压缩包
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包
unzip file1.zip 解压一个zip格式压缩包
&lt;/code>&lt;/pre>
&lt;h2 id="rpm-包">RPM 包&lt;/h2>
&lt;pre>&lt;code>rpm -ivh package.rpm 安装一个rpm包
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告
rpm -U package.rpm 更新一个rpm包但不改变其配置文件
rpm -F package.rpm 更新一个确定已经安装的rpm包
rpm -e package_name.rpm 删除一个rpm包
rpm -qa 显示系统中所有已经安装的rpm包
rpm -qa | grep httpd 显示所有名称中包含 &amp;quot;httpd&amp;quot; 字样的rpm包
rpm -qi package_name 获取一个已安装包的特殊信息
rpm -qg &amp;quot;System Environment/Daemons&amp;quot; 显示一个组件的rpm包
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表
rpm -q package_name --whatprovides 显示一个rpm包所占的体积
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l
rpm -q package_name --changelog 显示一个rpm包的修改历史
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书
rpm --checksig package.rpm 确认一个rpm包的完整性
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间
rpm -Va 检查系统中所有已安装的rpm包- 小心使用
rpm -Vp package.rpm 确认一个rpm包还未安装
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包
&lt;/code>&lt;/pre>
&lt;h2 id="yum-软件包升级器">YUM 软件包升级器&lt;/h2>
&lt;pre>&lt;code>yum install package_name 下载并安装一个rpm包
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系
yum update package_name.rpm 更新当前系统中所有安装的rpm包
yum update package_name 更新一个rpm包
yum remove package_name 删除一个rpm包
yum list 列出当前系统中安装的所有包
yum search package_name 在rpm仓库中搜寻软件包
yum clean packages 清理rpm缓存删除下载的包
yum clean headers 删除所有头文件
yum clean all 删除所有缓存的包和头文件
&lt;/code>&lt;/pre>
&lt;h2 id="deb-包">deb 包&lt;/h2>
&lt;pre>&lt;code>dpkg -i package.deb 安装/更新一个 deb 包
dpkg -r package_name 从系统删除一个 deb 包
dpkg -l 显示系统中所有已经安装的 deb 包
dpkg -l | grep httpd 显示所有名称中包含 &amp;quot;httpd&amp;quot; 字样的deb包
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供
APT 软件工具 (Debian, Ubuntu 以及类似系统)
apt-get install package_name 安装/更新一个 deb 包
apt-cdrom install package_name 从光盘安装/更新一个 deb 包
apt-get update 升级列表中的软件包
apt-get upgrade 升级所有已安装的软件
apt-get remove package_name 从系统删除一个deb包
apt-get check 确认依赖的软件仓库正确
apt-get clean 从下载的软件包中清理缓存
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称
&lt;/code>&lt;/pre>
&lt;h2 id="查看文件内容">查看文件内容&lt;/h2>
&lt;pre>&lt;code>cat file1 从第一个字节开始正向查看文件的内容
tac file1 从最后一行开始反向查看一个文件的内容
more file1 查看一个长文件的内容
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作
head -2 file1 查看一个文件的前两行
tail -2 file1 查看一个文件的最后两行
tail -f /var/log/messages 实时查看被添加到一个文件中的内容
&lt;/code>&lt;/pre>
&lt;h2 id="文本处理">文本处理&lt;/h2>
&lt;pre>&lt;code>cat file1 file2 ... | command &amp;lt;&amp;gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT
cat file1 | command( sed, grep, awk, grep, etc...) &amp;gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中
cat file1 | command( sed, grep, awk, grep, etc...) &amp;gt;&amp;gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中
grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词&amp;quot;Aug&amp;quot;
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以&amp;quot;Aug&amp;quot;开始的词汇
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串&amp;quot;Aug&amp;quot;
sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 &amp;quot;string1&amp;quot; 替换成 &amp;quot;string2&amp;quot;
sed '/^$/d' example.txt 从example.txt文件中删除所有空白行
sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容
sed -e '1d' result.txt 从文件example.txt 中排除第一行
sed -n '/stringa1/p' 查看只包含词汇 &amp;quot;string1&amp;quot;的行
sed -e 's/ *$//' example.txt 删除每一行最后的空白字符
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 &amp;quot;string1&amp;quot; 并保留剩余全部
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容
sed -n '5p;5q' example.txt 查看第5行
sed -e 's/00*/0/g' example.txt 用单个零替换多个零
cat -n file1 标示文件的行数
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行
echo a b c | awk '{print $1}' 查看一行第一栏
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏
paste file1 file2 合并两个文件或两栏的内容
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用&amp;quot;+&amp;quot;区分
sort file1 file2 排序两个文件的内容
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)
sort file1 file2 | uniq -u 删除交集，留下其他的行
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分
&lt;/code>&lt;/pre>
&lt;h2 id="字符设置和文件格式转换">字符设置和文件格式转换&lt;/h2>
&lt;pre>&lt;code>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS
recode ..HTML &amp;lt; page.txt &amp;gt; page.html 将一个文本文件转换成html
recode -l | more 显示所有允许的转换格式
&lt;/code>&lt;/pre>
&lt;h2 id="文件系统分析">文件系统分析&lt;/h2>
&lt;pre>&lt;code>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
&lt;/code>&lt;/pre>
&lt;h2 id="初始化一个文件系统">初始化一个文件系统&lt;/h2>
&lt;pre>&lt;code>mkfs /dev/hda1 在hda1分区创建一个文件系统
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统
fdformat -n /dev/fd0 格式化一个软盘
mkswap /dev/hda3 创建一个swap文件系统
&lt;/code>&lt;/pre>
&lt;h2 id="swap文件系统">SWAP文件系统&lt;/h2>
&lt;pre>&lt;code>mkswap /dev/hda3 创建一个swap文件系统
swapon /dev/hda3 启用一个新的swap文件系统
swapon /dev/hda2 /dev/hdb3 启用两个swap分区
&lt;/code>&lt;/pre>
&lt;h2 id="备份">备份&lt;/h2>
&lt;pre>&lt;code>dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份
restore -if /tmp/home0.bak 还原一个交互式备份
rsync -rogpav --delete /home /tmp 同步两边的目录
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作
( cd /tmp/local/ &amp;amp;&amp;amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;amp;&amp;amp; tar x -p' 通过ssh在远程目录中复制一个目录内容
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;amp;&amp;amp; tar x -p' 通过ssh在远程目录中复制一个本地目录
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 &amp;gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容
&lt;/code>&lt;/pre>
&lt;h2 id="光盘">光盘&lt;/h2>
&lt;pre>&lt;code>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容
mkisofs /dev/cdrom &amp;gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件
mkisofs /dev/cdrom | gzip &amp;gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件
mkisofs -J -allow-leading-dots -R -V &amp;quot;Label CD&amp;quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中
cd-paranoia -- &amp;quot;-3&amp;quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3）
cdrecord --scanbus 扫描总线以识别scsi通道
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD
&lt;/code>&lt;/pre>
&lt;h2 id="网络以太网和wifi无线">网络（以太网和WIFI无线）&lt;/h2>
&lt;pre>&lt;code>ifconfig eth0 显示一个以太网卡的配置
ifup eth0 启用一个 'eth0' 网络设备
ifdown eth0 禁用一个 'eth0' 网络设备
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)
dhclient eth0 以dhcp模式启用 'eth0'
route -n show routing table
route add -net 0/0 gw IP_Gateway configura default gateway
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'
route del 0/0 gw IP_gateway remove static route
echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward activate ip routing
hostname show hostname of system
host www.example.com lookup hostname to resolve name to ip address and viceversa(1)
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)
ip link show show link status of all interfaces
mii-tool eth0 show link status of 'eth0'
ethtool eth0 show statistics of network card 'eth0'
netstat -tup show all active network connections and their PID
netstat -tupl show all network services listening on the system and their PID
tcpdump tcp port 80 show all HTTP traffic
iwlist scan show wireless networks
iwconfig eth1 show configuration of a wireless network card
hostname show hostname
host www.example.com lookup hostname to resolve name to ip address and viceversa
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa
whois www.example.com lookup on Whois database
&lt;/code>&lt;/pre>
&lt;h2 id="列出目录内容">列出目录内容&lt;/h2>
&lt;pre>&lt;code>ls -a：显示所有文件（包括隐藏文件）；
ls -l：显示详细信息；
ls -R：递归显示子目录结构；
ls -ld：显示目录和链接信息；
ctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；
Linux中以.开头的文件是隐藏文件；
pwd:显示当前目录
&lt;/code>&lt;/pre>
&lt;h2 id="查看文件的类型">查看文件的类型&lt;/h2>
&lt;pre>&lt;code>file:查看文件的类型
&lt;/code>&lt;/pre>
&lt;h2 id="复制文件目录">复制文件目录&lt;/h2>
&lt;pre>&lt;code>1、cp：复制文件和目录 cp源文件（文件夹）目标文件（文件夹）。
常用参数：-r:递归复制整个目录树；-v：显示详细信息；
复制文件夹时要在cp命令后面加一个-r参数：
如：cp -r 源文件夹 目标文件夹。
2、touch+文件名：当文件不存在的时候，创建相应的文件；当文件存在的时候，修改文件的创建时间。
功能：生成一个空文件或修改文件的存取/修改的时间记录值；
touch * ：将当前下的文件时间修改为系统的当前时间；
touch –d 20040210 test：将test文件的日期改为20040210；
touch abc：若abc文件存在，则修改为系统的当前时间；若不存在，则生成一个为当前时间的空文件。
3、mv 文件 目标目录：移动或重命名文件或目录（如果指定文件名，则可以重命名文件）。可以将文件及目录移到另一目录下，或更改文件及目录的名称。
格式为：mv [参数]&amp;lt;源文件或目录&amp;gt; &amp;lt;目标文件或目录&amp;gt;
mva.txt ../：将a.txt文件移动上层目录
mv a.txt b.txt：将a.txt改名为b.txt
mvdir2 ../：将dir2目录上移一层
4、rm：删除文件
常用参数：-i：交互式 -r：递归的删除包括目录中的所有内容。
5、mkdir +文件夹名称：创建文件夹
6、rm -r +文件夹名称：删除文件夹（空文件夹和非空文件夹都可删除）；
rmdir 文件夹名称：删除文件夹（只能删除空文件夹）。
7、mkdir -p dir1/dir2 ：在当前目录下创建dir1目录，并在dir1目录下创建dir2目录， 也就是连续创建两个目录（dir1/和dir1/dir2）。
8、rmdir –p dir1/dir2：删除dir1下的dir2目录，若dir1目录为空也删除它。
9、rm * ：删除当前目录下的所有文件
10、-f参数：强迫删除文件 rm –f *.txt：强迫删除所有以后缀名为txt文件。
11、-i参数：删除文件时询问
rm　–i * ：删除当前目录下的所有文件会有如下提示：
rm:backup:is a directory　　　 遇到目录会略过
rm: remove ‘myfiles.txt’ ? Y
删除文件时会询问，可按Y或N键表示允许或拒绝删除文件。
12、-r参数：递归删除（连子目录一同删除，这是一个相当常用的参数）。
rm -r test ：删除test目录（含test目录下所有文件和子目录）；
rm -r *：删除所有文件（含当前目录所有文件、所有子目录和子目录下的文件） 一般在删除目录时r和f一起用，避免麻烦；
rm -rf test ：强行删除、不加询问。
13、grep：功能：在文件中搜索匹配的字符并进行输出。
格式：grep[参数] &amp;lt;要找的字串&amp;gt; &amp;lt;要寻找字 串的源文件&amp;gt;
greplinux test.txt：搜索test.txt文件中字符串linux并输出。
14、ln命令
功能：在文件和目录之间建立链接
格式：ln [参数] &amp;lt;源文件或目录&amp;gt; &amp;lt;目标文件或目录&amp;gt;
链接分“软链接”和“硬链接”
1.软链接:
ln–s /usr/share/do doc ：创建一个链接文件doc，并指向目录/usr/share/do
2.硬链接:
ln /usr/share/test hard：创建一个硬链接文件hard，这时对于test文件对应 的存储区域来说，又多了一个文件指向它。
&lt;/code>&lt;/pre>
&lt;h2 id="系统常用命令">系统常用命令&lt;/h2>
&lt;pre>&lt;code>1、显示命令
date:查看或设置当前系统的时间：格式化显示时间：+%Y--%m--%d；
date -s:设置当前系统的时间；
hwclock(clock)：显示硬件时钟时间(需要管理员权限)；
cal：查看日历；
格式cal [参数] 月年；
cal：显示当月的日历 cal4 2004 ：显示2004年4月的日历；
cal- y 2003：显示2003年的日历；
uptime：查看系统运行时间
2、输出查看命令
2、输出查看命令
echo：显示输入的内容 追加文件echo &amp;quot;liuyazhuang&amp;quot; &amp;gt;&amp;gt; liuyazhuang.txt
cat：显示文件内容,也可以将数个文件合并成一个文件；
格式：格式：cat[参数]&amp;lt;文件名&amp;gt;
cat test.txt：显示test.txt文件内容；
cat test.txt | more ：逐页显示test.txt文件中的内容；
cat test.txt &amp;gt;&amp;gt; test1.txt ：将test.txt的内容附加到test1.txt文件之后；
cat test.txt test2.txt &amp;gt;readme.txt　: 将test.txt和test2.txt文件合并成readme.txt 文件；
head:显示文件的头几行（默认10行） -n:指定显示的行数格式：head -n 文件名；
tail：显示文件的末尾几行（默认10行）-n：指定显示的行数 -f：追踪显示文件更新 （一般用于查看日志，命令不会退出，而是持续显示新加入的内容）；
格式：格式：tail[参数]&amp;lt;文件名&amp;gt;
tail-10 /etc/passwd ：显示/etc/passwd/文件的倒数10行内容；
tail+10 /etc/passwd ：显示/etc/passwd/文件从第10行开始到末尾的内容；
more：用于翻页显示文件内容（只能向下翻页）；
more命令是一般用于要显示的内容会超过一个画面长度的情况。为了避免画 面显示时瞬间就闪过去，用户可以使用more命令，让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按Q键停止显示；
ls -al |more：以长格形式显示etc目录下的文件列表，显示满一个画面便暂停，可 按空格键继续显示下一画面，或按Q键跳离；
less：翻页显示文件内容（带上下翻页）按下上键分页，按q退出；
less命令的用法与more命令类似，也可以用来浏览超过一页的文件。所不同 的是less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在less命令的提示符“：”下按Q键即可；
ls -al | less：以长格形式列出/etc目录中所有的内容。用户可按上下键浏览或按Q键跳离。
3、查看硬件信息
3、查看硬件信息
Ispci：查看PCI设备 -v：查看详细信息
Isusb：查看USB设备 -v：查看详细信息
Ismod：查看加载的模块(驱动)
4、关机、重启
4、关机、重启
shutdown关闭、重启计算机
shutdown[关机、重启]时间 -h关闭计算机 -r：重启计算机
如：立即关机：shutdown -h now
10分钟后关机：shutdown -h +10
23:30分关机：shutdown -h 23:30
立即重启：shutdown -r now
poweroff：立即关闭计算机
reboot：立即重启计算机
5、归档、压缩
5、归档、压缩
zip:压缩文件 zip liuyazhuang.zip myfile 格式为：“zip 压缩后的zip文件文件名”
unzip：解压文件 unzip liuyazhuang.zip
gzip：压缩文件 gzip 文件名
tar：归档文件
tar -cvf out.tar liuyazhuang 打包一个归档（将文件&amp;quot;liuyazhuang&amp;quot;打包成一个归档）
tar -xvf liuyazhuang.tar 释放一个归档（释放liuyazhuang.tar归档）
tar -cvzf backup.tar.gz/etc
-z参数将归档后的归档文件进行gzip压缩以减少大小。
-c：创建一个新tar文件
-v：显示运行过程的信息
-f：指定文件名
-z：调用gzip压缩命令进行压缩
-t：查看压缩文件的内容
-x：解开tar文件
tar -cvf test.tar *：将所有文件打包成test.tar,扩展名.tar需自行加上
tar -zcvf test.tar.gz *：将所有文件打包成test.tar,再用gzip命令压缩
tar -tf test.tar ：查看test.tar文件中包括了哪些文件
tar -xvf test.tar 将test.tar解开
tar -zxvf foo.tar.gz 解压缩
gzip各gunzip命令
gziptest.txt ：压缩文件时，不需要任何参数
gizp–l test.txt.gz：显示压缩率
6、查找
6、查找
locate：快速查找文件、文件夹：locate keyword
此命令需要预先建立数据库，数据库默认每天更新一次，可用updatedb命令手工建立、更新数据库。
find查找位置查找参数
如：
find . -name *liuyazhuang* 查找当前目录下名称中含有&amp;quot;liuyazhuang&amp;quot;的文件
find / -name *.conf 查找根目录下（整个硬盘）下后缀为.conf的文件
find / -perm 777 查找所有权限是777的文件
find / -type d 返回根目录下所有的目录
find . -name &amp;quot;a*&amp;quot;-exec ls -l {} \;
find功能：用来寻找文件或目录
格式：find [&amp;lt;路径&amp;gt;] [匹配条件]
find / -name httpd.conf 搜索系统根目录下名为httpd.conf的文件
7、ctrl+c :终止当前的命令
8、who或w命令
8、who或w命令
功能：查看当前系统中有哪些用户登录
格式：who/w[参数]
9、dmesg命令
9、dmesg命令
功能：显示系统诊断信息、操作系统版本号、物理内存的大小以及其它信息。
10、df命令
10、df命令
功能：用于查看文件系统的各个分区的占用情况。
11、du命令
11、du命令
功能：查看某个目录中各级子目录所使用的硬盘空间数。
格式：du [参数] &amp;lt;目录名&amp;gt;
12、free命令
12、free命令
功能：用于查看系统内存，虚拟内存（交换空间）的大小占用情况。
&lt;/code>&lt;/pre>
&lt;h2 id="vim">VIM&lt;/h2>
&lt;pre>&lt;code>VIM是一款功能强大的命令行文本编辑器，在Linux中通过vim命令可以启动vim编辑器。
一般使用vim + 目标文件路径 的形式使用vim
如果目标文件存在，则vim打开目标文件，如果目标文件不存在，则vim新建并打开该文件。
:q：退出vim编辑器
VIM模式
vim拥有三种模式：
（1）命令模式（常规模式）
vim启动后，默认进入命令模式，任何模式都可以通过esc键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。
命名模式常用命令如下：
i : 在光标前插入文本
o:在当前行的下面插入新行
dd:删除整行
yy：将当前行的内容放入缓冲区（复制当前行）
n+yy :将n行的内容放入缓冲区（复制n行）
p:将缓冲区中的文本放入光标后（粘贴）
u：撤销上一个操作
r:替换当前字符
/ 查找关键字
（2）插入模式
在命令模式下按 &amp;quot; i &amp;quot;键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用esc键可以返回命令模式。
（3）ex模式
在命令模式中按&amp;quot; : &amp;quot;键可以进入ex模式，光标会移动到底部，在这里可以保存修改或退出vim.
ext模式常用命令如下：
:w ：保存当前的修改
:q ：退出
:q! ：强制退出，保存修改
:x :保存并退出，相当于:wq
:set number 显示行号
:! 系统命令 执行一个系统命令并显示结果
:sh ：切换到命令行，使用ctrl+d切换回vim
&lt;/code>&lt;/pre>
&lt;h2 id="软件包管理命令rpm">软件包管理命令(RPM)&lt;/h2>
&lt;pre>&lt;code>1、软件包的安装
1、软件包的安装
使用RPM命令的安装模式可以将软件包内所有的组件放到系统中的正确路径，安装软件包的命令是:rpm –ivh wu-ftpd-2.6.2-8.i386.rpm
i：作用rpm的安装模式 v: 校验文件信息h: 以＃号显示安装进度
2、软件包的删除
2、软件包的删除
删除模式会将指定软件包的内容全部删除，但并不包括已更改过的配置文件，删除RPM软件包的命令如下：rpm –e wu-ftpd
注意：这里必须使用软件名“wu-ftpd”或”wu-ftpd-2.6.2-8而不是使用当初安装时的软件包名.wu-ftpd-2.6.2-8.i386.rpm
3、软件包升级
3、软件包升级
升级模式会安装用户所指定的更新版本，并删除已安装在系统中的相同软件包，升级软件包命令如下：rpm –Uvh wu-ftpd-2.6.2-8.i386.rpm –Uvh：升级参数。
4、软件包更新
4、软件包更新
更新模式下，rpm命令会检查在命令行中所指定的软件包是否比系统中原有的软件 包更新。如果情况属实，rpm命令会自动更新指定的软件包；反之，若系统中并没有指定软件包的较旧版本，rpm命令并不会安装此软件包。而在升级模式下，不管系统中是否有较旧的版本，rpm命令都会安装指定的软件包。
rpm –Fvhwu-ftpd-2.6.2-8.i386.rpm -Fvh：更新参数
5、软件包查询
5、软件包查询
若要获取RPM软件包的相关信息，可以使用查询模式。使用-q参数可查询一个已 安装的软件包的内容。
rpm –q wu-ftpd
查询软件包所安装的位置：rpm –ql package-name
rpm –ql xv (l参数：显示文件列表)
&lt;/code>&lt;/pre></description></item><item><title>Mac 常用命令</title><link>https://blog.baicai.me/article/2023/mac_cmd/</link><pubDate>Fri, 31 Mar 2023 22:54:41 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/mac_cmd/</guid><description>&lt;h2 id="查看指定端口的进程">查看指定端口的进程&lt;/h2>
&lt;p>sudo lsof -i :5353&lt;/p>
&lt;p>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
mDNSRespo 185 _mdnsresponder 6u IPv4 0x1111111111111 0t0 UDP *:mdns
mDNSRespo 185 _mdnsresponder 7u IPv6 0x1111111111111 0t0 UDP *:mdns&lt;/p>
&lt;h2 id="根据进程名称">根据进程名称&lt;/h2>
&lt;p>ps -ef | grep mDNSRespo&lt;/p>
&lt;p>65 185 1 0 8:08上午 ?? 0:26.69 /usr/sbin/mDNSResponder
0 223 1 0 8:08上午 ?? 0:02.16 /usr/sbin/mDNSResponderHelper
501 66848 66623 0 11:00下午 ttys000 0:00.00 grep mDNSRespo&lt;/p>
&lt;h2 id="根据pid杀进程">根据PID杀进程：&lt;/h2>
&lt;p>sudo kill -9 185&lt;/p></description></item><item><title>安装 debian 后，中文环境下将home目录下文件夹更改为对应的英文</title><link>https://blog.baicai.me/article/2023/home_dirs_update/</link><pubDate>Mon, 02 Jan 2023 12:41:04 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/home_dirs_update/</guid><description>&lt;p>操作环境:&lt;/p>
&lt;pre tabindex="0">&lt;code> Distributor ID: Debian
Description: Debian GNU/Linux 11 (bullseye)
Release: 11
Codename: bullseye
&lt;/code>&lt;/pre>&lt;p>安装 debian 后，中文环境下home目录下文件夹显示的是中文，不方便使用cd命令，用到的软件xdg-user-dirs-gtk(Gnome 环境已默认安装),可以方便更改为英文.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#临时转换系统语言为英文，重启后会自动恢复原值的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export LANG&lt;span style="color:#f92672">=&lt;/span>en_US
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#执行转换命令，弹出的窗口中会询问是否将目录转化为英文路径，同意并关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xdg-user-dirs-gtk-update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#转换回系统语言为中文，也可以不执行下面的命令，直接重启也一样的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export LANG&lt;span style="color:#f92672">=&lt;/span>zh_CN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下次进入系统后，会提示是否把目录转化为中文，选择不，并选择不再提示，并取消修改。&lt;/p></description></item><item><title>Debian 安装 Transmission 并实现远程访问</title><link>https://blog.baicai.me/article/2022/debian-install-transmission-daemon-debian-install-transmission-daemon/</link><pubDate>Tue, 18 Oct 2022 17:05:07 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/debian-install-transmission-daemon-debian-install-transmission-daemon/</guid><description>&lt;p>Debian 安装完成后的桌面环境带有 transmission-gtk
这个gui版关闭界面后，无后台服务，导致不能方便使用远程访问。&lt;/p>
&lt;p>那么安装Transmission后台守护程序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sudo apt install -y transmission-daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#停止Transmisson后台服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl stop transmission-daemon.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nano /etc/transmission-daemon/settings.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动transmission后台服务">启动Transmission后台服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#启动transmission服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl start transmission-daemon.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#停止transmission服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl stop transmission-daemon.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查询transmission运行状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl status transmission-daemon.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#将transmission设置为开机自启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable transmission-daemon.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#关闭transmission开机自启&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl disable transmission-daemon.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>安装docker</title><link>https://blog.baicai.me/article/2022/debian_install_docker/</link><pubDate>Fri, 30 Sep 2022 00:38:13 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/debian_install_docker/</guid><description>&lt;p>运行环境&lt;/p>
&lt;pre tabindex="0">&lt;code> Operating System: Debian GNU/Linux 11 (bullseye)
Kernel: Linux 5.10.0-18-amd64
Architecture: x86-64
&lt;/code>&lt;/pre>&lt;h3 id="通过debian官方软件仓库安装">通过Debian官方软件仓库安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 更新软件源 并 安装 docker及相关应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y docker docker.io docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看docker运行状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo systemctl status docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看docker信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo docker info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 验证是否安装成功 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo docker run hello-world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="镜像加速器">镜像加速器&lt;/h3>
&lt;p>访问 &lt;a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors&lt;/a> 获取自己的阿里云镜像加速器地址&lt;/p>
&lt;p>修改 /etc/docker/daemon.json&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tee /etc/docker/daemon.json &lt;span style="color:#e6db74">&amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">{
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-concurrent-downloads&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-concurrent-uploads&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-download-attempts&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://修改为自己的.mirror.aliyuncs.com&amp;#34;,&amp;#34;https://hub-mirror.c.163.com&amp;#34;,&amp;#34;https://registry.aliyuncs.com&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="清理docker对象">清理docker对象&lt;/h3>
&lt;p>prune 命令用来删除不再使用的 docker 对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被 tag 标记和未被容器使用的镜像:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker image prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被容器使用的镜像:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker image prune -af
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有停止运行的容器:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker container prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被挂载的卷:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker volume prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有网络:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker network prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 docker 所有资源:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker system prune
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看容器ip">查看容器ip&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看所有容器的ip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker inspect --format&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看指定容器的ip网络配置包含网络，ip等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker inspect containerId
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看容器的ip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker exec -it containerId ip addr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="修改docker启动目录">修改docker启动目录&lt;/h3>
&lt;p>因为装系统时 /var 分区小，需要把docker 启动后的路径改成 /home/docker , /etc/docker/daemon.json 是 docker 的配置文件，默认是没有的，需要手动创建。&lt;/p>
&lt;p>具体的操作是：&lt;/p>
&lt;p>1: 设置 /etc/docker/daemon.json 文件.
内容参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;data-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;/home/docker&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.创建并修改完daemon.json文件后，需要让这个文件生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># a.修改完成后reload配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># b.重启docker服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># c.查看状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl status docker -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># d.查看服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="调试镜像">调试镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用--entrypoint设置（额外增加-it选项可直接进入容器），进入容器成功。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -it --entrypoint /bin/bash --name 容器名 镜像:v30.2.9
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看程序动态库依赖关系">查看程序动态库依赖关系&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ldd (Debian GLIBC 2.36-9+deb12u1) 2.36&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Copyright (C) 2022 Free Software Foundation, Inc.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This is free software; see the source for copying conditions. There is NO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Written by Roland McGrath and Ulrich Drepper.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldd --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 判断某条命令需要哪些共享库文件的支持，以确保指定的命令在独立的系统内可以可靠的运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldd /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参考">参考&lt;/h3>
&lt;p>Docker官方安装文档：
&lt;a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/&lt;/a>&lt;/p>
&lt;h3 id="docker-daemonjson各配置详解">docker-daemon.json各配置详解&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;api-cors-header&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————在引擎API中设置CORS标头
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;authorization-plugins&amp;#34;&lt;/span>:[], &lt;span style="color:#75715e">//——————要加载的授权插件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;bridge&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————将容器附加到网桥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cgroup-parent&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————为所有容器设置父cgroup
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-store&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————分布式存储后端的URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-store-opts&amp;#34;&lt;/span>:{}, &lt;span style="color:#75715e">//————————设置集群存储选项（默认map []）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-advertise&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————要通告的地址或接口名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;debug&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————启用调试模式，启用后，可以看到很多的启动信息。默认false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-gateway&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器默认网关IPv4地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-gateway-v6&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器默认网关IPv6地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-runtime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;runc&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————容器的默认OCI运行时（默认为&amp;#34; runc&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-ulimits&amp;#34;&lt;/span>:{}, &lt;span style="color:#75715e">//——————容器的默认ulimit（默认[]）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;192.168.1.1&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//——————设定容器DNS的地址，在容器的 /etc/resolv.conf文件中可查看。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns-opts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————容器 /etc/resolv.conf 文件，其他设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns-search&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;exec-opts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————运行时执行选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;exec-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————执行状态文件的根目录（默认为’/var/run/docker‘）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;fixed-cidr&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————固定IP的IPv4子网
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;fixed-cidr-v6&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————固定IP的IPv6子网
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;data-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;/var/lib/docker&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————-Docker运行时使用的根路径，默认/var/lib/docker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;group&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————UNIX套接字的组（默认为&amp;#34;docker&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;hosts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//——————设置容器hosts
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;icc&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用容器间通信（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0.0.0.0&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————绑定容器端口时的默认IP（默认0.0.0.0）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;iptables&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//———————启用iptables规则添加（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ipv6&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用IPv6网络
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip-forward&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//————————默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip-masq&amp;#34;&lt;/span>:&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用IP伪装（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>:[&lt;span style="color:#e6db74">&amp;#34;nodeName=node-121&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//————————docker主机的标签，很实用的功能,例如定义：–label nodeName=host-121
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;live-restore&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//——————在容器仍在运行时启用docker的实时还原
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-driver&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器日志的默认驱动程序（默认为&amp;#34; json-file&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-level&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————设置日志记录级别（&amp;#34;调试&amp;#34;，&amp;#34;信息&amp;#34;，&amp;#34;警告&amp;#34;，&amp;#34;错误&amp;#34;，&amp;#34;致命&amp;#34;）（默认为&amp;#34;信息&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;max-concurrent-downloads&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#75715e">//——————设置每个请求的最大并发下载量（默认为3）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;max-concurrent-uploads&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#75715e">//——————设置每次推送的最大同时上传数（默认为5）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;mtu&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#75715e">//——————设置容器网络MTU
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;oom-score-adjust&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">-500&lt;/span>, &lt;span style="color:#75715e">//——————设置守护程序的oom_score_adj（默认值为-500）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;pidfile&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————Docker守护进程的PID文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;raw-logs&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————全时间戳机制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;selinux-enabled&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————默认 false，启用selinux支持
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;storage-driver&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————要使用的存储驱动程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;swarm-default-advertise-addr&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————设置默认地址或群集广告地址的接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tls&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————默认 false, 启动TLS认证开关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlscacert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————默认 ~/.docker/ca.pem，通过CA认证过的的certificate文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlscert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————默认 ~/.docker/cert.pem ，TLS的certificate文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlskey&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————默认~/.docker/key.pem，TLS的key文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlsverify&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————默认false，使用TLS并做后台进程与客户端通讯的验证
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;userland-proxy&amp;#34;&lt;/span>:&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————使用userland代理进行环回流量（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;userns-remap&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————用户名称空间的用户/组设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;bip&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;192.168.88.0/22&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————————指定网桥IP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;https://192.498.89.232:89&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//————————设置镜像加速
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;insecure-registries&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;192.168.0.123:12312&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//———————设置私有仓库地址可以设为http
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;storage-opts&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;overlay2.override_kernel_check=true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;overlay2.size=15G&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>], &lt;span style="color:#75715e">//————————存储驱动程序选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-opts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;max-file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;max-size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10m&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, &lt;span style="color:#75715e">//————————容器默认日志驱动程序选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;iptables&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e">//————————启用iptables规则添加（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>nginx 启用目录索引，显示文件列表</title><link>https://blog.baicai.me/article/2022/nginx_autoindex_conf/</link><pubDate>Sat, 23 Jul 2022 23:52:39 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/nginx_autoindex_conf/</guid><description>&lt;p>在nginx中，如果特定目录中没有index.html 文件，则默认会返回 404 Not Found 的错误。&lt;/p>
&lt;p>但是，Nginx 自动索引模块—— ngx_http_autoindex_module 模块，提供了一种自动生成列表的方法，添加自动索引非常容易，使用 autoindex on 即可。下面的配置，将在访问特定请求时返回目录结构。&lt;/p>
&lt;pre>&lt;code>官方参考： http://nginx.org/en/docs/http/ngx_http_autoindex_module.html
&lt;/code>&lt;/pre>
&lt;pre tabindex="0">&lt;code> server {
listen 80;
... ...
location /index_dir {
autoindex on;
}
}
&lt;/code>&lt;/pre>&lt;p>除了简单地使用自动索引打开或关闭之外，还可以对其做其他的配置，包括：&lt;/p>
&lt;pre tabindex="0">&lt;code> autoindex_exact_size; 显示输出的确切文件大小，还是最接近的KB，MB或GB。默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB。
autoindex_format; 该指令指定Nginx索引列表应以什么格式输出。该指令有4个选项：html/xml/json/jsonp。
autoindex_localtime; 显示的文件时间为GMT时间。 注意:改为on后，显示的文件时间为文件的服务器时间。
&lt;/code>&lt;/pre>&lt;p>使用这几个配置后配置内容类似于如下内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>location /index_dir/ {
root /data/index_dir/;
autoindex on;
autoindex_exact_size off;
autoindex_format html;
autoindex_localtime on;
}
&lt;/code>&lt;/pre>&lt;p>如果有中文目录的话会出现乱码问题，所以还需要在下面添加这一句：&lt;/p>
&lt;pre tabindex="0">&lt;code>charset utf-8;
&lt;/code>&lt;/pre>&lt;p>或&lt;/p>
&lt;pre tabindex="0">&lt;code>charset utf-8,gbk;
&lt;/code>&lt;/pre></description></item><item><title>PostgresSQL 基本用法：新建数据库、用户、连接、备份/恢复数据库</title><link>https://blog.baicai.me/article/2022/create_use1/</link><pubDate>Fri, 22 Jul 2022 14:26:40 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/create_use1/</guid><description>&lt;p>系统环境：
Debian 11&lt;/p>
&lt;h3 id="切换到超级用户">切换到超级用户：&lt;/h3>
&lt;pre tabindex="0">&lt;code> sudo su postgres
&lt;/code>&lt;/pre>&lt;h3 id="进入psql">进入psql：&lt;/h3>
&lt;pre tabindex="0">&lt;code> psql
&lt;/code>&lt;/pre>&lt;h3 id="创建一个用户">创建一个用户：&lt;/h3>
&lt;pre tabindex="0">&lt;code> CREATE USER username WITH PASSWORD &amp;#39;password&amp;#39;;
&lt;/code>&lt;/pre>&lt;h3 id="查看角色列表">查看角色列表：&lt;/h3>
&lt;pre tabindex="0">&lt;code> \du
&lt;/code>&lt;/pre>&lt;h3 id="创建数据库并制定所有者和编码">创建数据库并制定所有者和编码：&lt;/h3>
&lt;pre tabindex="0">&lt;code> CREATE DATABASE dbname WITH OWNER username ENCODING UTF8;
&lt;/code>&lt;/pre>&lt;h4 id="创建一个数据库">创建一个数据库：&lt;/h4>
&lt;pre tabindex="0">&lt;code> CREATE DATABASE dbname;
&lt;/code>&lt;/pre>&lt;h4 id="查看数据库列表">查看数据库列表：&lt;/h4>
&lt;pre tabindex="0">&lt;code> \l
&lt;/code>&lt;/pre>&lt;h4 id="更改刚创建的数据库所有权">更改刚创建的数据库所有权：&lt;/h4>
&lt;pre tabindex="0">&lt;code> ALTER DATABASE dbname OWNER TO username;
&lt;/code>&lt;/pre>&lt;h4 id="删除表字段">删除表字段&lt;/h4>
&lt;p>要删除一个字段，使用下面这样的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ALTER TABLE products DROP COLUMN description;
&lt;/code>&lt;/pre>&lt;p>不管字段里有啥数据，都会消失，和这个字段相关的约束也会被删除。不过， 如果这个字段被另一个表的外键约束所引用，PostgreSQL 则不会隐含地删除该约束。你可以通过使用CASCADE指明删除任何依赖该字段的东西：&lt;/p>
&lt;pre tabindex="0">&lt;code> ALTER TABLE products DROP COLUMN description CASCADE;
&lt;/code>&lt;/pre>&lt;h3 id="通过psql连接数据库">通过psql连接数据库&lt;/h3>
&lt;pre tabindex="0">&lt;code> psql -h 127.0.0.1 -p 5432 -U username -d dbname
&lt;/code>&lt;/pre>&lt;h3 id="备份数据库">备份数据库&lt;/h3>
&lt;pre tabindex="0">&lt;code> pg_dump dbname &amp;gt; dbname.dump
&lt;/code>&lt;/pre>&lt;h3 id="恢复数据库">恢复数据库&lt;/h3>
&lt;pre tabindex="0">&lt;code> psql -f dbname.dump -d dbname
&lt;/code>&lt;/pre></description></item><item><title>查看 Debian 系统版本的方式</title><link>https://blog.baicai.me/article/2022/debian_version_check/</link><pubDate>Fri, 22 Jul 2022 11:04:30 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/debian_version_check/</guid><description>&lt;p>查看 Dibian 系统发行版本号的方式&lt;/p>
&lt;h3 id="1-使用-lsb_release-命令">1. 使用 lsb_release 命令&lt;/h3>
&lt;p>lsb_release 命令可用于查看 Linux 发行版操作系统的具体版本。它可能尚未安装在你的操作系统中，因此你需要先安装它。运行以下命令来安装 lsb_release：&lt;/p>
&lt;pre tabindex="0">&lt;code> apt-get install lsb-release
&lt;/code>&lt;/pre>&lt;p>安装完成之后，只需要输入下面的命令就可以查看到你当前系统的版本信息：&lt;/p>
&lt;pre tabindex="0">&lt;code> lsb_release -a
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> No LSB modules are available.
Distributor ID: Debian
Description: Debian GNU/Linux 11 (bullseye)
Release: 11
Codename: bullseye
&lt;/code>&lt;/pre>&lt;p>以上运行结果说明当前使用的操作系统版本是 Debian 11.&lt;/p>
&lt;h3 id="2-查看-etcissue-文件">2. 查看 /etc/issue 文件&lt;/h3>
&lt;p>第二种查看当前 Debian 版本的方法是查看位于 /etc 目录中的 issue 文件。你可以使用 cat 命令查看文件的内容，输入下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> cat /etc/issue
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> Debian GNU/Linux 11 \n \l
&lt;/code>&lt;/pre>&lt;h3 id="3-查看-etcos-release-文件">3. 查看 /etc/os-release 文件&lt;/h3>
&lt;p>/etc/os-release 是一个包含操作系统标识数据的文件，它只能在运行 systemd 的最新 Debian 发行版上找到。同样可以使用 cat 命令查看该文件的内容，输入下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code>cat /etc/os-release
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> PRETTY_NAME=&amp;#34;Debian GNU/Linux 11 (bullseye)&amp;#34;
NAME=&amp;#34;Debian GNU/Linux&amp;#34;
VERSION_ID=&amp;#34;11&amp;#34;
VERSION=&amp;#34;11 (bullseye)&amp;#34;
VERSION_CODENAME=bullseye
ID=debian
HOME_URL=&amp;#34;https://www.debian.org/&amp;#34;
SUPPORT_URL=&amp;#34;https://www.debian.org/support&amp;#34;
BUG_REPORT_URL=&amp;#34;https://bugs.debian.org/&amp;#34;
&lt;/code>&lt;/pre>&lt;p>如果想知道更具体的小版本号，可以查看 /etc/debian_version 文件，输入下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> cat /etc/debian_version
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> 11.4
&lt;/code>&lt;/pre>&lt;h3 id="4-使用-uname-命令">4. 使用 uname 命令&lt;/h3>
&lt;p>uname 命令可以显示电脑以及操作系统的相关信息，输入下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> uname -a
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> Linux baicai-l01 5.10.0-16-amd64 #1 SMP Debian 5.10.127-1 (2022-06-30) x86_64 GNU/Linux
&lt;/code>&lt;/pre>&lt;h3 id="5-使用-hostnamectl-命令">5. 使用 hostnamectl 命令&lt;/h3>
&lt;p>hostnamectl 命令用于配置或修改系统的主机名，不过也使用此命令来获取 Debian 系统的版本，只需要直接输入 hostnamectl 即可：&lt;/p>
&lt;pre tabindex="0">&lt;code> hostnamectl
&lt;/code>&lt;/pre>&lt;p>你将看到类似下面的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code> Static hostname: baicai-l01
Icon name: computer-desktop
Chassis: desktop
Machine ID: xxx
Boot ID: xxx
Operating System: Debian GNU/Linux 11 (bullseye)
Kernel: Linux 5.10.0-16-amd64
Architecture: x86-64
&lt;/code>&lt;/pre></description></item><item><title>删除 Debian Gnome 所有默认安装的游戏</title><link>https://blog.baicai.me/article/2022/debian_gnome_remove_game/</link><pubDate>Fri, 22 Jul 2022 10:35:22 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/debian_gnome_remove_game/</guid><description>&lt;p>我用以下命令删除Debian 11.5（带有gnome）中的所有预装游戏：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo apt purge aisleriot gnome-sudoku gnome-nibbles ace-of-penguins gnomine gbrainy gnome-sushi gnome-taquin gnome-tetravex gnome-robots gnome-chess lightsoff swell-foop quadrapassel tali gnome-mahjongg gnome-2048 iagno gnome-klotski five-or-more gnome-mines four-in-a-row hitori &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt autoremove
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>上传公钥实现ssh登录</title><link>https://blog.baicai.me/article/2022/linux_ssh_copy_id/</link><pubDate>Sat, 12 Mar 2022 20:22:55 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/linux_ssh_copy_id/</guid><description>&lt;h3 id="生成密钥和公钥">生成密钥和公钥&lt;/h3>
&lt;p>如果之前已经存在就不用重新生成了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ssh-keygen -t rsa
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="上传公钥">上传公钥&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中root 服务器用户， 192.168.0.1 是服务器ip。之后按照提示输入密码即可&lt;/p>
&lt;h3 id="连接到服务器">连接到服务器&lt;/h3>
&lt;p>直接使用ssh直接连接服务器，无需输入密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ssh root@192.168.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>在 Linux 命令行中使用的 6 个元字符</title><link>https://blog.baicai.me/article/2022/linux_metacharacters/</link><pubDate>Mon, 14 Feb 2022 17:37:24 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/linux_metacharacters/</guid><description>&lt;pre>&lt;code>在 Linux 命令行上使用元字符是提高生产力的一个好方法。
&lt;/code>&lt;/pre>
&lt;p>许多 Linux 电脑是无头运行的，你可以在命令行上完成所有的管理任务。它使用许多所有人都熟悉的基本命令，如 ls、ls-l、ls-l、cd、pwd、top 等等。&lt;/p>
&lt;pre>&lt;code>Linux 上的 Shell 元字符
&lt;/code>&lt;/pre>
&lt;p>你可以通过使用元字符来扩展这些命令。&lt;/p>
&lt;h3 id="管道符-">管道符 |&lt;/h3>
&lt;p>假设我想知道我的系统上运行的 Firefox 的所有实例。我可以使用带有 -ef 参数的 ps 命令来列出我系统上运行的所有程序实例。现在我想只看那些涉及 Firefox 的实例。我使用了我最喜欢的元字符之一，管道符 |，将其结果送到 grep，用它来搜索模式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ps -ef | grep firefox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="输出重定向-">输出重定向 &amp;gt;&lt;/h3>
&lt;p>另一个我最喜欢的元字符是输出重定向 &amp;gt;。我用它来打印 dmesg 命令结果中所有 AMD 相关的结果。你可能会发现这在硬件故障排除中很有帮助：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ dmesg | grep amd &amp;gt; amd.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat amd.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> 0.897&lt;span style="color:#f92672">]&lt;/span> amd_uncore: &lt;span style="color:#ae81ff">4&lt;/span> amd_df counters detected
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> 0.897&lt;span style="color:#f92672">]&lt;/span> amd_uncore: &lt;span style="color:#ae81ff">6&lt;/span> amd_l3 counters detected
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> 0.898&lt;span style="color:#f92672">]&lt;/span> perf/amd_iommu: Detected AMD IOMMU &lt;span style="color:#75715e">#0 (2 banks, 4 counters/bank).&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="星号-">星号 *&lt;/h3>
&lt;p>星号 *（通配符）是寻找具有相同扩展名的文件时我的最爱，如 .jpg 或 .png。我首先进入我的系统中的 Picture 目录，并使用类似以下的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls *.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BlountScreenPicture.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DisplaySettings.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EbookStats.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StrategicPlanMenu.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Screenshot from 01-24 19-35-05.png
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="波浪号-">波浪号 ~&lt;/h3>
&lt;p>波浪号 ~ 是在 Linux 系统上通过输入以下命令快速返回你的家目录的一种方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cd ~
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/home/don
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="美元符号-">美元符号 $&lt;/h3>
&lt;p>$ 符号作为一个元字符有不同的含义。当用于匹配模式时，它意味着任何以给定字符串结尾的字符串。例如，当同时使用元字符 | 和 $ 时：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls | grep png$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BlountScreenPicture.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DisplaySettings.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EbookStats.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StrategicPlanMenu.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Screenshot from 01-24 19-35-05.png
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="上尖号-">上尖号 ^&lt;/h3>
&lt;p>符号 ^ 将结果限制在以给定字符串开始的项目上。例如，当同时使用元字符 | 和 ^ 时：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls | grep ^Screen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Screenshot from 01-24 19-35-05.png
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些元字符中有许多是通往 正则表达式 的大门，所以还有很多东西可以探索。你最喜欢的 Linux 元字符是什么，它们是如何节省你的工作的？&lt;/p>
&lt;p>via:
&lt;a href="https://opensource.com/article/22/2/metacharacters-linux">1&lt;/a>
&lt;a href="https://linux.cn/article-14270-1.html">2&lt;/a>&lt;/p></description></item><item><title>ubuntu上安装微信(wechat)</title><link>https://blog.baicai.me/article/2022/ubuntu_wechat-install/</link><pubDate>Sun, 30 Jan 2022 15:19:12 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/ubuntu_wechat-install/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>由于微信官网 &lt;a href="https://weixin.qq.com/">https://weixin.qq.com/&lt;/a> 没有linux版本的下载和安装方法，但微信确实提供了优麒麟发行版的官方版本，所以就有了下面的安装方法。&lt;/p>
&lt;h2 id="安装方法">安装方法&lt;/h2>
&lt;p>打开优麒麟应用商店官网，然后下载应用，就看到微信了
&lt;a href="https://www.ubuntukylin.com/applications/106-cn.html">https://www.ubuntukylin.com/applications/106-cn.html&lt;/a>
下载deb包，用命令sudo dpkg -i ，就能安装上了，而且可以用。
这是linux原生的，功能少点，但比wine的要轻巧不少。&lt;/p>
&lt;h2 id="安装方法2">安装方法2&lt;/h2>
&lt;p>下载链接在方法1中，优麒麟应用商店微信应用页面右键 “64位下载” ——&amp;gt; “复制链接”
终端下载Deb安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> wget -O ~/weixin.deb &lt;span style="color:#e6db74">&amp;#34;http://archive.ubuntukylin.com/software/pool/partner/weixin_2.1.1_amd64.deb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo dpkg -i ~/weixin.deb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docker 运行 postgreSQL</title><link>https://blog.baicai.me/article/2021/docker_postgres/</link><pubDate>Thu, 09 Dec 2021 14:19:08 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/docker_postgres/</guid><description>&lt;h3 id="简单步骤">简单步骤&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>安装docker，可参考 &lt;a href="https://blog.baicai.me/article/2021/docker_start/">安装docker及简单的使用&lt;/a> 或 百度解决；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉取postgreSQL的docker镜像文件：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker pull postgres
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>创建 docker volume，名字为“dv_pgdata&amp;quot;（其实可以省略手动创建，直接跑下一步，docker也会自动创建的）：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker volume create dv_pgdata
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>启动容器，用-v来指定把postgres的数据目录映射到上面创建的dv_pgdata里面：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --name my_postgres -v dv_pgdata:/var/lib/postgresql/data -e POSTGRES_PASSWORD&lt;span style="color:#f92672">=&lt;/span>xxxxxx -p 5432:5432 -d postgres
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>这时候查看已存在的docker volume:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker volume ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>查看volume信息：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ docker inspect dv_pgdata
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>在宿主机，也可以直接查看volume里的内容：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ cd /var/lib/docker/volumes/dv_pgdata/_data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ ll
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="8">
&lt;li>查看postgresql：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$docker exec -it &lt;span style="color:#ae81ff">618&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@618f1a4128ee:/# psql -U postgres -d postgres -p &lt;span style="color:#ae81ff">5432&lt;/span> -h 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="9">
&lt;li>更多的时候，我们希望能用图形界面来管理和操作数据库，可以部署pgadmin工具（例如下面），然后在浏览器中访问宿主机的5080端口，便能打开pgadmin。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker pull dpage/pgadmin4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --name pgadmin -p 5080:80 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_DEFAULT_EMAIL=hi@nav.xin&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_DEFAULT_PASSWORD=xxxxxx&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION=True&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_LOGIN_BANNER=&amp;#34;Authorised users only!&amp;#34;&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_CONSOLE_LOG_LEVEL=10&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -d dpage/pgadmin4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="用docker-compose部署postgresql和pgadmin4">用docker-compose部署postgresql和pgAdmin4&lt;/h3>
&lt;h4 id="准备步骤">准备步骤&lt;/h4>
&lt;p>安装docker-compose&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> apt install docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>确定已经pull好postgres和pgAdmin4镜像,若未完成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker pull postgres
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker pull dpage/pgadmin4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置内容">配置内容&lt;/h4>
&lt;p>然后在任意目录下新建文件docker-compose.yml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> touch ./docker-compose.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Use postgres/example user/password credentials &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># https://hub.docker.com/_/postgres?tab=description&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在当前目录下运行：sudo docker-compose up -d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 若需停止运行，在当前目录运行：sudo docker-compose down&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># docker路由地址查看： sudo docker inspect postgres_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># sudo docker kill $(sudo docker ps -aq)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># sudo docker rm $(sudo docker ps -aq)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">db&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">postgres&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">privileged&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">postgres_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">5432&lt;/span>:&lt;span style="color:#ae81ff">5432&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">POSTGRES_PASSWORD&lt;/span>: &lt;span style="color:#ae81ff">你的密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGDATA&lt;/span>: &lt;span style="color:#ae81ff">/var/lib/postgresql/data/pgdata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/navxin/kn1/baicai_docker/baicai_postgres/pg_data:/var/lib/postgresql/data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - pgdata:/var/lib/postgresql/data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pgadmin4&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">dpage/pgadmin4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">pgadmin_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">5080&lt;/span>:&lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGADMIN_DEFAULT_EMAIL&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;hi@nav.xin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGADMIN_DEFAULT_PASSWORD&lt;/span>: &lt;span style="color:#ae81ff">你的密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># volumes:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># pgdata:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="部署">部署&lt;/h4>
&lt;p>在当前目录下运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker-compose up -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若需停止运行，在当前目录运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker-compose down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>连接步骤&lt;/p>
&lt;p>打开浏览器，输入localhost:5080，登录pgAdmin4之后，点击添加新服务器，特别注意，在连接地址IP里应该填写docker路由地址，端口填写5432。
docker路由地址查看方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker inspect postgres_baicai
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在输出内容中找到Gateway，对应的地址即为docker路由地址。&lt;/p>
&lt;h3 id="更多参考">更多参考：&lt;/h3>
&lt;p>&lt;a href="https://blog.baicai.me/article/2021/docker_start/">安装docker及简单的使用&lt;/a>
&lt;a href="https://hub.docker.com/_/postgres?tab=description">postgres&lt;/a>
&lt;a href="https://hub.docker.com/r/dpage/pgadmin4">dpage/pgadmin4&lt;/a>&lt;/p></description></item><item><title>Ubuntu使用systemd配置开机运行service</title><link>https://blog.baicai.me/article/2021/ubuntu_systemd_service/</link><pubDate>Wed, 01 Dec 2021 22:44:28 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/ubuntu_systemd_service/</guid><description>&lt;h2 id="systemd">systemd&lt;/h2>
&lt;p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。&lt;/p>
&lt;h2 id="由来">由来&lt;/h2>
&lt;p>历史上，Linux 的启动一直采用init进程。&lt;/p>
&lt;p>下面的命令用来启动服务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> $ sudo /etc/init.d/apache2 start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ service apache2 start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方法有两个缺点。&lt;/p>
&lt;p>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/p>
&lt;p>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/p>
&lt;h2 id="systemd-概述">Systemd 概述&lt;/h2>
&lt;p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p>
&lt;p>使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> $ systemctl --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的命令查看 Systemd 的版本。&lt;/p>
&lt;h2 id="使用-systemd-实现开机执行-shell-脚本">使用 systemd 实现开机执行 Shell 脚本&lt;/h2>
&lt;h3 id="通用操作步骤">通用操作步骤&lt;/h3>
&lt;p>创建希望开机马上执行的脚本，本文举例脚本存放位置为 /home/navxin/Example/startup.sh，脚本内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e"># 开机时在脚本的同级目录下创建一个名为 StartupTouch.txt 的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch /home/navxin/Example/startup.sh.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开机执行的脚本需增加可执行权限才能被-systemd-运行使用如下命令">开机执行的脚本需增加可执行权限才能被 systemd 运行，使用如下命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>chmod u+x /home/navxin/Example/startup.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod g+x /home/navxin/Example/startup.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="进入-systemd-放置-service-的目录在该目录下可看到大量服务配置文件命令如下">进入 systemd 放置 service 的目录，在该目录下可看到大量服务配置文件，命令如下&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 进入 systemd 的 service 目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd /usr/lib/systemd/system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看文件列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -al
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>在该目录创建一个新的 .service 文件用于配置开机启动脚本，本例中的文件名为 StartupExample.service，所执行命令和文件中的配置内容如下：
&lt;/code>&lt;/pre>
&lt;h3 id="创建服务配置文件">创建服务配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo touch /usr/lib/systemd/system/StartupExample.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下为 StartupExample.service 配置文件的内容&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=Startup Example
[Service]
ExecStart=/home/navxin/Example/startup.sh
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;h3 id="尝试手动运行新创建的-service使用如下命令">尝试手动运行新创建的 service，使用如下命令：&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 手动运行 StartupExample.service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl start StartupExample.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看运行日志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl status StartupExample.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 删除刚测试服务时创建的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm -f /home/navxin/Example/startup.sh.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设置服务为 enable 状态，使之能开机运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo systemctl enable StartupExample.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 重启机器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> systemctl reboot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附注unit">附注：Unit&lt;/h2>
&lt;p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。&lt;/p>
&lt;p>Unit 一共分成12种。&lt;/p>
&lt;pre>&lt;code> Service unit：系统服务
Target unit：多个 Unit 构成的一个组
Device Unit：硬件设备
Mount Unit：文件系统的挂载点
Automount Unit：自动挂载点
Path Unit：文件或路径
Scope Unit：不是由 Systemd 启动的外部进程
Slice Unit：进程组
Snapshot Unit：Systemd 快照，可以切回某个快照
Socket Unit：进程间通信的 socket
Swap Unit：swap 文件
Timer Unit：定时器
&lt;/code>&lt;/pre>
&lt;p>systemctl list-units命令可以查看当前系统的所有 Unit 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出正在运行的 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ systemctl list-units
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出所有Unit，包括没有找到配置文件的或者启动失败的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ systemctl list-units --all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出所有没有运行的 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ systemctl list-units --all --state&lt;span style="color:#f92672">=&lt;/span>inactive
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出所有加载失败的 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ systemctl list-units --failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出所有正在运行的、类型为 service 的 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $ systemctl list-units --type&lt;span style="color:#f92672">=&lt;/span>service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 列出所有正在运行的、类型为 mount 的 Unit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $systemctl list-units --type&lt;span style="color:#f92672">=&lt;/span>mount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 命令用于列出所有配置文件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $systemctl list-unit-files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> $systemctl list-unit-files --type&lt;span style="color:#f92672">=&lt;/span>mount
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 myadmin.service文件，增加语句&lt;/p>
&lt;pre tabindex="0">&lt;code> After=network-online.target remote-fs.target nss-lookup.target navxin-kn1.mount
Wants=network-online.target
&lt;/code>&lt;/pre>&lt;p>全部文件内容如下(部分内容参考nginx.service)：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf"> # /lib/systemd/system/myadmin.service
[Unit]
Description=Start myAdmin web server
Documentation=https://www.lyhuilin.com/
After=network-online.target remote-fs.target nss-lookup.target navxin-kn1.mount
Wants=network-online.target
[Service]
Environment=&amp;#34;WELCOME=Baicai myAdmin Base Environment.&amp;#34;
ExecStartPre=/bin/echo ${WELCOME}
ExecStart=/baicai/systemdStart/my_admin/my_admin -c /baicai/systemdStart/my_admin/conf/config.yaml
ExecStop=/bin/kill -s TERM ${MAINPID}
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre></description></item><item><title>安装docker及简单的使用</title><link>https://blog.baicai.me/article/2021/docker_start/</link><pubDate>Tue, 05 Oct 2021 17:21:06 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/docker_start/</guid><description>&lt;h2 id="docker的介绍里面包括了3个基本概念">docker的介绍，里面包括了3个基本概念&lt;/h2>
&lt;h3 id="11-docker主要由镜像和容器构成">1.1 docker主要由镜像和容器构成&lt;/h3>
&lt;p>镜像（Image）:docker镜像好比一个模板，相当于一个文件系统&lt;/p>
&lt;p>容器（Container）:容器需要通过镜像来创建。镜像和容器就像是面向对象中的类和实例一样。容器可以被创建/启动/停止/删除等&lt;/p>
&lt;p>仓库（Repository）:仓库就是存放镜像的地方，分为私有仓库和公有仓库。类似git&lt;/p>
&lt;h3 id="12-docker的运行原理">1.2 docker的运行原理&lt;/h3>
&lt;p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问。dockerServer接收到docker-Client的指令，就会执行这个命令。&lt;/p>
&lt;h2 id="一-mac-系统-docker-的安装">一. Mac 系统 docker 的安装&lt;/h2>
&lt;p>1.1 homebrew的cask应支持Docker for Mac,所以可以直接安装 brew cask install docker&lt;/p>
&lt;p>1.2 也可以直接到官网下载，https://download.docker.com/mac/stable/Docker.dmg&lt;/p>
&lt;p>1.3 docker的参考文档：https://docs.docker.com&lt;/p>
&lt;p>1.4 dockerhub查找镜像源地址：https://hub.docker.com&lt;/p>
&lt;h2 id="二-docker的使用">二. docker的使用&lt;/h2>
&lt;h3 id="11-查看版本">1.1 查看版本&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-compose --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-machine --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-查看docker系统信息包括镜像和容器的数量等">1.2 查看docker系统信息（包括镜像和容器的数量等）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-帮助命令">1.3 帮助命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker help
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="14-查看-cpu的状况">1.4 查看 cpu的状况&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stats
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="三-docker的基本命令">三. docker的基本命令&lt;/h2>
&lt;p>镜像相关命令：&lt;/p>
&lt;h3 id="11-查看镜像可用版本nginx为例">1.1 查看镜像可用版本（nginx为例）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker search nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-下载一个镜像">1.2 下载一个镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker pull nginx:latest &lt;span style="color:#75715e">#（：后面跟镜像版本）&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-运行一个nginx服务器">1.3 运行一个nginx服务器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d -p 81:80 --name webserver nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#--name webserver ：容器名称，用来区分容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-p 81:80 ：端口进行映射，将本地的81端口映射到容器内部的80端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-v ～/nginx/html:/usr/share/nginx/html 数据卷挂载ro/rw，将主机项目中的目录挂载到容器的目录下，默认rw只能在宿主机外改变，容器内部不能改变&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-d：设置容器中在后台一直运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-it：使用交互方式运行，进入容器查看内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-P：随机端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-e：环境配置设置&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：后台启动运行，必须要有一个前台进程，docker发现没有应用，就会自动停止&lt;/p>
&lt;p>重点：数据卷挂载分为具名/匿名/指定路径挂载，容器数据卷挂载可以实现数据共享，容器的持久化和同步操作，可以使用docker volume 查看卷的情况，可以使用volumes-from实现多个容器之间的数据共享。&lt;/p>
&lt;h3 id="14-停止nginx服务">1.4 停止nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stop webserver&lt;span style="color:#f92672">(&lt;/span>容器ID&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="15-删除nginx服务">1.5 删除nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm webserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16-启动重启nginx服务">1.6 启动/重启nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker start/restart webserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17-列出所有镜像列表包含了-仓库名标签镜像-id创建时间-以及-所占用的空间">1.7 列出所有镜像(列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker images ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;pre>&lt;code>REPOSITORY 镜像的仓库源
TAG 镜像的标签
IMAGE ID 镜像的id
CREATED 镜像的创建时间
SIZE 镜像的大小
&lt;/code>&lt;/pre>
&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-a：列出所有的镜像
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-q：只显示镜像的id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：镜像ID是唯一标识，一个镜像可以对应多个标签&lt;/p>
&lt;h3 id="18-查看镜像容器数据卷所占用的空间">1.8 查看镜像、容器、数据卷所占用的空间&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker system df
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="19-删除镜像">1.9 删除镜像&lt;/h3>
&lt;p>指定镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#f92672">[&lt;/span>镜像名称/镜像短ID/镜像长ID/镜像摘要&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多个镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi 镜像ID 镜像ID 镜像ID
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>全部镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="20-删除docker-images-ls-命令配合-删除所有仓库名为redis的镜像">2.0 删除docker images ls 命令配合 删除所有仓库名为redis的镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images ls -q redis&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="21-查看镜像运行记录">2.1 查看镜像运行记录&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker history 镜像id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>容器相关命令&lt;/p>
&lt;h3 id="11-列出容器">1.1 列出容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker ps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-a：显示所有的容器，包括未运行的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-l：显示最近创建的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-n：列出最近创建的n个容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-q：只显示容器的编号&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-进入容器">1.2 进入容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker exec -it &lt;span style="color:#f92672">[&lt;/span>容器名称&lt;span style="color:#f92672">]&lt;/span> /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker atthch 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>区别：docker exec 进入容器后开启一个新的终端，可以在里面操作；docker attach 进入容器正在执行的终端，不会启动新的进程&lt;/p>
&lt;h3 id="13-退出容器">1.3 退出容器&lt;/h3>
&lt;p>容器停止退回主机&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>容器不停止推出&lt;/p>
&lt;pre>&lt;code>ctrl+p+q
&lt;/code>&lt;/pre>
&lt;h3 id="14-删除容器">1.4 删除容器&lt;/h3>
&lt;p>指定容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#f92672">[&lt;/span>容器id&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多个容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm 容器id 容器id 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker ps -a -q|xargs docker rm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：不能删除正在运行的容器，要删除正在运行的容器需要加 -f 参数，docker rm -f 容器id&lt;/p>
&lt;h3 id="15-启动重启容器">1.5 启动/重启容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker start/restart 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16-停止强制停止容器">1.6 停止/强制停止容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stop/kill 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17-查看容器日志">1.7 查看容器日志&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker logs -f -t --tail &lt;span style="color:#ae81ff">100&lt;/span> 容器id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#--tail后面必须加参数条数&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="18-查看容器中的进程信息">1.8 查看容器中的进程信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker top 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="19-查看容器的元数据重要命令">1.9 查看容器的元数据（重要命令）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker inspect 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="20-从容器上拷贝数据到主机上">2.0 从容器上拷贝数据到主机上&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker cp 容器id:容器内路径 主机路径
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四-dockerfile的指令">四. Dockerfile的指令&lt;/h2>
&lt;pre>&lt;code>FROM 基础镜像，一切从这里开始
MAINTAINER 镜像的作者 姓名&amp;lt;邮箱&amp;gt;
RUN 镜像构建需要运行的命令
ADD 步骤，添加内容
WORKDIR 镜像的工作目录
VOLUME 挂载的目录
EXPOST 端口配置
CMD 指定容器启动要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT 指定这个容器启动要运行的命令，可以追加命令
ONBUILD 当构建一个被继承的Dockerfile时会运行
COPY 类似ADD将我们文件拷贝到镜像中
ENV 构建的时候设置环境变量
&lt;/code>&lt;/pre></description></item><item><title>ubuntu上安装firefox</title><link>https://blog.baicai.me/article/2021/ubuntu_firefox-install/</link><pubDate>Wed, 29 Sep 2021 16:19:42 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/ubuntu_firefox-install/</guid><description>&lt;h2 id="卸载原来firefox">卸载原来Firefox&lt;/h2>
&lt;pre>&lt;code>sudo apt-get purge firefox
&lt;/code>&lt;/pre>
&lt;p>或
sudo apt-get remove firefox&lt;/p>
&lt;h2 id="下载最新firefox二进制压缩包">下载最新Firefox二进制压缩包&lt;/h2>
&lt;pre>&lt;code>wget -O ~/firefox.tar.bz2 &amp;quot;https://download.mozilla.org/?product=firefox-latest&amp;amp;os=linux64&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="解压并移动到opt目录">解压并移动到/opt目录&lt;/h2>
&lt;pre>&lt;code>sudo tar xjf ~/firefox.tar.bz2 -C /opt/
&lt;/code>&lt;/pre>
&lt;h2 id="创建软链接">创建软链接&lt;/h2>
&lt;pre>&lt;code>sudo ln -s /opt/firefox/firefox /usr/lib/firefox/firefox
&lt;/code>&lt;/pre>
&lt;p>在/usr/lib/中创建一个firefox可执行链接文件，该文件指向/opt中firefox可执行主程序位置。&lt;/p>
&lt;h2 id="启动firefox">启动firefox&lt;/h2>
&lt;p>终端启动Firefox&lt;/p>
&lt;pre>&lt;code>firefox
&lt;/code>&lt;/pre>
&lt;h2 id="创建桌面快捷方式">创建桌面快捷方式&lt;/h2>
&lt;p>进入/usr/share/applications目录&lt;/p>
&lt;pre>&lt;code>touch firefox.desktop
nano firefox.desktop
&lt;/code>&lt;/pre>
&lt;p>添加内容：&lt;/p>
&lt;pre>&lt;code>[Desktop Entry]
Name=firefox
Comment=firefox
Exec=/opt/firefox/firefox
Icon=/opt/firefox/browser/chrome/icons/default/default128.png
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
&lt;/code>&lt;/pre>
&lt;h2 id="卸载firefox">卸载Firefox&lt;/h2>
&lt;p>通过上面方法安装的Firefox，如果想删除，可以在终端种输入以下命令：&lt;/p>
&lt;pre>&lt;code>sudo rm -rf /opt/firefox
sudo rm /usr/share/applications/firefox.desktop
&lt;/code>&lt;/pre></description></item><item><title>如何知道谁在ping我？</title><link>https://blog.baicai.me/article/2021/tcpdump_icmp-echo/</link><pubDate>Sat, 28 Aug 2021 21:14:41 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/tcpdump_icmp-echo/</guid><description>&lt;blockquote>
&lt;p>tcpdump 是 Linux 上可用的最强大和使用最广泛的 命令行 数据包嗅探器(包分析器)工具。&lt;/p>&lt;/blockquote>
&lt;p>在您要监控的计算机的终端应用程序中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tcpdump -i ethX icmp and icmp&lt;span style="color:#f92672">[&lt;/span>icmptype&lt;span style="color:#f92672">]=&lt;/span>icmp-echo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-n avoid a &lt;span style="color:#f92672">(&lt;/span>potentially slow&lt;span style="color:#f92672">)&lt;/span> reverse DNS query
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>−i interface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>icmp&lt;span style="color:#f92672">[&lt;/span>icmptype&lt;span style="color:#f92672">]=&lt;/span>icmp-echo To print all ICMP packets that are echo requests/replies
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它将开始侦听 ethX 并等待到达的数据包。&lt;/p>
&lt;p>示例：我有 2 台 pc win7 192.168.0.8 , Ubuntu 192.168.0.57 它将监控到达的数据包：
在Win上：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ping 192.168.0.57
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Ubuntu 上：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tcpdump -i eth0 icmp and icmp&lt;span style="color:#f92672">[&lt;/span>icmptype&lt;span style="color:#f92672">]=&lt;/span>icmp-echo -n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考：nixCraft&lt;a href="http://www.cyberciti.biz/howto/question/man/tcpdump-man-page-with-examples.php">[1]&lt;/a>&lt;/p></description></item><item><title>使用 df 命令查看 Linux 上的可用磁盘空间</title><link>https://blog.baicai.me/article/2021/check-disk-space-linux-df/</link><pubDate>Wed, 04 Aug 2021 16:12:56 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/check-disk-space-linux-df/</guid><description>&lt;p>磁盘空间已经不像计算机早期那样珍贵，但无论你有多少磁盘空间，总有耗尽的可能。计算机需要一些磁盘空间才能启动运行，所以为了确保你没有在无意间用尽了所有的硬盘空间，偶尔检查一下是非常必要的。在 Linux 终端，你可以用 df 命令来做这件事。&lt;/p>
&lt;p>df 命令可以显示文件系统中可用的磁盘空间。&lt;/p>
&lt;p>要想使输出结果易于阅读，你可以加上 &amp;ndash;human-readable（或其简写 -h）选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ df --human-readable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sda1 1.0T 525G 500G 52% /
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，计算机的磁盘已经用了 52%，还有 500 GB 可用空间。&lt;/p>
&lt;p>由于 Linux 从整体上看待所有挂载设备的文件系统，df 命令会展示出连接到计算机上的每个存储设备的详细信息。如果你有很多磁盘，那么输出结果将会反映出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ df --human-readable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/root 110G 45G 61G 43% /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devtmpfs 12G &lt;span style="color:#ae81ff">0&lt;/span> 12G 0% /dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 12G 848K 12G 1% /run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sda1 1.6T 1.3T 191G 87% /home
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdb1 917G 184G 687G 22% /penguin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdc1 57G 50G 4.5G 92% /sneaker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdd1 3.7T 2.4T 1.3T 65% /tux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，计算机的 /home 目录已经用了 87%，剩下 191 GB 的可用空间。&lt;/p>
&lt;h3 id="查看总的可用磁盘空间">查看总的可用磁盘空间&lt;/h3>
&lt;p>如果你的文件系统确实很复杂，而你希望看到所有磁盘的总空间，可以使用 &amp;ndash;total 选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ df --human-readable --total
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/root 110G 45G 61G 43% /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>devtmpfs 12G &lt;span style="color:#ae81ff">0&lt;/span> 12G 0% /dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs 12G 848K 12G 1% /run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sda1 1.6T 1.3T 191G 87% /home
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdb1 917G 184G 687G 22% /penguin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdc1 57G 50G 4.5G 92% /sneaker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sdd1 3.7T 2.4T 1.3T 65% /tux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 6.6T 4.0T 2.5T 62% -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出的最后一行展示了文件系统的总空间、已用总空间、可用总空间。&lt;/p>
&lt;h3 id="查看磁盘空间使用情况">查看磁盘空间使用情况&lt;/h3>
&lt;p>如果你想大概了解哪些文件占用了磁盘空间，请阅读我们关于 du 命令[1] 的文章。&lt;/p>
&lt;p>via:
&lt;a href="https://opensource.com/article/21/7/check-disk-space-linux-df">https://opensource.com/article/21/7/check-disk-space-linux-df&lt;/a>
&lt;a href="https://linux.cn/article-13646-1.html">https://linux.cn/article-13646-1.html&lt;/a>&lt;/p></description></item><item><title>Ubuntu安装 Zlib</title><link>https://blog.baicai.me/article/2021/zlib/</link><pubDate>Mon, 12 Jul 2021 21:01:31 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/zlib/</guid><description>&lt;blockquote>
&lt;p>如果你尝试在 Ubuntu 上安装 zlib，它会抛出 “unable to locate package zlib” 错误。&lt;/p>&lt;/blockquote>
&lt;p>Zlib 是一个用于数据压缩的开源库。&lt;/p>
&lt;p>作为使用者，你可能会遇到需要安装 zlib（或 zlib-devel 包）作为另一个应用程序的依赖项的情况。&lt;/p>
&lt;p>但问题来了，如果你尝试在 Ubuntu 上安装 zlib，它会抛出 “unable to locate package zlib” 错误。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo apt install zlib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Reading package lists... Done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Building dependency tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Reading state information... Done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E: Unable to locate package zlib
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么会看到这个 Ubable to locate package 错误呢？因为没有名为 zlib 的包。&lt;/p>
&lt;p>如果你 使用 apt search 命令，你会发现有几个包可以让你安装：zlib 1g 和 zlib 1g-dev。当你知道这些后，只需一个 apt 命令就可以安装它们。&lt;/p>
&lt;h2 id="在基于-ubuntu-的-linux-发行版上安装-zlib">在基于 Ubuntu 的 Linux 发行版上安装 Zlib&lt;/h2>
&lt;p>打开终端，使用以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo apt install zlib1g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请记住 g 前面的字母是数字 1，而不是小写的字母 L。很多人在输入命令时都会犯这个错误。&lt;/p>
&lt;p>另一个包，zlib 1g-dev 是开发包。只有在你需要时才安装它，否则你应该使用 zlib 1g 包。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> sudo apt install zlib1g-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你也可以 Zlib 网站 下载源代码并安装它。但是，除非你有充分的理由，否则我不推荐使用源代码方式来安装 zlib。例如，如果你需要最新或特定版本的 zlib，但该版本在发行版的仓库中不可用。&lt;/p>
&lt;p>有趣的是，像安装 zlib 这样看似很小的东西可能会变得很麻烦，有两个原因：一个是不同的包名；另一个是包含“隐藏”数字 1，它与小写 L 混淆了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>Zlib &lt;a href="https://zlib.net/">[1]&lt;/a>&lt;/p></description></item><item><title>Ubuntu安装 qbittorrent-nox并启动</title><link>https://blog.baicai.me/article/2021/qbittorrent/</link><pubDate>Fri, 02 Jul 2021 21:01:31 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/qbittorrent/</guid><description>&lt;h3 id="qbittorrent-nox">Qbittorrent-Nox&lt;/h3>
&lt;p>要在Linux上使用Qbittorrent Web UI，你无需安装完整的Qbittorent桌面应用程序，有一个基于终端的Qbittorrent应用程序可用，它被称为Qbittorrent-Nox。&lt;/p>
&lt;p>注意：Web UI功能不仅限于Qbittorrent-Nox应用程序，此功能还可以与传统的Qbittorent Linux桌面应用程序一起使用&lt;/p>
&lt;h3 id="安装qbittorrent">安装qbittorrent&lt;/h3>
&lt;h4 id="安装add-apt-repository命令">安装add-apt-repository命令&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt-get install software-properties-common -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="添加qbittorrent-nox的ppa软件源">添加qbittorrent-nox的PPA软件源&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="安装qbittorrent-noxwebui版">安装qbittorrent-nox（webui版）&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt-get install qbittorrent-nox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="设置开机启动">设置开机启动&lt;/h3>
&lt;h4 id="通过rclocal完成">通过rc.local完成&lt;/h4>
&lt;p>如果是Ubuntu-16.10及其之后的版本需要先按下面的文章完成设置后，开机启动才会生效&lt;/p>
&lt;p>Ubuntu-18.04设置开机启动脚本
起因Ubuntu-16.10（不包括）之前的版本使用的是update-rc.d以及rc.local等方法设置开机启&amp;hellip;&lt;/p>
&lt;p>编辑rc.local脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nano /etc/rc.local
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在exit 0前面（前一行）添加以下内容并保存&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qbittorrent-nox -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="通过创建自定义服务实现">通过创建自定义服务实现&lt;/h4>
&lt;p>创建系统服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install nano -y &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nano /etc/systemd/system/qbittorrent-nox.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>粘贴以下内容，并保存。&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=qBittorrent-nox
After=network.target
[Service]
User=root
Type=simple
RemainAfterExit=yes
ExecStart=/usr/bin/qbittorrent-nox -d
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>启动qbittorrent-nox并创建服务配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start qbittorrent-nox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置开机自动启动qbittorrent-nox&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable qbittorrent-nox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看qbittorrent-nox状态&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl status qbittorrent-nox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认账号：admin 密码： adminadmin
默认登陆网址：ip:8080&lt;/p></description></item><item><title>MAC命令快速模糊查找文件</title><link>https://blog.baicai.me/article/2021/mac_find/</link><pubDate>Sun, 27 Jun 2021 10:04:44 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/mac_find/</guid><description>&lt;h3 id="find命令">find命令&lt;/h3>
&lt;p>描述：通过 find命令查找
语法：find ~ -iname “文件名*”&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 比如我要查找一个以‘vue-’开头的.zip文件,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 但是你忘了它的全名也忘了在那个文件夹，
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 查找范围是‘～’节点以内
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 就可以用这种方式进行模糊搜索
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find ~ -iname &lt;span style="color:#e6db74">&amp;#34;vue-*.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 然后它就把所有包含符合条件的文件和路径都打印出来了
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>find不但能查找文件，还能查找文件夹&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 比如我要查找所有包含‘vue’的文件或文件夹
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find ~ -iname &lt;span style="color:#e6db74">&amp;#34;*vue*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 结果它找到了所有包含‘vue’的文件或文件夹
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>find方式很简单但是需要一点专业知识，需要知道一些正则的基本常识，需要指定路径范围，搜索的名字需要加引号等等&lt;/p>
&lt;h3 id="mdfind命令">mdfind命令&lt;/h3>
&lt;p>描述：通过 mdfind命令查找
语法：mdfind -name 文件名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 比如我要查找所有包含‘vue’的文件或文件夹
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mdfind -name vue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 看，我直接输入我要找的关键字‘vue’
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 就把所有文件和文件夹都输出出来了，是不是很方便
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mdfind 简单粗暴，没缺点，但有个前提是你mac电脑要支持Spotlight功能，不过也不用担心，一般mac默认是支持的&lt;/p>
&lt;h3 id="在-shell-中执行命令">在 shell 中执行命令&lt;/h3>
&lt;blockquote>
&lt;p>你是找到这个文件或文件夹了，但是你想直接打开它，那么怎么打开呢，看下面&lt;/p>&lt;/blockquote>
&lt;p>若要运行当前用户个人文件夹中的命令，请在前面加上文件夹说明符。例如，若要运行 MyCommandLineProg，请使用以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>% ~/MyCommandLineProg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若要打开一个 App，请使用打开命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>% open -a MyProg.app
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="终止命令">终止命令&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>在 Mac 上的“终端” App 中，点按正在运行您想要终止的命令的“终端”窗口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按下 Control-C 键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这会发出一个让大多数命令终止的信号。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>在 Mac 上的“终端”中执行命令和运行工具 &lt;a href="https://support.apple.com/zh-cn/guide/terminal/apdb66b5242-0d18-49fc-9c47-a2498b7c91d5/mac">[1]&lt;/a>&lt;/p>
&lt;p>MAC命令快速全局查找文件或文件夹，支持模糊搜索 &lt;a href="https://blog.csdn.net/weixin_34403976/article/details/88844651">[2]&lt;/a>&lt;/p></description></item><item><title>用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上</title><link>https://blog.baicai.me/article/2021/linux_deskreen/</link><pubDate>Mon, 21 Jun 2021 19:50:25 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux_deskreen/</guid><description>&lt;blockquote>
&lt;p>如果你有多显示器设置，你会意识到拥有多个屏幕的好处。而且，有了 Deskreen，你可以把任何设备变成你的副屏。&lt;/p>&lt;/blockquote>
&lt;h3 id="deskreen将任何设备变成你的-linux-系统的副屏">Deskreen：将任何设备变成你的 Linux 系统的副屏&lt;/h3>
&lt;p>Deskreen 是一个自由开源的应用，可以让你使用任何带有 Web 浏览器的设备来作为电脑的副屏。&lt;/p>
&lt;p>如果你愿意，它还支持多个设备连接。&lt;/p>
&lt;p>Deskreen 很容易使用，当你的所有设备都连接到同一个 Wi-Fi 网络时，它可以正常工作。&lt;/p>
&lt;p>让我们来看看它的功能和工作原理。
Deskreen 的功能&lt;/p>
&lt;p>Deskreen 的功能包括以下要点：&lt;/p>
&lt;ul>
&lt;li>分享整个屏幕的能力&lt;/li>
&lt;li>选择一个特定的应用窗口进行串流&lt;/li>
&lt;li>翻转模式，将你的屏幕作为提词器使用&lt;/li>
&lt;li>支持多种设备&lt;/li>
&lt;li>高级视频质量设置&lt;/li>
&lt;li>提供端对端加密&lt;/li>
&lt;li>最小的系统要求&lt;/li>
&lt;li>黑暗模式&lt;/li>
&lt;/ul>
&lt;p>没有一个冗长的功能列表，但对大多数用户来说应该是足够的。&lt;/p>
&lt;h3 id="如何使用-deskreen-应用">如何使用 Deskreen 应用？&lt;/h3>
&lt;p>Deskreen 使用分为三个简单的步骤，让我为你强调一下，以便你开始使用：&lt;/p>
&lt;p>首先，当你启动该应用时，它会显示一个二维码和一个 IP 地址，以帮助你用 Web 浏览器连接其他设备，以串流你的屏幕。&lt;/p>
&lt;p>你可以按你喜欢的方式，在你的辅助设备上的 Web 浏览器的帮助下建立连接。&lt;/p>
&lt;p>当你扫描二维码或在浏览器的地址栏中输入 IP 地址，你会在 Deskreen 应用上得到一个提示，允许或拒绝连接。除非是你不认识它，否则就允许吧。&lt;/p>
&lt;p>接下来，你将被要求选择你想要串流的内容（你的整个屏幕或特定的应用窗口）：&lt;/p>
&lt;p>你可以选择串流整个屏幕或选择你想串流的窗口。然而，并不是每个应用窗口都能被检测到。&lt;/p>
&lt;p>你只需要选择源并确认，就可以了。你应该注意到它在你的副屏（手机/桌面）上开始串流。&lt;/p>
&lt;p>Deskreen 还为你提供了管理连接设备的能力。因此，如果你需要断开任何会话或所有会话的连接，你可以从设置中进行操作。&lt;/p>
&lt;h3 id="在-linux-中安装-deskreen">在 Linux 中安装 Deskreen&lt;/h3>
&lt;p>你会找到一个用于 Linux 机器的 DEB 包和 AppImage 文件。如果你不知道，可以通过我们的 安装 DEB 包 和 使用 AppImage 文件 指南来安装它。&lt;/p>
&lt;p>你可以从 官方网站 下载它，或者从它的 &lt;a href="https://github.com/pavlobu/deskreen">GitHub&lt;/a> 页面探索更多的信息。&lt;/p>
&lt;h3 id="结束语">结束语&lt;/h3>
&lt;p>考虑到它使用 Wi-Fi 网络工作，在串流方面绝对没有问题。这是一种奇妙的方式，可以与别人分享你的屏幕，或者出于任何目的将其串流到第二个设备上。&lt;/p>
&lt;p>当然，它不能取代你的电脑的第二个显示器的优势，但在一些使用情况下，你可能不需要第二个屏幕。&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>With Deskreen, You Can Mirror or Stream Your Linux Computer Screen to Any Device &lt;a href="https://itsfoss.com/deskreen/">[1]&lt;/a>&lt;/p>
&lt;p>用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上 &lt;a href="https://linux.cn/article-13507-1.html">[2]&lt;/a>&lt;/p></description></item><item><title>Linux 常用命令</title><link>https://blog.baicai.me/article/2021/linux_cmd/</link><pubDate>Sat, 05 Jun 2021 10:31:29 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux_cmd/</guid><description>&lt;p>Linux 常用命令&lt;/p>
&lt;h3 id="日期">日期&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">$(&lt;/span>date -d &lt;span style="color:#e6db74">&amp;#39;1 day ago&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+%Y-%m-%d&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用方法&lt;/p>
&lt;h3 id="数字格式化">数字格式化&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>part&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>printf &lt;span style="color:#e6db74">&amp;#34;%03d&amp;#34;&lt;/span> $i&lt;span style="color:#e6db74">`&lt;/span> &lt;span style="color:#75715e"># 左补0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除旧文件">删除旧文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 找出5天前修改的文件名以.tar结尾的文件进行删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find /www/backup -mtime +5 -name &lt;span style="color:#e6db74">&amp;#34;*.tar&amp;#34;&lt;/span> |xargs rm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="for循环">for循环&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">((&lt;/span>i&lt;span style="color:#f92672">=&lt;/span>0;i&amp;lt;10;i++&lt;span style="color:#f92672">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_date&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date +%Y-%m-%d -d &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> day&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $_date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#f92672">{&lt;/span>1..10&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文件合并">文件合并&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>find ./ -name &lt;span style="color:#e6db74">&amp;#34;item*&amp;#34;&lt;/span> | xargs sed &lt;span style="color:#e6db74">&amp;#39;a\&amp;#39;&lt;/span> &amp;gt; all.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find ./ -name &lt;span style="color:#e6db74">&amp;#34;item*&amp;#34;&lt;/span> | xargs cat &amp;gt; all.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:s/old/new &lt;span style="color:#75715e">#替换当前行的第一个old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:s/old/new/g &lt;span style="color:#75715e">#替换当前行的所有的old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:.,$s/old/new &lt;span style="color:#75715e">#替换当前行到最后行的第一个old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:.,$s/old/new/g &lt;span style="color:#75715e">#替换当前行到最后行的所有old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:N,Ms/old/new &lt;span style="color:#75715e">#替换第N行到第M行的第一个old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:N,Ms/old/new/g &lt;span style="color:#75715e">#替换第N行到第M行的所有old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:N,Ms/old/new/gc &lt;span style="color:#75715e">#替换第N行到第M行的所有old为new，且逐一询问是否删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:%s/old/new &lt;span style="color:#75715e">#替换所有行的第一个old为new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:%s/old/new/g &lt;span style="color:#75715e">#替换所有行的所有old为new&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文件排序交集并集差集">文件排序、交集、并集、差集&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#排序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort a.txt |uniq -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#一、交集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort a.txt b.txt | uniq -d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#二、并集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort a.txt b.txt | uniq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#三、差集 a.txt-b.txt:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort a.txt b.txt b.txt | uniq -u
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#差集 b.txt - a.txt:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort b.txt a.txt a.txt | uniq -u
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除重复行">删除重复行&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sort -k2n all.txt | uniq &amp;gt; real.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort -k2n all.txt | awk &lt;span style="color:#e6db74">&amp;#39;{if ($0!=line) print;line=$0}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort -k2n all.txt | sed &lt;span style="color:#e6db74">&amp;#39;$!N; /^\(.*\)\n\1$/!P; D&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除空格">删除空格&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat all.txt |sed s/&lt;span style="color:#f92672">[[&lt;/span>:space:&lt;span style="color:#f92672">]]&lt;/span>//g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="awk-去重">awk 去重&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;!($1 in a){a[$1];print $1}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort $1 | uniq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># awk结果使用逗号间隔拼接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>awk -F &lt;span style="color:#e6db74">&amp;#39;,&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> | xargs | tr &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;,&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="常用状态查看">常用状态查看&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 按CPU和内存倒序前n个进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ps -aux --sort -pcpu,+pmem | head -n &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 按进程名查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ps -f -C java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文件同步rsync">文件同步rsync&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rsync -zvrtopgl --progress --delete /fromDist/ root@s1:/toDist/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链接状态统计">链接状态统计&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>netstat -n | awk &lt;span style="color:#e6db74">&amp;#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># TCP连接状态详解 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># LISTEN: 服务器在侦听来自远方的TCP端口的连接请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SYN-SENT: 在发送连接请求后等待匹配的连接请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SYN_RECV: 一个连接请求已经到达，等待确认&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SYN-RECEIVED: 再收到和发送一个连接请求后等待对方对连接请求的确认&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ESTABLISHED: 代表一个打开的连接/正常数据传输状态/当前并发连接数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># FIN_WAIT1: 等待远程TCP连接中断请求，或先前的连接中断请求的确认/应用说它已经完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># FIN_WAIT2: 从远程TCP等待连接中断请求/另一边已同意释放&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CLOSE-WAIT: 等待从本地用户发来的连接中断请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CLOSING: 等待远程TCP对连接中断的确认/两边同时尝试关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># LAST-ACK: 等待原来的发向远程TCP的连接中断请求的确认/等待所有分组死掉&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># TIME-WAIT: 等待足够的时间以确保远程TCP接收到连接中断请求的确认/另一边已初始化一个释放&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ITMED_WAIT: 等待所有分组死掉&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CLOSED： 没有任何连接状态&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu内存系统信息查看">CPU/内存/系统信息查看&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep &lt;span style="color:#e6db74">&amp;#34;model name&amp;#34;&lt;/span> /proc/cpuinfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo | grep physical | uniq -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cpu位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $HOSTTYPE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 内存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep MemTotal /proc/meminfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># linux 版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /etc/redhat-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /etc/os-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /etc/lsb-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># linux 内核版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>uname -a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>uname -r
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="常用监控工具">常用监控工具&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 网络监控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iftop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># IO监控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iotop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 负载监控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>htop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>top
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="进程监控">进程监控&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pidstat -p &lt;span style="color:#ae81ff">843&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> -u -t
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -u：代表对 CPU 使用率的监控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 参数 1 3 代表每秒采样一次，一共三次&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -t：将监控级别细化到线程&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ssh相关">ssh相关&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 秘钥生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ssh-keygen -t rsa -b &lt;span style="color:#ae81ff">4096&lt;/span> -C &lt;span style="color:#e6db74">&amp;#34;your_hostname&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 免密登录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat ~/.ssh/id_rsa.pub | ssh root@ip &lt;span style="color:#e6db74">&amp;#34;cat &amp;gt;&amp;gt; .ssh/authorized_keys&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="firewalld防火墙使用">firewalld防火墙使用&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 禁止ping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --permanent --add-rich-rule&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;rule protocol value=icmp drop&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 允许192.168.1.0/24主机所有连接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --add-rich-rule&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;rule family=&amp;#34;ipv4&amp;#34; source address=&amp;#34;192.168.1.0&amp;#34; accept&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 禁止某IP访问&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --permanent --zone&lt;span style="color:#f92672">=&lt;/span>public --add-rich-rule&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;rule family=ipv4 source address=&amp;#39;123.56.247.76/24&amp;#39; reject&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 开放端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --zone&lt;span style="color:#f92672">=&lt;/span>public --permanent --add-port&lt;span style="color:#f92672">=&lt;/span>8080/tcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --reload
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文件统计">文件统计&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls -g |awk &lt;span style="color:#e6db74">&amp;#39;BEGIN{sum=0}{sum+=$4}END{print sum/(1024*1024*1024)}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="history格式及数量修改">history格式及数量修改&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export HISTSIZE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export HISTTIMEFORMAT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34; %Y-%m-%d %H:%M:%S - `who am i 2&amp;gt;/dev/null | awk &amp;#39;{print &lt;/span>$NF&lt;span style="color:#e6db74">}&amp;#39;|sed -e &amp;#39;s/[()]//g&amp;#39;` - `who -u am i |awk &amp;#39;{print &lt;/span>$1&lt;span style="color:#e6db74">}&amp;#39;` &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PROMPT_COMMAND&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;history 1 &amp;gt;&amp;gt; /var/log/.myhistory&amp;#34;&lt;/span> &lt;span style="color:#75715e">#将命令记录输出到文本中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch /var/log/.myhistory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod /var/log/.myhistory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>awk 分析 nginx 运行日志常用指令</title><link>https://blog.baicai.me/article/2021/awk-nginx-access_log/</link><pubDate>Sat, 05 Jun 2021 10:16:16 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/awk-nginx-access_log/</guid><description>&lt;p>awk 分析 nginx 运行日志常用指令&lt;/p>
&lt;p>1.独立IP&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> access.log | sort -r |uniq -c | wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.统计PV&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;{print $6}&amp;#39;&lt;/span> access.log | wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3.查询访问最频繁的URL&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;{print $7}&amp;#39;&lt;/span> access.log|sort | uniq -c |sort -n -k &lt;span style="color:#ae81ff">1&lt;/span> -r|more
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>4.查询访问最频繁的IP&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;{print $1}&amp;#39;&lt;/span> access.log|sort | uniq -c |sort -n -k &lt;span style="color:#ae81ff">1&lt;/span> -r|more
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>5.UV统计：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>awk &lt;span style="color:#e6db74">&amp;#39;{print $6}&amp;#39;&lt;/span> access.log | sort -r |uniq -c |wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>6.按小时统计&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat access.log |awk &lt;span style="color:#e6db74">&amp;#39;{print $4}&amp;#39;&lt;/span> | awk -F &lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1,$2}&amp;#39;&lt;/span>|uniq -c | awk &lt;span style="color:#e6db74">&amp;#39;{print $2&amp;#34; &amp;#34;$3&amp;#34; &amp;#34;$1}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>使用开源工具进行 Linux 内存取证</title><link>https://blog.baicai.me/article/2021/linux-memory-forensics/</link><pubDate>Wed, 26 May 2021 12:57:28 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux-memory-forensics/</guid><description>&lt;blockquote>
&lt;p>利用 Volatility 找出应用程序、网络连接、内核模块、文件等方面的情况。&lt;/p>&lt;/blockquote>
&lt;p>计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。&lt;/p>
&lt;p>内存取证是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。&lt;/p>
&lt;p>因此，这篇文章分为两部分：&lt;/p>
&lt;ul>
&lt;li>第一部分是处理获取物理内存并将其转储到一个文件中。&lt;/li>
&lt;li>第二部分使用 Volatility 从这个内存转储中读取并处理这些信息。&lt;/li>
&lt;/ul>
&lt;p>我在本教程中使用了以下测试系统，不过它可以在任何 Linux 发行版上工作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /etc/redhat-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Red Hat Enterprise Linux release 8.3 &lt;span style="color:#f92672">(&lt;/span>Ootpa&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ uname -r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4.18.0-240.el8.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>注意事项： 部分 1 涉及到编译和加载一个内核模块。不要担心：它并不像听起来那么困难。
一些指南：
按照以下的步骤。
不要在生产系统或你的主要计算机上尝试任何这些步骤。
始终使用测试的虚拟机（VM）来尝试，直到你熟悉使用这些工具并理解它们的工作原理为止。
&lt;/code>&lt;/pre>
&lt;h2 id="安装需要的包">安装需要的包&lt;/h2>
&lt;p>在开始之前安装必要的工具。如果你经常使用基于 Debian 的发行版，可以使用 apt-get 命令。这些包大多数提供了需要的内核信息和工具来编译代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ yum install kernel-headers kernel-devel gcc elfutils-libelf-devel make git libdwarf-tools python2-devel.x86_64-y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部分-1使用-lime-获取内存并将其转储到一个文件中">部分 1：使用 LiME 获取内存并将其转储到一个文件中&lt;/h2>
&lt;p>在开始分析内存之前，你需要一个内存转储供你使用。在实际的取证活动中，这可能来自一个被破坏或者被入侵的系统。这些信息通常会被收集和存储来分析入侵是如何发生的及其影响。由于你可能没有可用的内存转储，你可以获取你的测试 VM 的内存转储，并使用它来执行内存取证。&lt;/p>
&lt;p>Linux 内存提取器（LiME）是一个在 Linux 系统上获取内存很常用的工具。使用以下命令获得 LiME：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/504ensicsLabs/LiME.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd LiME/src/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deflate.c disk.c hash.c lime.h main.c Makefile Makefile.sample tcp.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="构建-lime-内核模块">构建 LiME 内核模块&lt;/h3>
&lt;p>在 src 文件夹下运行 make 命令。这会创建一个以 .ko 为扩展名的内核模块。理想情况下，在 make 结束时，lime.ko 文件会使用格式 &lt;code>lime-&amp;lt;your-kernel-version&amp;gt;.ko&lt;/code> 被重命名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make -C /lib/modules/4.18.0-240.el8.x86_64/build M&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/root/LiME/src&amp;#34;&lt;/span> modules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>: Entering directory &lt;span style="color:#e6db74">&amp;#39;/usr/src/kernels/4.18.0-240.el8.x86_64&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>: Leaving directory &lt;span style="color:#e6db74">&amp;#39;/usr/src/kernels/4.18.0-240.el8.x86_64&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strip --strip-unneeded lime.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv lime.ko lime-4.18.0-240.el8.x86_64.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l lime-4.18.0-240.el8.x86_64.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r--. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">25696&lt;/span> Apr &lt;span style="color:#ae81ff">17&lt;/span> 14:45 lime-4.18.0-240.el8.x86_64.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ file lime-4.18.0-240.el8.x86_64.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lime-4.18.0-240.el8.x86_64.ko: ELF 64-bit LSB relocatable, x86-64, version &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>SYSV&lt;span style="color:#f92672">)&lt;/span>, BuildID&lt;span style="color:#f92672">[&lt;/span>sha1&lt;span style="color:#f92672">]=&lt;/span>1d0b5cf932389000d960a7e6b57c428b8e46c9cf, not stripped
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加载lime-内核模块">加载LiME 内核模块&lt;/h3>
&lt;p>现在是时候加载内核模块来获取系统内存了。insmod 命令会帮助加载内核模块；模块一旦被加载，会在你的系统上读取主内存（RAM）并且将内存的内容转储到命令行所提供的 path 目录下的文件中。另一个重要的参数是 format；保持 lime 的格式，如下所示。在插入内核模块之后，使用 lsmod 命令验证它是否真的被加载。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ lsmod | grep lime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ insmod ./lime-4.18.0-240.el8.x86_64.ko &lt;span style="color:#e6db74">&amp;#34;path=../RHEL8.3_64bit.mem format=lime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ lsmod | grep lime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lime &lt;span style="color:#ae81ff">16384&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你应该看到给 path 命令的文件已经创建好了，而且文件大小与你系统的物理内存（RAM）大小相同（并不奇怪）。一旦你有了内存转储，你就可以使用 rmmod 命令删除该内核模块：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l ~/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r--. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4294544480&lt;/span> Apr &lt;span style="color:#ae81ff">17&lt;/span> 14:47 /root/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ du -sh ~/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4.0G /root/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ free -m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: &lt;span style="color:#ae81ff">3736&lt;/span> &lt;span style="color:#ae81ff">220&lt;/span> &lt;span style="color:#ae81ff">366&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">3149&lt;/span> &lt;span style="color:#ae81ff">3259&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: &lt;span style="color:#ae81ff">4059&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">4051&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rmmod lime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ lsmod | grep lime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="内存转储中是什么">内存转储中是什么？&lt;/h3>
&lt;p>这个内存转储文件只是原始数据，就像使用 file 命令可以看到的一样。你不可能通过手动去理解它；是的，在这里边有一些 ASCII 字符，但是你无法用编辑器打开这个文件并把它读出来。hexdump 的输出显示，最初的几个字节是 EmiL；这是因为你的请求格式在上面的命令行中是 lime：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ file ~/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/root/LiME/RHEL8.3_64bit.mem: data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ hexdump -C ~/LiME/RHEL8.3_64bit.mem | head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000000&lt;/span> &lt;span style="color:#ae81ff">45&lt;/span> 4d &lt;span style="color:#ae81ff">69&lt;/span> 4c &lt;span style="color:#ae81ff">01&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> |EMiL............|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000010&lt;/span> ff fb &lt;span style="color:#ae81ff">09&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> |................|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000020&lt;/span> b8 fe 4c cd &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#ae81ff">44&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> 2a 2a 2a 2a 2a |..L.!D.2 ..*****|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000030&lt;/span> 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a |****************|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000040&lt;/span> 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span> |************* . |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000050&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> |................|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000080&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">70&lt;/span> &lt;span style="color:#ae81ff">78&lt;/span> &lt;span style="color:#ae81ff">65&lt;/span> 6c |............pxel|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">00000090&lt;/span> &lt;span style="color:#ae81ff">69&lt;/span> 6e &lt;span style="color:#ae81ff">75&lt;/span> &lt;span style="color:#ae81ff">78&lt;/span> 2e &lt;span style="color:#ae81ff">30&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> |inux.0..........|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>000000a0 &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> |................|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部分-2获得-volatility-并使用它来分析你的内存转储">部分 2：获得 Volatility 并使用它来分析你的内存转储&lt;/h2>
&lt;p>现在你有了要分析的示例内存转储，使用下面的命令获取 Volatility 软件。Volatility 已经用 Python 3 重写了，但是本教程使用的是用 Python 2 写的原始的 Volatility 包。如果你想用 Volatility 3 进行实验，可以从合适的 Git 仓库下载它，并在以下命令中使用 Python 3 而不是 Python 2：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/volatilityfoundation/volatility.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd volatility/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AUTHORS.txt contrib LEGAL.txt Makefile PKG-INFO pyinstaller.spec resources tools vol.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CHANGELOG.txt CREDITS.txt LICENSE.txt MANIFEST.in pyinstaller README.txt setup.py volatility
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Volatility 使用两个 Python 库来实现某些功能，所以使用以下命令来安装它们。否则，在你运行 Volatility 工具时，你可能看到一些导入错误；你可以忽略它们，除非你正在运行的插件需要这些库；这种情况下，工具将会报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ pip2 install pycrypto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip2 install distorm3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="列出-volatility-的-linux-配置文件">列出 Volatility 的 Linux 配置文件&lt;/h3>
&lt;p>你将要运行的第一个 Volatility 命令列出了可用的 Linux 配置文件，运行 Volatility 命令的主要入口点是 vol.py 脚本。使用 Python 2 解释器调用它并提供 &amp;ndash;info 选项。为了缩小输出，查找以 Linux 开头的字符串。正如你所看到的，并没有很多 Linux 配置文件被列出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py --info | grep ^Linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LinuxAMD64PagedMemory - Linux-specific AMD 64-bit address space.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="构建你自己的-linux-配置文件">构建你自己的 Linux 配置文件&lt;/h3>
&lt;p>Linux 发行版是多种多样的，并且是为不同架构而构建的。这就是为什么配置文件是必要的 —— Volatility 在提取信息前必须知道内存转储是从哪个系统和架构获得的。有一些 Volatility 命令可以找到这些信息；但是这个方法很费时。为了加快速度，可以使用以下命令构建一个自定义的 Linux 配置文件：&lt;/p>
&lt;p>移动到 Volatility 仓库的 tools/linux目录下，运行 make 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cd tools/linux/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/root/volatility/tools/linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kcore Makefile Makefile.enterprise module.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make -C //lib/modules/4.18.0-240.el8.x86_64/build CONFIG_DEBUG_INFO&lt;span style="color:#f92672">=&lt;/span>y M&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/root/volatility/tools/linux&amp;#34;&lt;/span> modules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>: Entering directory &lt;span style="color:#e6db74">&amp;#39;/usr/src/kernels/4.18.0-240.el8.x86_64&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>: Leaving directory &lt;span style="color:#e6db74">&amp;#39;/usr/src/kernels/4.18.0-240.el8.x86_64&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你应该看到一个新的 module.dwarf 文件。你也需要 /boot 目录下的 System.map 文件，因为它包含了所有与当前运行的内核相关的符号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kcore Makefile Makefile.enterprise module.c module.dwarf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l module.dwarf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r--. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">3987904&lt;/span> Apr &lt;span style="color:#ae81ff">17&lt;/span> 15:17 module.dwarf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l /boot/System.map-4.18.0-240.el8.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-------. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">4032815&lt;/span> Sep &lt;span style="color:#ae81ff">23&lt;/span> &lt;span style="color:#ae81ff">2020&lt;/span> /boot/System.map-4.18.0-240.el8.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要创建一个自定义配置文件，移动回到 Volatility 目录并且运行下面的命令。第一个参数提供了一个自定义 .zip 文件，文件名是你自己命名的。我经常使用操作系统和内核版本来命名。下一个参数是前边创建的 module.dwarf 文件，最后一个参数是 /boot 目录下的 System.map 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd volatility/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ zip volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip tools/linux/module.dwarf /boot/System.map-4.18.0-240.el8.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adding: tools/linux/module.dwarf &lt;span style="color:#f92672">(&lt;/span>deflated 91%&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adding: boot/System.map-4.18.0-240.el8.x86_64 &lt;span style="color:#f92672">(&lt;/span>deflated 79%&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在自定义配置文件就准备好了，所以在前边给出的位置检查一下 .zip 文件是否被创建好。如果你想知道 Volatility 是否检测到这个自定义配置文件，再一次运行 &amp;ndash;info 命令。现在，你应该可以在下边的列出的内容中看到新的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ls -l volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r--. &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">1190360&lt;/span> Apr &lt;span style="color:#ae81ff">17&lt;/span> 15:20 volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ python2 vol.py --info | grep Redhat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LinuxRedhat8_3_4_18_0-240x64 - A Profile &lt;span style="color:#66d9ef">for&lt;/span> Linux Redhat8.3_4.18.0-240 x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始使用-volatility">开始使用 Volatility&lt;/h3>
&lt;p>现在你已经准备好去做一些真正的内存取证了。记住，Volatility 是由自定义的插件组成的，你可以针对内存转储来获得信息。命令的通用格式是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>python2 vol.py -f &amp;lt;memory-dump-file-taken-by-Lime&amp;gt; &amp;lt;plugin-name&amp;gt; --profile&lt;span style="color:#f92672">=&lt;/span>&amp;lt;name-of-our-custom-profile&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这些信息，运行 linux_banner 插件来看看你是否可从内存转储中识别正确的发行版信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_banner --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linux version 4.18.0-240.el8.x86_64 &lt;span style="color:#f92672">([&lt;/span>mockbuild@vm09.test.com&lt;span style="color:#f92672">][&lt;/span>4&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">(&lt;/span>gcc version 8.3.1 &lt;span style="color:#ae81ff">20191121&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Red Hat 8.3.1-5&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>GCC&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#75715e">#1 SMP Wed Sep 23 05:13:10 EDT 2020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="找到-linux-插件">找到 Linux 插件&lt;/h3>
&lt;p>到现在都很顺利，所以现在你可能对如何找到所有 Linux 插件的名字比较好奇。有一个简单的技巧：运行 &amp;ndash;info 命令并抓取 linux_ 字符串。有各种各样的插件可用于不同的用途。这里列出一部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py --info | grep linux_
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_apihooks - Checks &lt;span style="color:#66d9ef">for&lt;/span> userland apihooks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_arp - Print the ARP table
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_aslr_shift - Automatically detect the Linux ASLR shift
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_banner - Prints the Linux banner information
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_vma_cache - Gather VMAs from the vm_area_struct cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_volshell - Shell in the memory image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>linux_yarascan - A shell in the Linux memory image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 linux_psaux 插件检查内存转储时系统上正在运行哪些进程。注意列表中的最后一个命令：它是你在转储之前运行的 insmod 命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_psaux --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pid Uid Gid Arguments
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /usr/lib/systemd/systemd --switched-root --system --deserialize &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>kthreadd&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>rcu_gp&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>rcu_par_gp&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">861&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /usr/libexec/platform-python -Es /usr/sbin/tuned -l -P
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">869&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /usr/bin/rhsmcertd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">875&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /usr/libexec/sssd/sssd_be --domain implicit_files --uid &lt;span style="color:#ae81ff">0&lt;/span> --gid &lt;span style="color:#ae81ff">0&lt;/span> --logger&lt;span style="color:#f92672">=&lt;/span>files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">878&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /usr/libexec/sssd/sssd_nss --uid &lt;span style="color:#ae81ff">0&lt;/span> --gid &lt;span style="color:#ae81ff">0&lt;/span> --logger&lt;span style="color:#f92672">=&lt;/span>files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">11064&lt;/span> &lt;span style="color:#ae81ff">89&lt;/span> &lt;span style="color:#ae81ff">89&lt;/span> qmgr -l -t unix -u
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">227148&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>kworker/0:0&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">227298&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> -bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">227374&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>kworker/u2:1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">227375&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>kworker/0:2&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">227884&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">[&lt;/span>kworker/0:3&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">228573&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> insmod ./lime-4.18.0-240.el8.x86_64.ko path&lt;span style="color:#f92672">=&lt;/span>../RHEL8.3_64bit.mem format&lt;span style="color:#f92672">=&lt;/span>lime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">228576&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想要知道系统的网络状态吗？运行 linux_netstat 插件来找到在内存转储期间网络连接的状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_netstat --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UNIX &lt;span style="color:#ae81ff">18113&lt;/span> systemd/1 /run/systemd/private
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UNIX &lt;span style="color:#ae81ff">11411&lt;/span> systemd/1 /run/systemd/notify
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UNIX &lt;span style="color:#ae81ff">11413&lt;/span> systemd/1 /run/systemd/cgroups-agent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UNIX &lt;span style="color:#ae81ff">11415&lt;/span> systemd/1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UNIX &lt;span style="color:#ae81ff">11416&lt;/span> systemd/1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，使用 linux_mount 插件来看在内存转储期间哪些文件系统被挂载：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_mount --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cgroup /sys/fs/cgroup/pids cgroup rw,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/mapper/rhel_kvm--03--guest11-root / xfs rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs /dev/shm tmpfs rw,nosuid,nodev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>selinuxfs /sys/fs/selinux selinuxfs rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bpf /sys/fs/bpf bpf rw,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cgroup /sys/fs/cgroup/memory cgroup ro,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cgroup /sys/fs/cgroup/cpuset cgroup rw,relatime,nosuid,nodev,noexec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mqueue /dev/mqueue mqueue rw,relatime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好奇哪些内核模块被加载了吗？Volatility 也为这个提供了一个插件 linux_lsmod：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_lsmod --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc0535040 lime &lt;span style="color:#ae81ff">20480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc0530540 binfmt_misc &lt;span style="color:#ae81ff">20480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc05e8040 sunrpc &lt;span style="color:#ae81ff">479232&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc04f9540 nfit &lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc0266280 dm_mirror &lt;span style="color:#ae81ff">28672&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc025e040 dm_region_hash &lt;span style="color:#ae81ff">20480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc0258180 dm_log &lt;span style="color:#ae81ff">20480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ffffffffc024bbc0 dm_mod &lt;span style="color:#ae81ff">151552&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想知道哪些文件被哪些进程打开了吗？使用 linux_bash 插件可以列出这些信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_bash --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64 -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pid Name Command Time Command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-------- -------------------- ------------------------------ -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 lsmod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 rm -f .log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 ls -l /etc/zzz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 cat ~/.vimrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 cat /proc/817/cwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 ls -l /proc/817/cwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227221&lt;/span> bash 2021-04-17 18:38:24 UTC+0000 ls /proc/817/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 gcc prt.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 vim prt.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 gcc prt.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">227298&lt;/span> bash 2021-04-17 18:40:30 UTC+0000 ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想知道哪些文件被哪些进程打开了吗？使用 linux_lsof 插件可以列出这些信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_lsof --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Offset Name Pid FD Path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>------------------ ------------------------------ -------- -------- ----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> /dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> /dev/null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> /dev/urandom
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> socket:&lt;span style="color:#f92672">[&lt;/span>83565&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> /var/log/messages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> anon_inode:&lt;span style="color:#f92672">[&lt;/span>9063&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c83fb1e9f40 rsyslogd &lt;span style="color:#ae81ff">71194&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> /var/log/secure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c8365761f40 insmod &lt;span style="color:#ae81ff">228573&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> /dev/pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c8365761f40 insmod &lt;span style="color:#ae81ff">228573&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> /dev/pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c8365761f40 insmod &lt;span style="color:#ae81ff">228573&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> /dev/pts/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xffff9c8365761f40 insmod &lt;span style="color:#ae81ff">228573&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> /root/LiME/src/lime-4.18.0-240.el8.x86_64.ko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问-linux-插件脚本位置">访问 Linux 插件脚本位置&lt;/h3>
&lt;p>通过读取内存转储和处理这些信息，你可以获得更多的信息。如果你会 Python，并且好奇这些信息是如何被处理的，可以到存储所有插件的目录，选择一个你感兴趣的，并看看 Volatility 是如何获得这些信息的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls volatility/plugins/linux/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apihooks.py common.py kernel_opened_files.py malfind.py psaux.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apihooks.pyc common.pyc kernel_opened_files.pyc malfind.pyc psaux.pyc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>arp.py cpuinfo.py keyboard_notifiers.py mount_cache.py psenv.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>arp.pyc cpuinfo.pyc keyboard_notifiers.pyc mount_cache.pyc psenv.pyc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aslr_shift.py dentry_cache.py ld_env.py mount.py pslist_cache.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aslr_shift.pyc dentry_cache.pyc ld_env.pyc mount.pyc pslist_cache.pyc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&amp;lt; 删节 &amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check_syscall_arm.py __init__.py lsmod.py proc_maps.py tty_check.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check_syscall_arm.pyc __init__.pyc lsmod.pyc proc_maps.pyc tty_check.pyc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check_syscall.py iomem.py lsof.py proc_maps_rb.py vma_cache.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check_syscall.pyc iomem.pyc lsof.pyc proc_maps_rb.pyc vma_cache.pyc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我喜欢 Volatility 的理由是他提供了许多安全插件。这些信息很难手动获取：&lt;/p>
&lt;pre>&lt;code>linux_hidden_modules - Carves memory to find hidden kernel modules
linux_malfind - Looks for suspicious process mappings
linux_truecrypt_passphrase - Recovers cached Truecrypt passphrases
&lt;/code>&lt;/pre>
&lt;p>Volatility 也允许你在内存转储中打开一个 shell，所以你可以运行 shell 命令来代替上面所有命令，并获得相同的信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_volshell --profile&lt;span style="color:#f92672">=&lt;/span>LinuxRedhat8_3_4_18_0-240x64 -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Volatility Foundation Volatility Framework 2.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current context: process systemd, pid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> DTB&lt;span style="color:#f92672">=&lt;/span>0x1042dc000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Welcome to volshell! Current memory image is:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>file:///root/LiME/RHEL8.3_64bit.mem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>To get help, type &lt;span style="color:#e6db74">&amp;#39;hh()&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; sc&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Current context: process systemd, pid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> DTB&lt;span style="color:#f92672">=&lt;/span>0x1042dc000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="接下来的步骤">接下来的步骤&lt;/h2>
&lt;p>内存转储是了解 Linux 内部情况的好方法。试一试 Volatility 的所有插件，并详细研究它们的输出。然后思考这些信息如何能够帮助你识别入侵或安全问题。深入了解这些插件的工作原理，甚至尝试改进它们。如果你没有找到你想做的事情的插件，那就写一个并提交给 Volatility，这样其他人也可以使用它。&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>使用开源工具进行 Linux 内存取证 &lt;a href="https://linux.cn/article-13425-1.html">[1]&lt;/a>&lt;/p>
&lt;p>Perform Linux memory forensics with this open source tool &lt;a href="https://opensource.com/article/21/4/linux-memory-forensics">[2]&lt;/a>&lt;/p></description></item><item><title>使用 sed 命令进行复制、剪切和粘贴</title><link>https://blog.baicai.me/article/2021/linux_sed/</link><pubDate>Mon, 24 May 2021 00:39:20 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux_sed/</guid><description>&lt;blockquote>
&lt;p>很少有 Unix 命令像 sed、grep 和 awk 一样出名，它们经常组合在一起，可能是因为它们具有奇怪的名称和强大的文本解析能力。它们还在一些语法和逻辑上有相似之处。虽然它们都能用于文本解析，但都有其特殊性。本文研究 sed 命令，它是一个 流编辑器。&lt;/p>&lt;/blockquote>
&lt;h3 id="安装-sed">安装 sed&lt;/h3>
&lt;p>如果你使用的是 Linux、BSD 或 macOS，那么它们已经安装了 GNU 的或 BSD 的 sed。这些是原始 sed 命令的独特重新实现。虽然它们很相似，但也有一些细微的差别。本文已经在 Linux 和 NetBSD 版本上进行了测试，所以你可以使用你的计算机上找到的任何 sed，但是对于 BSD sed，你必须使用短选项（例如 -n 而不是 &amp;ndash;quiet）。&lt;/p>
&lt;p>GNU sed 通常被认为是功能最丰富的 sed，因此无论你是否运行 Linux，你可能都想要尝试一下。如果在 Ports 树中找不到 GNU sed（在非 Linux 系统上通常称为 gsed），你可以从 GNU 网站 下载源代码。 安装 GNU sed 的好处是，你可以使用它的额外功能，但是如果需要可移植性，还可以限制它以遵守 sed 的 POSIX 规范。&lt;/p>
&lt;p>MacOS 用户可以在 MacPorts 或 Homebrew 上找到 GNU sed。&lt;/p>
&lt;p>在 Windows 上，你可以通过 Chocolatey 来 安装 GNU sed。&lt;/p>
&lt;h3 id="了解模式空间和保留空间">了解模式空间和保留空间&lt;/h3>
&lt;p>sed 一次只能处理一行。因为它没有可视化模式，所以会创建一个 模式空间，这是一个内存空间，其中包含来自输入流的当前行（删除了尾部的任何换行符）。填充模式空间后，sed 将执行你的指令。当命令执行完时，sed 将模式空间中的内容打印到输出流，默认是 标准输出，但是可以将输出重定向到文件，甚至使用 &lt;code>--in-place=.bak&lt;/code> 选项重定向到同一文件。&lt;/p>
&lt;p>然后，循环从下一个输入行再次开始。&lt;/p>
&lt;p>为了在遍历文件时提供一点灵活性，sed 还提供了保留空间（有时也称为 保留缓冲区），即 sed 内存中为临时数据存储保留的空间。你可以将保留空间当作剪贴板，实际上，这正是本文所演示的内容：如何使用 sed 复制/剪切和粘贴。&lt;/p>
&lt;p>首先，创建一个示例文本文件，其内容如下：&lt;/p>
&lt;pre>&lt;code>Line one
Line three
Line two
&lt;/code>&lt;/pre>
&lt;h3 id="复制数据到保留空间">复制数据到保留空间&lt;/h3>
&lt;p>要将内容放置在 sed 的保留空间，使用 &lt;code>h&lt;/code> 或 &lt;code>H&lt;/code> 命令。小写的 &lt;code>h&lt;/code> 告诉 sed 覆盖保留空间中的当前内容，而大写的 &lt;code>H&lt;/code> 告诉 sed 将数据追加到保留空间中已经存在的内容之后。&lt;/p>
&lt;p>单独使用，什么都看不到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed --quiet -e &lt;span style="color:#e6db74">&amp;#39;/three/ h&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>--quiet&lt;/code>（缩写为 &lt;code>-n&lt;/code>）选项禁止显示所有输出，但 sed 执行了我的搜索需求。在这种情况下，sed 选择包含字符串 three 的任何行，并将其复制到保留空间。我没有告诉 sed 打印任何东西，所以没有输出。&lt;/p>
&lt;h3 id="从保留空间复制数据">从保留空间复制数据&lt;/h3>
&lt;p>要了解保留空间，你可以从保留空间复制内容，然后使用 g 命令将其放入模式空间，观察会发生什么：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed -n -e &lt;span style="color:#e6db74">&amp;#39;/three/h&amp;#39;&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;g;p&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个空白行是因为当 sed 第一次复制内容到模式空间时，保留空间为空。&lt;/p>
&lt;p>接下来的两行包含 &lt;code>Line three&lt;/code> 是因为这是从第二行开始的保留空间。&lt;/p>
&lt;p>该命令使用两个唯一的脚本（-e）纯粹是为了帮助提高可读性和组织性。将步骤划分为单独的脚本可能会很有用，但是从技术上讲，以下命令与一个脚本语句一样有效：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed -n -e &lt;span style="color:#e6db74">&amp;#39;/three/h ; g ; p&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="将数据追加到模式空间">将数据追加到模式空间&lt;/h3>
&lt;p>&lt;code>G&lt;/code> 命令会将一个换行符和保留空间的内容添加到模式空间。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed -n -e &lt;span style="color:#e6db74">&amp;#39;/three/h&amp;#39;&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;G;p&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此输出的前两行同时包含模式空间（&lt;code>Line one&lt;/code>）的内容和空的保留空间。接下来的两行与搜索文本（&lt;code>three&lt;/code>）匹配，因此它既包含模式空间又包含保留空间。第三行的保留空间没有变化，因此在模式空间（&lt;code>Line two&lt;/code>）的末尾是保留空间（仍然是 &lt;code>Line three&lt;/code>）。&lt;/p>
&lt;h3 id="用-sed-剪切和粘贴">用 sed 剪切和粘贴&lt;/h3>
&lt;p>现在你知道了如何将字符串从模式空间转到保留空间并再次返回，你可以设计一个 sed 脚本来复制、删除，然后在文档中粘贴一行。例如，将示例文件的 Line three 挪至第三行，sed 可以解决这个问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed -n -e &lt;span style="color:#e6db74">&amp;#39;/three/ h&amp;#39;&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;/three/ d&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-e &lt;span style="color:#e6db74">&amp;#39;/two/ G;p&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一个脚本找到包含字符串 &lt;code>three&lt;/code> 的行，并将其从模式空间复制到保留空间，替换当前保留空间中的任何内容。&lt;/li>
&lt;li>第二个脚本删除包含字符串 &lt;code>three&lt;/code> 的任何行。这样就完成了与文字处理器或文本编辑器中的 剪切 动作等效的功能。&lt;/li>
&lt;li>最后一个脚本找到包含字符串 &lt;code>two&lt;/code> 的行，并将保留空间的内容_追加_到模式空间，然后打印模式空间。&lt;/li>
&lt;/ul>
&lt;p>任务完成。&lt;/p>
&lt;h3 id="使用-sed-编写脚本">使用 sed 编写脚本&lt;/h3>
&lt;p>再说一次，使用单独的脚本语句纯粹是为了视觉和心理上的简单。剪切和粘贴命令作为一个脚本同样有效：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sed -n -e &lt;span style="color:#e6db74">&amp;#39;/three/ h ; /three/ d ; /two/ G ; p&amp;#39;&lt;/span> example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它甚至可以写在一个专门的脚本文件中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/usr/bin/sed -nf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/three/h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/three/d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/two/ G
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要运行该脚本，将其加入可执行权限，然后用示例文件尝试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ chmod +x myscript.sed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./myscript.sed example.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Line three
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，你需要解析的文本越可预测，则使用 sed 解决问题越容易。发明 sed 操作（例如复制和粘贴）的“配方”通常是不切实际的，因为触发操作的条件可能因文件而异。但是，你对 sed 命令的使用越熟练，就越容易根据需要解析的输入来设计复杂的动作。&lt;/p>
&lt;p>重要的事情是识别不同的操作，了解 sed 何时移至下一行，并预测模式和保留空间包含的内容。&lt;/p>
&lt;p>sed 很复杂。虽然它只有十几个命令，但它灵活的语法和原生功能意味着它充满了无限的潜力。&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>How to use the Linux sed command &lt;a href="https://opensource.com/article/21/3/sed-cheat-sheet">[1]&lt;/a>&lt;/p>
&lt;p>使用 sed 命令进行复制、剪切和粘贴 &lt;a href="https://linux.cn/article-13417-1.html">[2]&lt;/a>&lt;/p></description></item><item><title>Linux/Mac 使用 GNU Screen 的小技巧</title><link>https://blog.baicai.me/article/2021/linux_screen/</link><pubDate>Thu, 13 May 2021 12:50:05 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux_screen/</guid><description>&lt;blockquote>
&lt;p>学习基本的 GNU Screen 终端复用技术，然后下载我们的终端命令备忘录，以便你能够熟悉常用的快捷方式。&lt;/p>&lt;/blockquote>
&lt;p>对于一般用户而言，命令行终端窗口可能是令人困惑和神秘的。但随着你对 Linux 终端的进一步了解，你很快就会意识到它的高效和强大。不过，也不需要很长时间，你就会想让终端变得更加高效，除了将更多的终端放到你的终端，还有什么高好的方法能够提升你的终端效率呢？&lt;/p>
&lt;h3 id="终端复用">终端复用&lt;/h3>
&lt;p>终端的许多优点之一是它是一个集中控制的界面。它是一个能让你访问数百个应用程序的窗口，而你与每一个应用程序进行交互所需要的只是一个键盘。但是，现代计算机几乎总是有多余的处理能力，而且现代计算机专家喜欢多任务处理，导致一个窗口处理数百个应用程序的能力是相当有限的。&lt;/p>
&lt;p>解决这一问题的常见答案是终端复用：即将虚拟终端叠放在一起，然后在它们之间移动的能力。通过终端复用器，你保持了集中控制，但是当你进行多任务时，你能够进行终端切换。更好的是，你能够在终端中拆分屏幕，使得在同一时间显示多个屏幕窗口。&lt;/p>
&lt;h3 id="选择合适的复用器">选择合适的复用器&lt;/h3>
&lt;p>一些终端提供类似的功能，有标签式界面和分割式视图，但也有细微的差别。首先，这些终端的功能依赖于图形化的桌面环境。其次，许多图形化的终端功能需要鼠标交互或使用不方便的键盘快捷键。终端复用器的功能在文本控制台上和在图形桌面上一样好用，而且键位绑定是针对常见的终端序列设计的，很方便。&lt;/p>
&lt;p>现有两种流行的复用器：tmux 和 GNU Screen。尽管你与它们互动的方式略有不同，但它们做同样的事情，而且大多具有相同的功能。这篇文章是 GNU Screen 的入门指南。关于 tmux 的相关介绍，请阅读 Kevin Sonney 的 tmux 介绍。&lt;/p>
&lt;h3 id="使用-gnu-screen">使用 GNU Screen&lt;/h3>
&lt;p>GNU Screen 的基本用法很简单，通过 &lt;code>screen&lt;/code> 命令启动，你将进入 Screen 会话的第 0 个窗口。在你决定需要一个新的终端提示符前，你可能很难注意到有什么变化。&lt;/p>
&lt;p>当一个终端窗口被某项活动占用（比如，你启动了文本编辑器 &lt;strong>Vim&lt;/strong> 或 &lt;strong>Jove&lt;/strong> 或者你在处理音视频，或运行批处理任务），你可以新建一个窗口。要打开一个新的窗口，按 &lt;code>Ctrl+A&lt;/code>，释放，然后按 &lt;code>c&lt;/code>。这将在你现有窗口的基础上创建一个新的窗口。&lt;/p>
&lt;p>你会知道当前你是在一个新的窗口中，因为你的终端除了默认的提示符外，似乎没有任何东西。当然，你的另一个终端仍然存在，它只是躲在新窗口的后面。要遍历打开的窗口，按 &lt;code>Ctrl+A&lt;/code>，释放，然后按 &lt;code>n&lt;/code>（表示下一个）或按 &lt;code>p&lt;/code>（表示上一个）。在只打开两个窗口的情况下， &lt;code>n&lt;/code> 和 &lt;code>p&lt;/code> 的功能是一样的，但你可以随时打开更多的窗口（&lt;code>Ctrl+A&lt;/code>，然后 &lt;code>c&lt;/code> ），并在它们之间切换。&lt;/p>
&lt;h3 id="分屏">分屏&lt;/h3>
&lt;p>GNU Screen 的默认行为更像移动设备的屏幕，而不是桌面：你一次只能看到一个窗口。如果你因为喜欢多任务而使用 GNU Screen ，那么只关注一个窗口可能看起来是一种退步。幸运的是，GNU Screen 可以让你把终端分成窗口中的窗口。&lt;/p>
&lt;p>要创建一个水平分割窗口，按 &lt;code>Ctrl+A&lt;/code>，然后按 &lt;code>s&lt;/code> 。这将把一个窗口置于另一个窗口之上，就像窗格一样。然而，在你告诉它要显示什么之前，分割的空间是没有用途的。因此，在创建一个分割窗后，你可以用 &lt;code>Ctrl+A&lt;/code> ，然后用 &lt;code>Tab&lt;/code> 移动到分割窗中。一旦进入，使用 &lt;code>Ctrl+A&lt;/code> 然后 &lt;code>n&lt;/code> 浏览所有可用的窗口，直到你想显示的内容出现在分割窗格中。&lt;/p>
&lt;p>你也可以按 &lt;code>Ctrl+A&lt;/code> 然后按 &lt;code>|&lt;/code> （这是一个管道字符，在大多数键盘上通过按下 &lt;code>shift&lt;/code> 键加上 &lt;code>\&lt;/code>）创建垂直分割窗口。&lt;/p>
&lt;h3 id="自定义-gnu-screen">自定义 GNU Screen&lt;/h3>
&lt;p>GNU Screen 使用基于 &lt;code>Ctrl+A&lt;/code> 的快捷键。根据你的习惯，这可能会让你感觉非常自然，也可能非常不方便，因为你可能会用 &lt;code>Ctrl+A&lt;/code> 来移动到一行的开头。无论怎样，GNU Screen 允许通过 &lt;code>.screenrc&lt;/code> 配置文件进行各种定制。你可以用这个来改变触发键的绑定（称为 “转义” 键绑定）。&lt;/p>
&lt;p>&lt;code>escape ^jJ&lt;/code>&lt;/p>
&lt;p>你还可以添加一个状态行，以帮助你在 Screen 会话中保持自己不迷失。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># status bar, with current window highlighted&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hardstatus alwayslastline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hardstatus string &lt;span style="color:#e6db74">&amp;#39;%{= kG}[%{G}%H%? %1`%?%{g}][%= %{= kw}%-w%{+b yk} %n*%t%?(%u)%? %{-}%+w %=%{g}][%{B}%m/%d %{W}%C%A%{g}]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># enable 256 colors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attrcolor b &lt;span style="color:#e6db74">&amp;#34;.I&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> termcapinfo xterm &lt;span style="color:#e6db74">&amp;#39;Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defbce on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在有多个窗口打开的会话中，有一个时刻提醒哪些窗口具有焦点活动，哪些窗口有后台活动的提醒器特别有用。它类似一种终端的任务管理器。&lt;/p>
&lt;h3 id="备忘单">备忘单&lt;/h3>
&lt;p>当你学习 GNU Screen 的使用方法时，需要记住很多新的键盘命令。有些命令你马上就能记住，但那些你不常使用的命令可能就很难记住了。你可以按 &lt;code>Ctrl+A&lt;/code> 然后再按 &lt;code>?&lt;/code> 来访问 GNU Screen 的帮助界面。&lt;/p>
&lt;p>学习 GNU Screen 是提高你使用你最喜欢的 终端模拟器 的效率和敏捷性的一个好方法。请试一试吧！&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>Linux tips for using GNU Screen &lt;a href="https://opensource.com/article/21/4/gnu-screen-cheat-sheet">[1]&lt;/a>&lt;/p>
&lt;p>使用 GNU Screen 的小技巧 &lt;a href="https://linux.cn/article-13387-1.html">[2]&lt;/a>&lt;/p></description></item><item><title>使用 cron 调度自动化任务</title><link>https://blog.baicai.me/article/2021/linux_cron/</link><pubDate>Wed, 12 May 2021 18:59:21 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/linux_cron/</guid><description>&lt;blockquote>
&lt;p>cron 是一个调度守护进程，它以指定的时间间隔执行任务，这些任务称为 corn 作业，主要用于自动执行系统维护或管理任务。例如，你可以设置一个 cron 作业来自动执行重复的任务，比如备份数据库或数据，使用最新的安全补丁更新系统，检查磁盘空间使用情况，发送电子邮件等等。 cron 作业可以按分钟、小时、日、月、星期或它们的任意组合运行。&lt;/p>&lt;/blockquote>
&lt;h1 id="cron-的一些优点">cron 的一些优点&lt;/h1>
&lt;p>以下是使用 cron 作业的一些优点：&lt;/p>
&lt;pre>&lt;code>你可以更好地控制作业的运行时间。例如，你可以精确到分钟、小时、天等。
它消除了为循环任务逻辑而去写代码的需要，当你不再需要执行任务时，可以直接关闭它。
作业在不执行时不会占用内存，因此你可以节省内存分配。
如果一个作业执行失败并由于某种原因退出，它将在适当的时间再次运行。
&lt;/code>&lt;/pre>
&lt;h1 id="安装-cron-守护进程">安装 cron 守护进程&lt;/h1>
&lt;p>幸运的是，Fedora Linux 预先配置了运行重要的系统任务来保持系统更新，有几个实用程序可以运行任务例如 cron、anacron、at 和 batch 。本文只关注 cron 实用程序的安装。cron 和 cronie 包一起安装，cronie 包也提供 cron 服务。&lt;/p>
&lt;h3 id="要确定软件包是否已经存在使用-rpm-命令">要确定软件包是否已经存在，使用 rpm 命令：&lt;/h3>
&lt;p>&lt;code>$ rpm -q cronie Cronie-1.5.2-4.el8.x86_64&lt;/code>&lt;/p>
&lt;p>如果安装了 cronie ，它将返回 cronie 包的全名。如果你的系统中没有安装，则会显示未安装。&lt;/p>
&lt;h3 id="使用以下命令安装">使用以下命令安装：&lt;/h3>
&lt;p>&lt;code>$ dnf install cronie&lt;/code>&lt;/p>
&lt;h3 id="运行-cron-守护进程">运行 cron 守护进程&lt;/h3>
&lt;p>cron 作业由 crond 服务来执行，它会读取配置文件中的信息。在将作业添加到配置文件之前，必须启动 crond 服务，或者安装它。什么是 crond 呢？crond 是 cron 守护程序的简称。要确定 crond 服务是否正在运行，输入以下命令：&lt;/p>
&lt;p>&lt;code>$ systemctl status crond.service&lt;/code>&lt;/p>
&lt;pre>&lt;code>● crond.service - Command Scheduler
Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor pre&amp;gt;
Active: active (running) since Sat 2021-03-20 14:12:35 PDT; 1 day 21h ago
Main PID: 1110 (crond)
&lt;/code>&lt;/pre>
&lt;p>如果你没有看到类似的内容 Active: active (running) since…，你需要启动 crond 守护进程。要在当前会话中运行 crond 服务，输入以下命令：&lt;/p>
&lt;p>&lt;code>$ systemctl run crond.service&lt;/code>&lt;/p>
&lt;p>将其配置为开机自启动，输入以下命令：&lt;/p>
&lt;p>&lt;code>$ systemctl enable crond.service&lt;/code>&lt;/p>
&lt;p>如果出于某种原因，你希望停止 crond 服务，按以下方式使用 stop 命令：&lt;/p>
&lt;p>&lt;code>$ systemctl stop crond.service&lt;/code>&lt;/p>
&lt;p>要重新启动它，只需使用 restart 命令：&lt;/p>
&lt;p>&lt;code>$ systemctl restart crond.service&lt;/code>&lt;/p>
&lt;h1 id="定义一个-cron-作业">定义一个 cron 作业&lt;/h1>
&lt;h3 id="cron-配置">cron 配置&lt;/h3>
&lt;p>以下是一个 cron 作业的配置细节示例。它定义了一个简单的 cron 作业，将 git master 分支的最新更改拉取到克隆的仓库中：&lt;/p>
&lt;p>&lt;code>*/59 * * * * username cd /home/username/project/design &amp;amp;&amp;amp; git pull origin master&lt;/code>&lt;/p>
&lt;p>主要有两部分：&lt;/p>
&lt;pre>&lt;code>第一部分是 */59 * * * *。这表明计时器设置为第 59 分钟执行一次。
该行的其余部分是命令，因为它将从命令行运行。 在此示例中，命令本身包含三个部分：
作业将以用户 username 的身份运行
它将切换到目录 /home/username/project/design
运行 git 命令拉取 master 分支中的最新更改
&lt;/code>&lt;/pre>
&lt;h3 id="时间语法">时间语法&lt;/h3>
&lt;p>如上所述，时间信息是 cron 作业字符串的第一部分，如上所属。它决定了 cron 作业运行的频率和时间。它按以下顺序包括 5 个部分：&lt;/p>
&lt;ul>
&lt;li>分钟&lt;/li>
&lt;li>小时&lt;/li>
&lt;li>一个月中的某天&lt;/li>
&lt;li>月份&lt;/li>
&lt;li>一周中的某天&lt;/li>
&lt;/ul>
&lt;p>下面是一种更图形化的方式来解释语法：&lt;/p>
&lt;pre>&lt;code>.--------------- 分钟 (0 - 59)
| .------------- 小时 (0 - 23)
| | .---------- 一月中的某天 (1 - 31)
| | | .------- 月份 (1 - 12) 或 jan、feb、mar、apr …
| | | | .---- 一周中的某天 (0-6) (周日=0 或 7)
| | | | | 或 sun、mon、tue、wed、thr、fri、sat
| | | | |
* * * * * user-name command-to-be-executed
&lt;/code>&lt;/pre>
&lt;h3 id="星号的使用">星号的使用&lt;/h3>
&lt;p>星号（*）可以用来替代数字，表示该位置的所有可能值。例如，分钟位置上的星号会使它每分钟运行一次。以下示例可能有助于更好地理解语法。&lt;/p>
&lt;p>这个 cron 作业将每分钟运行一次：&lt;/p>
&lt;p>&lt;code>* * * * [command]&lt;/code>&lt;/p>
&lt;p>斜杠表示分钟的间隔数。下面的示例将每小时运行 12 次，即每 5 分钟运行一次：&lt;/p>
&lt;p>&lt;code>*/5 * * * * [command]&lt;/code>&lt;/p>
&lt;p>下一个示例将每月的第二天午夜（例如 1 月 2 日凌晨 12:00，2 月 2 日凌晨 12:00 等等）：&lt;/p>
&lt;p>&lt;code>0 0 2 * * [command]&lt;/code>&lt;/p>
&lt;p>&lt;em>关于 cron 时间格式，还有更多格式符号，此处没有展开&lt;/em>&lt;/p>
&lt;h3 id="使用-crontab-创建一个-cron-作业">使用 crontab 创建一个 cron 作业&lt;/h3>
&lt;p>cron 作业会在后台运行，它会不断检查 /etc/crontab 文件和 /etc/cron.*/ 以及 /var/spool/cron/ 目录。每个用户在 /var/spool/cron/ 中都有一个唯一的 crontab 文件。&lt;/p>
&lt;p>不应该直接编辑这些 cron 文件。crontab 命令是用于创建、编辑、安装、卸载和列出 cron 作业的方法。&lt;/p>
&lt;p>更酷的是，在创建新文件或编辑现有文件后，你无需重新启动 cron。&lt;/p>
&lt;p>&lt;code>$ crontab -e&lt;/code>&lt;/p>
&lt;p>这将打开你现有的 crontab 文件，或者创建一个。调用 crontab -e 时，默认情况下会使用 vi 编辑器。注意：要使用 Nano 编辑 crontab 文件，可以设置 EDITOR=nano 环境变量。&lt;/p>
&lt;p>使用 -l 选项列出所有 cron 作业。如果需要，使用 -u 选项指定一个用户。&lt;/p>
&lt;p>&lt;code>$ crontab -l&lt;/code>&lt;/p>
&lt;p>&lt;code>$ crontab -u username -l&lt;/code>&lt;/p>
&lt;p>使用以下命令删除所有 cron 作业：&lt;/p>
&lt;p>&lt;code>$ crontab -r&lt;/code>&lt;/p>
&lt;p>要删除特定用户的作业，你必须以 root 用户身份运行以下命令：&lt;/p>
&lt;p>&lt;code>$ crontab -r -u username&lt;/code>&lt;/p>
&lt;p>cron 作业看起来可能只是系统管理员的工具，但它实际上与许多 Web 应用程序和用户任务有关。&lt;/p>
&lt;h1 id="参考">参考&lt;/h1>
&lt;p>Fedora Linux 文档的 &lt;a href="https://docs.fedoraproject.org/en-US/Fedora/12/html/Deployment_Guide/ch-autotasks.html">[1]&lt;/a>&lt;/p>
&lt;p>使用 cron 调度任务 &lt;a href="https://linux.cn/article-13383-1.html">[2]&lt;/a>&lt;/p></description></item></channel></rss>