<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on 白菜</title><link>https://blog.baicai.me/tags/docker/</link><description>Recent content in Docker on 白菜</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@baicai.me (白菜)</managingEditor><webMaster>admin@baicai.me (白菜)</webMaster><copyright>baicai.me</copyright><lastBuildDate>Fri, 11 Oct 2024 14:53:59 +0800</lastBuildDate><atom:link href="https://blog.baicai.me/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker本地镜像的导出、导入 (export,import,save,load)</title><link>https://blog.baicai.me/article/2024/docker_export_import_save_load/</link><pubDate>Fri, 11 Oct 2024 14:53:59 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/docker_export_import_save_load/</guid><description>&lt;p>对于镜像的导出和导入，Docker 提供了两种方案，下面分别进行介绍。&lt;/p>
&lt;h2 id="一使用-export-和-import">一、使用 export 和 import&lt;/h2>
&lt;h3 id="1查看本机的容器">1，查看本机的容器&lt;/h3>
&lt;p>使用 &lt;code>docker ps -a&lt;/code> 命令查看本机所有的容器。&lt;/p>
&lt;h3 id="2导出镜像">2，导出镜像&lt;/h3>
&lt;p>（1）使用 &lt;code>docker export&lt;/code> 命令根据容器 ID 将镜像导出成一个文件。&lt;/p>
&lt;p>&lt;code>docker export 镜像ID &amp;gt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）上面命令执行后，可以看到文件已经保存到当前的终端目录下。&lt;/p>
&lt;h3 id="3导入镜像">3，导入镜像&lt;/h3>
&lt;p>（1）使用 &lt;code>docker import&lt;/code> 命令则可将这个镜像文件导入进来。&lt;/p>
&lt;p>&lt;code>docker import - new_server &amp;lt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）执行 &lt;code>docker images&lt;/code> 命令可以看到镜像确实已经导入进来了。&lt;/p>
&lt;h2 id="二使用-save-和-load">二、使用 save 和 load&lt;/h2>
&lt;h3 id="1查看本机的容器-1">1，查看本机的容器&lt;/h3>
&lt;p>这两个命令是通过镜像来保存、加载镜像文件的。首先我们使用 &lt;code>docker images&lt;/code> 命令查看本机所有的镜像。&lt;/p>
&lt;h3 id="2保存镜像">2，保存镜像&lt;/h3>
&lt;p>（1）下面使用 &lt;code>docker save&lt;/code> 命令根据 ID 将镜像保存成一个文件。&lt;/p>
&lt;p>&lt;code>docker save 镜像ID &amp;gt; server.tar&lt;/code>&lt;/p>
&lt;p>（2）我们还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包：&lt;/p>
&lt;p>&lt;code>docker save -o images.tar postgres mongo&lt;/code>&lt;/p>
&lt;h3 id="3载入镜像">3，载入镜像&lt;/h3>
&lt;p>使用 &lt;code>docker load&lt;/code> 命令则可将这个镜像文件载入进来。&lt;/p>
&lt;p>&lt;code>docker load &amp;lt; server.tar&lt;/code>&lt;/p>
&lt;h2 id="附两种方案的差别">附：两种方案的差别&lt;/h2>
&lt;p>特别注意：两种方法不可混用。&lt;br>
如果使用 &lt;code>import&lt;/code> 导入 &lt;code>save&lt;/code> 产生的文件，虽然导入不提示错误，但是启动容器时会提示失败，会出现类似&amp;quot;docker: Error response from daemon: Container command not found or does not exist&amp;quot;的错误。&lt;/p>
&lt;h3 id="1文件大小不同">1，文件大小不同&lt;/h3>
&lt;p>export 导出的镜像文件体积小于 save 保存的镜像&lt;/p>
&lt;h3 id="2是否可以对镜像重命名">2，是否可以对镜像重命名&lt;/h3>
&lt;p>docker import 可以为镜像指定新名称
docker load 不能对载入的镜像重命名&lt;/p>
&lt;h3 id="3是否可以同时将多个镜像打包到一个文件中">3，是否可以同时将多个镜像打包到一个文件中&lt;/h3>
&lt;p>docker export 不支持
docker save 支持&lt;/p>
&lt;h3 id="4是否包含镜像历史">4，是否包含镜像历史&lt;/h3>
&lt;p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。&lt;/p>
&lt;p>save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。&lt;/p>
&lt;h3 id="5应用场景不同">5，应用场景不同&lt;/h3>
&lt;p>docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。&lt;/p>
&lt;p>docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 docker save 将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。&lt;/p></description></item><item><title>解决 UFW 和 Docker 的问题</title><link>https://blog.baicai.me/article/2024/debian_ufw_docker/</link><pubDate>Thu, 11 Jul 2024 14:31:38 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/debian_ufw_docker/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>UFW 是一个 iptables 前端，可以非常方便的管理防火墙的规则。但是当安装了 Docker，UFW 无法管理 Docker 发布出来的端口了。&lt;/p>
&lt;p>具体现象是：&lt;/p>
&lt;ol>
&lt;li>在一个对外提供服务的服务器上启用了 UFW，并且默认阻止所有未被允许的传入连接。&lt;/li>
&lt;li>运行了一个 Docker 容器，并且使用 &lt;code>-p&lt;/code> 选项来把该容器的某个端口发布到服务器的所有 IP 地址上。比如：&lt;code>docker run -d --name httpd -p 0.0.0.0:8080:80 httpd:alpine&lt;/code> 将会运行一个 httpd 服务，并且将容器的 &lt;code>80&lt;/code> 端口发布到服务器的 &lt;code>8080&lt;/code> 端口上。&lt;/li>
&lt;li>UFW 将不会阻止所有对 &lt;code>8080&lt;/code> 端口访问的请求，用命令 &lt;code>ufw deny 8080&lt;/code> 也无法阻止外部访问这个端口。&lt;/li>
&lt;/ol>
&lt;p>这个问题其实挺严重的，这意味着本来只是为了在内部提供服务的一个端口被暴露在公共网络上。&lt;/p>
&lt;h2 id="解决-ufw-和-docker-的问题">解决 UFW 和 Docker 的问题&lt;/h2>
&lt;h3 id="撤销原先的修改">撤销原先的修改&lt;/h3>
&lt;p>如果已经按照目前网络上搜索到解决方案修改过了，请先修改回来，包括：&lt;/p>
&lt;ol>
&lt;li>启用 Docker 的 iptables 功能，删除所有类似 &lt;code>--iptables=false&lt;/code> 的修改，包括 &lt;code>/etc/docker/daemon.json&lt;/code> 配置文件。&lt;/li>
&lt;li>UFW 的默认 &lt;code>FORWARD&lt;/code> 规则改回默认的 &lt;code>DROP&lt;/code>，而非 &lt;code>ACCEPT&lt;/code>。&lt;/li>
&lt;li>删除 UFW 配置文件 &lt;code>/etc/ufw/after.rules&lt;/code> 中与 Docker 网络相关的规则。&lt;/li>
&lt;li>如果修改了 Docker 相关的配置文件，重启 Docker。稍后还要修改 UFW 的配置，可以一并重启。&lt;/li>
&lt;/ol>
&lt;p>目前新的解决方案只需要修改一个 UFW 配置文件即可，Docker 的所有配置和选项都保持默认。&lt;/p>
&lt;p>修改 UFW 的配置文件 &lt;code>/etc/ufw/after.rules&lt;/code>，在最后添加上如下规则：&lt;/p>
&lt;pre tabindex="0">&lt;code> # BEGIN UFW AND DOCKER
*filter
:ufw-user-forward - [0:0]
:ufw-docker-logging-deny - [0:0]
:DOCKER-USER - [0:0]
-A DOCKER-USER -j ufw-user-forward
-A DOCKER-USER -j RETURN -s 10.0.0.0/8
-A DOCKER-USER -j RETURN -s 172.16.0.0/12
-A DOCKER-USER -j RETURN -s 192.168.0.0/16
-A DOCKER-USER -p udp -m udp --sport 53 --dport 1024:65535 -j RETURN
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 172.16.0.0/12
-A DOCKER-USER -j RETURN
-A ufw-docker-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &amp;#34;[UFW DOCKER BLOCK] &amp;#34;
-A ufw-docker-logging-deny -j DROP
COMMIT
# END UFW AND DOCKER
&lt;/code>&lt;/pre>&lt;p>然后重启 UFW，&lt;code>sudo systemctl restart ufw&lt;/code>。现在外部就已经无法访问 Docker 发布出来的任何端口了，但是容器内部以及私有网络地址上可以正常互相访问，而且容器也可以正常访问外部的网络。&lt;strong>可能由于某些未知原因，重启 UFW 之后规则也无法生效，请重启服务器。&lt;/strong>&lt;/p>
&lt;p>如果希望允许外部网络访问 Docker 容器提供的服务，比如有一个容器的服务端口是 &lt;code>80&lt;/code>。那就可以用以下命令来允许外部网络访问这个服务：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto tcp from any to any port 80
&lt;/code>&lt;/pre>&lt;p>这个命令会允许外部网络访问所有用 Docker 发布出来的并且内部服务端口为 &lt;code>80&lt;/code> 的所有服务。&lt;/p>
&lt;p>如果有多个容器的服务端口为 80，但只希望外部网络访问某个特定的容器。比如该容器的私有地址为 &lt;code>172.17.0.2&lt;/code>，就用类似下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto tcp from any to 172.17.0.2 port 80
&lt;/code>&lt;/pre>&lt;p>如果一个容器的服务是 UDP 协议，假如是 DNS 服务，可以用下面的命令来允许外部网络访问所有发布出来的 DNS 服务：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any to any port 53
&lt;/code>&lt;/pre>&lt;p>同样的，如果只针对一个特定的容器，比如 IP 地址为 &lt;code>172.17.0.2&lt;/code>：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any to 172.17.0.2 port 53
&lt;/code>&lt;/pre>&lt;h3 id="解释">解释&lt;/h3>
&lt;p>在新增的这段规则中，下面这段规则是为了让私有网络地址可以互相访问。通常情况下，私有网络是比公共网络更信任的。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j RETURN -s 10.0.0.0/8
-A DOCKER-USER -j RETURN -s 172.16.0.0/12
-A DOCKER-USER -j RETURN -s 192.168.0.0/16
&lt;/code>&lt;/pre>&lt;p>下面的规则是为了可以用 UFW 来管理外部网络是否允许访问 Docker 容器提供的服务，这样我们就可以在一个地方来管理防火墙的规则了。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j ufw-user-forward
&lt;/code>&lt;/pre>&lt;p>例如，我们要阻止一个 IP 地址为 172.17.0.9 的容器内的所有对外连接，也就是阻止该容器访问外部网络，使用下列命令&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route deny from 172.17.0.9 to any
&lt;/code>&lt;/pre>&lt;p>下面的规则阻止了所有外部网络发起的连接请求，但是允许内部网络访问外部网络。对于 TCP 协议，是阻止了从外部网络主动建立 TCP 连接。对于 UDP，是阻止了所有小于端口 &lt;code>32767&lt;/code> 的访问。为什么是这个端口的？由于 UDP 协议是无状态的，无法像 TCP 那样阻止发起建立连接请求的握手信号。在 GNU/Linux 上查看文件 &lt;code>/proc/sys/net/ipv4/ip_local_port_range&lt;/code> 可以看到发出 TCP/UDP 数据后，本地源端口的范围，默认为 &lt;code>32768 60999&lt;/code>。当从一个运行的容器对外访问一个 UDP 协议的服务时，本地端口将会从这个端口范围里面随机选择一个，服务器将会把数据返回到这个随机端口上。所以，我们可以假定所有容器内部的 UDP 协议的监听端口都小余 &lt;code>32768&lt;/code>，不允许外部网络主动连接小余 &lt;code>32768&lt;/code> 的 UDP 端口。&lt;/p>
&lt;pre tabindex="0">&lt;code> -A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0/12
-A DOCKER-USER -j RETURN
&lt;/code>&lt;/pre>&lt;p>如果一个容器在接受数据的时候，端口号没有遵循操作系统的设定，也就是说最小端口号要小余 &lt;code>32768&lt;/code>。比如运行了一个 Dnsmasq 的容器，Dnsmasq 用于接受数据的最小端口号默认是 &lt;code>1024&lt;/code>。那可以用下面的命令来允许 Dnsmasq 这个容器使用一个更大的端口范围来接受数据。&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow proto udp from any port 53 to any port 1024:65535
&lt;/code>&lt;/pre>&lt;p>因为 DNS 是一个非常常见的服务，所以已经有一条规则用于允许使用一个更大的端口范围来接受 DNS 数据包&lt;/p>
&lt;h3 id="选择-ufw-user-forward-而不是-ufw-user-input-的原因">选择 &lt;code>ufw-user-forward&lt;/code> 而不是 &lt;code>ufw-user-input&lt;/code> 的原因&lt;/h3>
&lt;h4 id="使用-ufw-user-input">使用 &lt;code>ufw-user-input&lt;/code>&lt;/h4>
&lt;p>优点：&lt;/p>
&lt;p>使用的 UFW 命令比较简单，也比较容易理解&lt;/p>
&lt;p>比如，允许公众网络访问一个已经发布出来的容器端口 &lt;code>8080&lt;/code>，使用命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow 8080
&lt;/code>&lt;/pre>&lt;p>缺点：&lt;/p>
&lt;p>不仅仅是暴露了已经发布的容器端口，也暴露了主机上的端口。&lt;/p>
&lt;p>比如，如果在主机上运行了一个端口为 &lt;code>8080&lt;/code> 的服务。命令 &lt;code>ufw allow 8080&lt;/code> 允许了公共网络访问这个服务，也允许了访问所有已经发布的容器端口为 &lt;code>8080&lt;/code> 的服务。但是我们可能只是希望保留主机上的这个服务，或者是运行在容器里面的服务，而不是两个同时暴露。&lt;/p>
&lt;p>为了避免这个问题，我们可能需要使用类似下面的命令来管理已经发布的容器端口：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow proto tcp from any to 172.16.0.3 port 8080
&lt;/code>&lt;/pre>&lt;h4 id="使用-ufw-user-forward">使用 &lt;code>ufw-user-forward&lt;/code>&lt;/h4>
&lt;p>优点：&lt;/p>
&lt;p>不会因为同一条命令而同时暴露主机和容器里面的服务。&lt;/p>
&lt;p>比如，如果我们希望暴露所有容器端口为 &lt;code>8080&lt;/code> 的服务，使用下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw route allow 8080
&lt;/code>&lt;/pre>&lt;p>现在公共网络可以访问所有容器端口为 &lt;code>8080&lt;/code> 的已经发布的服务，但是运行在主机上的 &lt;code>8080&lt;/code> 服务仍然不会被公开。如果我们希望公开主机上的 &lt;code>8080&lt;/code> 端口，可以执行下面的命令：&lt;/p>
&lt;pre tabindex="0">&lt;code> ufw allow 8080
&lt;/code>&lt;/pre>&lt;h4 id="结论">结论&lt;/h4>
&lt;p>如果我们正在使用老版本，我们可以使用 &lt;code>ufw-user-input&lt;/code>。但是要小心避免把不该暴露的服务暴露出去。&lt;/p>
&lt;p>如果正在使用支持 &lt;code>ufw route&lt;/code> 命令的新版本，我们最好使用 &lt;code>ufw-user-forward&lt;/code>，并且使用 &lt;code>ufw route&lt;/code> 来管理与容器相关的防火墙规则。&lt;/p></description></item><item><title>docker 映射某个范围内的端口列表</title><link>https://blog.baicai.me/article/2024/docker_ports/</link><pubDate>Sat, 09 Mar 2024 00:01:19 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2024/docker_ports/</guid><description>&lt;p>在Dockerfile、命令行或docker-compose.yml中，都可以使用类似于8080-8090:8080-8090的格式，来映射多个端口&lt;/p>
&lt;h3 id="docker-composeyml">docker-compose.yml&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3.6&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">web&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx:1.18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 将会映射8080到8090这个范围内的端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">8080-8090&lt;/span>:&lt;span style="color:#ae81ff">8080-8090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./www:/www&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="命令行">命令行&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -p 8080-8090:8080-8090 nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dockerfile">Dockerfile&lt;/h3>
&lt;pre tabindex="0">&lt;code>Dockerfile
EXPOSE 8080-8090
&lt;/code>&lt;/pre></description></item><item><title>Docker的 privileged 选项解析（特权模式：赋予容器几乎与主机相同的权限）</title><link>https://blog.baicai.me/article/2023/docker_privileged/</link><pubDate>Fri, 17 Nov 2023 22:52:38 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_privileged/</guid><description>&lt;h3 id="runtime-privilege-and-linux-capabilities">Runtime privilege and Linux capabilities&lt;/h3>
&lt;p>参考官方文档：&lt;a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker run reference&lt;/a>&lt;/p>
&lt;p>By default, Docker containers are &amp;ldquo;unprivileged&amp;rdquo; and cannot, for example, run a Docker daemon inside a Docker container. This is because by default a container is not allowed to access any devices, but a &amp;ldquo;privileged&amp;rdquo; container is given access to all devices (see the documentation on cgroups devices).&lt;/p>
&lt;p>The &amp;ndash;privileged flag gives all capabilities to the container. When the operator executes docker run &amp;ndash;privileged, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with &amp;ndash;privileged is available on the &lt;a href="https://www.docker.com/blog/docker-can-now-run-within-docker/">Docker Blog&lt;/a>.&lt;/p>
&lt;h2 id="docker-容器的安全性">Docker 容器的安全性&lt;/h2>
&lt;h3 id="linux-namespace-和-capabilities">Linux Namespace 和 Capabilities&lt;/h3>
&lt;p>Docker使用Linux namespace和capabilities来实现容器隔离和限制权限。&lt;/p>
&lt;pre>&lt;code>Linux Namespace：Docker利用namespace技术，使得每个容器都有其自己的进程、网络、挂载、用户ID等独立的空间。这保证了容器与容器之间以及容器与主机之间的隔离性。
Capabilities：Linux capabilities允许将传统的root权限分割成多个不同的能力，例如CAP_NET_ADMIN能力允许操作网络配置，CAP_CHOWN能力允许改变文件所有权。Docker默认情况下会赋予容器一些必要的capabilities，但不包括全部的能力，从而降低了被攻击的风险。
&lt;/code>&lt;/pre>
&lt;p>Docker 通过 &amp;ndash;cap-add 和 &amp;ndash;cap-drop 两个参数，可以灵活地添加或删除容器的 capabilities。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --cap-add&lt;span style="color:#f92672">=&lt;/span>SYS_PTRACE --rm -it alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面 &lt;code>--cap-add=SYS_PTRACE&lt;/code> 的意思就是：给容器添加 SYS_PTRACE 权限，允许容器内的进程可以 ptrace 和 debug 其他进程。&lt;/p>
&lt;h3 id="docker限制和权限">Docker限制和权限&lt;/h3>
&lt;p>在默认情况下，Docker对容器的权限进行了严格的限制，只提供了有限的capabilities。此外，许多系统级别的操作（例如挂载文件系统、修改内核参数等）都是被禁止的。这种安全模型使得Docker可以在不牺牲安全性的前提下，实现轻量级的虚拟化。&lt;/p>
&lt;p>然而，在某些情况下，我们可能需要赋予容器更多的权限。例如，如果我们需要在容器中运行一些需要特权的服务（如网络设备管理、硬件设备接口等），那么默认的权限可能就不够用了。这时候，&lt;code>--privileged=true&lt;/code> 选项就派上了用场。&lt;/p>
&lt;h4 id="docker的privilegedtrue选项">Docker的–privileged=true选项&lt;/h4>
&lt;p>当使用&amp;ndash;privileged=true选项运行容器时，Docker会赋予容器几乎与主机相同的权限。
具体来说，这个选项做了以下两件事情：&lt;/p>
&lt;pre tabindex="0">&lt;code> 给容器添加了所有的capabilities
允许容器访问主机的所有设备
&lt;/code>&lt;/pre>&lt;h4 id="--privilegedtrue的风险">&amp;ndash;privileged=true的风险&lt;/h4>
&lt;p>尽管 &lt;code>--privileged=true&lt;/code> 选项为容器提供了强大的功能，但它也带来了一些严重的安全隐患。由于privileged容器具有几乎与主机相同的权限，所以如果容器被恶意代码控制，那么攻击者就可以轻易地突破容器的边界，对主机进行任意操作。&lt;/p>
&lt;p>因此，我们需要谨慎地使用 &lt;code>--privileged=true&lt;/code> 选项，只在真正需要的情况下才启用它。在可能的情况下，我们应该尽量使用其他更细粒度的权限控制手段，例如通过&lt;code>--cap-add&lt;/code>或&lt;code>--device&lt;/code>参数来分别添加必要的capabilities或设备访问权限。&lt;/p>
&lt;h4 id="细粒度的权限控制手段">细粒度的权限控制手段&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加单个capability&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --rm --cap-add NET_ADMIN -it alpine sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加设备访问权限&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --device&lt;span style="color:#f92672">=&lt;/span>/dev/sda:/dev/xvdc -it alpine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="docker-compose-参考">docker-compose 参考&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">baicai_image&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">debian&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;baicai_image&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run -c /app/config.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./config.json:/app/config.json&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;80:80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">privileged&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cap_add&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">NET_ADMIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_MODULE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_PTRACE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">SYS_ADMIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">NET_RAW&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cap_drop&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">ALL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="附注-在docker-debian容器中安装pstop等命令">附注: 在Docker Debian容器中安装ps、top等命令&lt;/h3>
&lt;p>debian镜像默认没有包括进程管理相关工具，在实际使用时可能有些麻烦，如果需要也可以自己安装，使用如下命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> apt install -y procps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docker 搭建MTProto协议上网</title><link>https://blog.baicai.me/article/2023/docker_mtg/</link><pubDate>Thu, 07 Sep 2023 18:00:43 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_mtg/</guid><description>&lt;p>系统环境：
Debian系（其他系只需要更换apt为对应系统的软件包管理工具名称即可）&lt;/p>
&lt;h2 id="安装docker">安装Docker&lt;/h2>
&lt;h3 id="安装docker相关工具">安装Docker相关工具&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt -y upgrade &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y docker docker.io docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动docker">启动docker&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo systemctl enable docker &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo systemctl start docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="验证是否安装成功">验证是否安装成功&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run hello-world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mtg-v2版本-docker运行">mtg v2版本 docker运行&lt;/h2>
&lt;h3 id="生成密钥">生成密钥&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker pull baicailin/mtg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker run --rm baicailin/mtg generate-secret --hex trade.aliexpress.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#会看到一串ee开头的密钥，形如：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eexxx44f3762c8a97d14f89df8c0174726164652e616c69657870726573732e636f6d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="写入简单配置">写入简单配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;secret = \&amp;#34;把上面一步生成的密钥填进来\&amp;#34;&amp;#34;&lt;/span> &amp;gt;config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;bind-to = \&amp;#34;0.0.0.0:443\&amp;#34;&amp;#34;&lt;/span> &amp;gt;&amp;gt;config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="运行docker镜像命令">运行docker镜像命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -d -v $PWD/config.toml:/config.toml -p 443:443 --name baicai_mtg --restart&lt;span style="color:#f92672">=&lt;/span>unless-stopped baicailin/mtg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-compose-启动可代替上面这个命令启动方式">docker-compose 启动（可代替上面这个命令启动方式）&lt;/h3>
&lt;p>一键启动 docker-compose.yaml 文件参考&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mtg_v2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">baicailin/mtg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mtg_v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run /config.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./config.toml:/config.toml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;443:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成mtproto协议服务配置">生成MTProto协议服务配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker exec mtg_v2 /mtg access /config.toml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mtg_v1-版本支持adtag-赞助选项运行">mtg_v1 版本(支持adtag 赞助选项)运行&lt;/h2>
&lt;p>生成密钥&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker run --rm baicailin/mtg:1 generate-secret tls -c bing.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eedf71035a8ed48a623d8e83e66aec4d0562696e672e636f6d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-compose-启动可代替上面这个命令启动方式-1">docker-compose 启动（可代替上面这个命令启动方式）&lt;/h3>
&lt;p>一键启动 docker-compose.yaml 文件参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mtg_v1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">baicailin/mtg:1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mtg_v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">unless-stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># deploy:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># resources:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># limits:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># cpus: 0.50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># memory: 256M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># reservations:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># memory: 128M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">run eedf71035a8ed48a623d8e83e66aec4d0562696e672e636f6d adtag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TZ&lt;/span>: &lt;span style="color:#ae81ff">Asia/Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_DEBUG: &amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_BIND: &amp;#34;0.0.0.0:3128&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_IPV4: &amp;#34;公网ip:端口&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_IPV6: &amp;#34;公网ip:端口&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># MTG_STATS_BIND: &amp;#34;127.0.0.1:3129&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># network_mode: host &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;1443:3128&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;1444:3129&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行参数中的 &lt;code>adtag&lt;/code> 可以通过tg机器人 &lt;code>@MTProxybot&lt;/code> 创建获得&lt;/p>
&lt;h3 id="查看mtproto协议服务配置">查看MTProto协议服务配置&lt;/h3>
&lt;p>在mtg v1 docker-compose.yml文件目录下运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker-compose logs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>docker golang:alpine CGO 制作镜像的正确姿势</title><link>https://blog.baicai.me/article/2023/docker_golang_alpine_cgo_build/</link><pubDate>Mon, 04 Sep 2023 23:23:09 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2023/docker_golang_alpine_cgo_build/</guid><description>&lt;p>当程序需要引入C/C++库（比如支持Sqlite数据库）的时候，编译环境需要打开CGO，否则打包完成后的程序就不能顺利运行（数据库初始化失败）。&lt;/p>
&lt;p>这时就需要安装 build-base 配置编译环境。&lt;/p>
&lt;p>参考 Dockerfile 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM golang:alpine as builder
ENV CGO_ENABLED=1
WORKDIR /app
COPY . .
RUN apk add --no-cache --update git build-base
RUN go mod tidy \
&amp;amp;&amp;amp; go build -o api_client_linux ./cmd/api_client/
FROM alpine:latest as runner
ENV TZ=Asia/Shanghai
RUN apk --no-cache add ca-certificates tzdata libc6-compat libgcc libstdc++
WORKDIR /app
COPY --from=builder /app/api_client_linux .
VOLUME /app/conf
EXPOSE 8080
ENTRYPOINT [&amp;#34;./api_client_linux&amp;#34; ,&amp;#34;-c&amp;#34;,&amp;#34;/app/conf/config.yaml&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>运行镜像我们也使用 Alpine ，由于 Alpine 极为精简，并没有常用的时区、证书等，会导致不可预料的错误。所以我们需要安装这些东西：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">包名&lt;/th>
&lt;th style="text-align:left">用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">ca-certificates:&lt;/td>
&lt;td style="text-align:left">CA证书，使用TLS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">tzdata:&lt;/td>
&lt;td style="text-align:left">时区配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">libc6-compat:&lt;/td>
&lt;td style="text-align:left">C 标准库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">libgcc:&lt;/td>
&lt;td style="text-align:left">GCC 相关库，CGO编译程序依赖&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">libstdc++:&lt;/td>
&lt;td style="text-align:left">C++ 标准库&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>安装docker</title><link>https://blog.baicai.me/article/2022/debian_install_docker/</link><pubDate>Fri, 30 Sep 2022 00:38:13 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2022/debian_install_docker/</guid><description>&lt;p>运行环境&lt;/p>
&lt;pre tabindex="0">&lt;code> Operating System: Debian GNU/Linux 11 (bullseye)
Kernel: Linux 5.10.0-18-amd64
Architecture: x86-64
&lt;/code>&lt;/pre>&lt;h3 id="通过debian官方软件仓库安装">通过Debian官方软件仓库安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 更新软件源 并 安装 docker及相关应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo apt update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y docker docker.io docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看docker运行状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo systemctl status docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看docker信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo docker info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 验证是否安装成功 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo docker run hello-world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="镜像加速器">镜像加速器&lt;/h3>
&lt;p>访问 &lt;a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors&lt;/a> 获取自己的阿里云镜像加速器地址&lt;/p>
&lt;p>修改 /etc/docker/daemon.json&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo mkdir -p /etc/docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tee /etc/docker/daemon.json &lt;span style="color:#e6db74">&amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">{
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-concurrent-downloads&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-concurrent-uploads&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;max-download-attempts&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://修改为自己的.mirror.aliyuncs.com&amp;#34;,&amp;#34;https://hub-mirror.c.163.com&amp;#34;,&amp;#34;https://registry.aliyuncs.com&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="清理docker对象">清理docker对象&lt;/h3>
&lt;p>prune 命令用来删除不再使用的 docker 对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被 tag 标记和未被容器使用的镜像:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker image prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被容器使用的镜像:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker image prune -af
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有停止运行的容器:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker container prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有未被挂载的卷:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker volume prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除所有网络:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker network prune
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 docker 所有资源:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker system prune
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看容器ip">查看容器ip&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看所有容器的ip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker inspect --format&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看指定容器的ip网络配置包含网络，ip等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker inspect containerId
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看容器的ip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker exec -it containerId ip addr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="修改docker启动目录">修改docker启动目录&lt;/h3>
&lt;p>因为装系统时 /var 分区小，需要把docker 启动后的路径改成 /home/docker , /etc/docker/daemon.json 是 docker 的配置文件，默认是没有的，需要手动创建。&lt;/p>
&lt;p>具体的操作是：&lt;/p>
&lt;p>1: 设置 /etc/docker/daemon.json 文件.
内容参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;data-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;/home/docker&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.创建并修改完daemon.json文件后，需要让这个文件生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># a.修改完成后reload配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># b.重启docker服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl restart docker.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># c.查看状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo systemctl status docker -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># d.查看服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="调试镜像">调试镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用--entrypoint设置（额外增加-it选项可直接进入容器），进入容器成功。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -it --entrypoint /bin/bash --name 容器名 镜像:v30.2.9
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看程序动态库依赖关系">查看程序动态库依赖关系&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ldd (Debian GLIBC 2.36-9+deb12u1) 2.36&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Copyright (C) 2022 Free Software Foundation, Inc.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This is free software; see the source for copying conditions. There is NO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Written by Roland McGrath and Ulrich Drepper.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldd --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 判断某条命令需要哪些共享库文件的支持，以确保指定的命令在独立的系统内可以可靠的运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldd /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参考">参考&lt;/h3>
&lt;p>Docker官方安装文档：
&lt;a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/&lt;/a>&lt;/p>
&lt;h3 id="docker-daemonjson各配置详解">docker-daemon.json各配置详解&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;api-cors-header&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————在引擎API中设置CORS标头
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;authorization-plugins&amp;#34;&lt;/span>:[], &lt;span style="color:#75715e">//——————要加载的授权插件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;bridge&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————将容器附加到网桥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cgroup-parent&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————为所有容器设置父cgroup
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-store&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————分布式存储后端的URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-store-opts&amp;#34;&lt;/span>:{}, &lt;span style="color:#75715e">//————————设置集群存储选项（默认map []）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;cluster-advertise&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————要通告的地址或接口名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;debug&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————启用调试模式，启用后，可以看到很多的启动信息。默认false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-gateway&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器默认网关IPv4地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-gateway-v6&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器默认网关IPv6地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-runtime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;runc&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————容器的默认OCI运行时（默认为&amp;#34; runc&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;default-ulimits&amp;#34;&lt;/span>:{}, &lt;span style="color:#75715e">//——————容器的默认ulimit（默认[]）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;192.168.1.1&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//——————设定容器DNS的地址，在容器的 /etc/resolv.conf文件中可查看。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns-opts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————容器 /etc/resolv.conf 文件，其他设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;dns-search&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;exec-opts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//————————运行时执行选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;exec-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————执行状态文件的根目录（默认为’/var/run/docker‘）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;fixed-cidr&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————固定IP的IPv4子网
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;fixed-cidr-v6&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————固定IP的IPv6子网
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;data-root&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;/var/lib/docker&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————-Docker运行时使用的根路径，默认/var/lib/docker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;group&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————UNIX套接字的组（默认为&amp;#34;docker&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;hosts&amp;#34;&lt;/span>: [], &lt;span style="color:#75715e">//——————设置容器hosts
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;icc&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用容器间通信（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0.0.0.0&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————绑定容器端口时的默认IP（默认0.0.0.0）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;iptables&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//———————启用iptables规则添加（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ipv6&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用IPv6网络
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip-forward&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//————————默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;ip-masq&amp;#34;&lt;/span>:&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————启用IP伪装（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>:[&lt;span style="color:#e6db74">&amp;#34;nodeName=node-121&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//————————docker主机的标签，很实用的功能,例如定义：–label nodeName=host-121
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;live-restore&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//——————在容器仍在运行时启用docker的实时还原
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-driver&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————容器日志的默认驱动程序（默认为&amp;#34; json-file&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-level&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————设置日志记录级别（&amp;#34;调试&amp;#34;，&amp;#34;信息&amp;#34;，&amp;#34;警告&amp;#34;，&amp;#34;错误&amp;#34;，&amp;#34;致命&amp;#34;）（默认为&amp;#34;信息&amp;#34;）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;max-concurrent-downloads&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#75715e">//——————设置每个请求的最大并发下载量（默认为3）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;max-concurrent-uploads&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#75715e">//——————设置每次推送的最大同时上传数（默认为5）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;mtu&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#75715e">//——————设置容器网络MTU
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;oom-score-adjust&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">-500&lt;/span>, &lt;span style="color:#75715e">//——————设置守护程序的oom_score_adj（默认值为-500）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;pidfile&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————Docker守护进程的PID文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;raw-logs&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————全时间戳机制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;selinux-enabled&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————默认 false，启用selinux支持
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;storage-driver&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————要使用的存储驱动程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;swarm-default-advertise-addr&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————设置默认地址或群集广告地址的接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tls&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————默认 false, 启动TLS认证开关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlscacert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————默认 ~/.docker/ca.pem，通过CA认证过的的certificate文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlscert&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————默认 ~/.docker/cert.pem ，TLS的certificate文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlskey&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————默认~/.docker/key.pem，TLS的key文件路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;tlsverify&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">//————————默认false，使用TLS并做后台进程与客户端通讯的验证
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;userland-proxy&amp;#34;&lt;/span>:&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#75715e">//——————使用userland代理进行环回流量（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;userns-remap&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//————————用户名称空间的用户/组设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;bip&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;192.168.88.0/22&amp;#34;&lt;/span>, &lt;span style="color:#75715e">//——————————指定网桥IP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;https://192.498.89.232:89&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//————————设置镜像加速
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;insecure-registries&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;192.168.0.123:12312&amp;#34;&lt;/span>], &lt;span style="color:#75715e">//———————设置私有仓库地址可以设为http
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;storage-opts&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;overlay2.override_kernel_check=true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;overlay2.size=15G&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>], &lt;span style="color:#75715e">//————————存储驱动程序选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;log-opts&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;max-file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#34;max-size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10m&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, &lt;span style="color:#75715e">//————————容器默认日志驱动程序选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;#34;iptables&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e">//————————启用iptables规则添加（默认为true）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docker 运行 postgreSQL</title><link>https://blog.baicai.me/article/2021/docker_postgres/</link><pubDate>Thu, 09 Dec 2021 14:19:08 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/docker_postgres/</guid><description>&lt;h3 id="简单步骤">简单步骤&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>安装docker，可参考 &lt;a href="https://blog.baicai.me/article/2021/docker_start/">安装docker及简单的使用&lt;/a> 或 百度解决；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉取postgreSQL的docker镜像文件：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker pull postgres
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>创建 docker volume，名字为“dv_pgdata&amp;quot;（其实可以省略手动创建，直接跑下一步，docker也会自动创建的）：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker volume create dv_pgdata
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>启动容器，用-v来指定把postgres的数据目录映射到上面创建的dv_pgdata里面：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --name my_postgres -v dv_pgdata:/var/lib/postgresql/data -e POSTGRES_PASSWORD&lt;span style="color:#f92672">=&lt;/span>xxxxxx -p 5432:5432 -d postgres
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>这时候查看已存在的docker volume:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker volume ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>查看volume信息：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ docker inspect dv_pgdata
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>在宿主机，也可以直接查看volume里的内容：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ cd /var/lib/docker/volumes/dv_pgdata/_data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$ ll
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="8">
&lt;li>查看postgresql：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cn2d6@navxin-desktop:~$docker exec -it &lt;span style="color:#ae81ff">618&lt;/span> bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@618f1a4128ee:/# psql -U postgres -d postgres -p &lt;span style="color:#ae81ff">5432&lt;/span> -h 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="9">
&lt;li>更多的时候，我们希望能用图形界面来管理和操作数据库，可以部署pgadmin工具（例如下面），然后在浏览器中访问宿主机的5080端口，便能打开pgadmin。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker pull dpage/pgadmin4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --name pgadmin -p 5080:80 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_DEFAULT_EMAIL=hi@nav.xin&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_DEFAULT_PASSWORD=xxxxxx&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION=True&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_LOGIN_BANNER=&amp;#34;Authorised users only!&amp;#34;&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e &lt;span style="color:#e6db74">&amp;#39;PGADMIN_CONFIG_CONSOLE_LOG_LEVEL=10&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -d dpage/pgadmin4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="用docker-compose部署postgresql和pgadmin4">用docker-compose部署postgresql和pgAdmin4&lt;/h3>
&lt;h4 id="准备步骤">准备步骤&lt;/h4>
&lt;p>安装docker-compose&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> apt install docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>确定已经pull好postgres和pgAdmin4镜像,若未完成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker pull postgres
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker pull dpage/pgadmin4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置内容">配置内容&lt;/h4>
&lt;p>然后在任意目录下新建文件docker-compose.yml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> touch ./docker-compose.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Use postgres/example user/password credentials &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># https://hub.docker.com/_/postgres?tab=description&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在当前目录下运行：sudo docker-compose up -d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 若需停止运行，在当前目录运行：sudo docker-compose down&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># docker路由地址查看： sudo docker inspect postgres_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># sudo docker kill $(sudo docker ps -aq)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># sudo docker rm $(sudo docker ps -aq)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">db&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">postgres&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">privileged&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">postgres_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">5432&lt;/span>:&lt;span style="color:#ae81ff">5432&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">POSTGRES_PASSWORD&lt;/span>: &lt;span style="color:#ae81ff">你的密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGDATA&lt;/span>: &lt;span style="color:#ae81ff">/var/lib/postgresql/data/pgdata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/navxin/kn1/baicai_docker/baicai_postgres/pg_data:/var/lib/postgresql/data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - pgdata:/var/lib/postgresql/data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pgadmin4&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">dpage/pgadmin4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#ae81ff">always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">pgadmin_baicai&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">5080&lt;/span>:&lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGADMIN_DEFAULT_EMAIL&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;hi@nav.xin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PGADMIN_DEFAULT_PASSWORD&lt;/span>: &lt;span style="color:#ae81ff">你的密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># volumes:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># pgdata:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="部署">部署&lt;/h4>
&lt;p>在当前目录下运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker-compose up -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若需停止运行，在当前目录运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker-compose down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>连接步骤&lt;/p>
&lt;p>打开浏览器，输入localhost:5080，登录pgAdmin4之后，点击添加新服务器，特别注意，在连接地址IP里应该填写docker路由地址，端口填写5432。
docker路由地址查看方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> docker inspect postgres_baicai
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在输出内容中找到Gateway，对应的地址即为docker路由地址。&lt;/p>
&lt;h3 id="更多参考">更多参考：&lt;/h3>
&lt;p>&lt;a href="https://blog.baicai.me/article/2021/docker_start/">安装docker及简单的使用&lt;/a>
&lt;a href="https://hub.docker.com/_/postgres?tab=description">postgres&lt;/a>
&lt;a href="https://hub.docker.com/r/dpage/pgadmin4">dpage/pgadmin4&lt;/a>&lt;/p></description></item><item><title>安装docker及简单的使用</title><link>https://blog.baicai.me/article/2021/docker_start/</link><pubDate>Tue, 05 Oct 2021 17:21:06 +0800</pubDate><author>admin@baicai.me (白菜)</author><guid>https://blog.baicai.me/article/2021/docker_start/</guid><description>&lt;h2 id="docker的介绍里面包括了3个基本概念">docker的介绍，里面包括了3个基本概念&lt;/h2>
&lt;h3 id="11-docker主要由镜像和容器构成">1.1 docker主要由镜像和容器构成&lt;/h3>
&lt;p>镜像（Image）:docker镜像好比一个模板，相当于一个文件系统&lt;/p>
&lt;p>容器（Container）:容器需要通过镜像来创建。镜像和容器就像是面向对象中的类和实例一样。容器可以被创建/启动/停止/删除等&lt;/p>
&lt;p>仓库（Repository）:仓库就是存放镜像的地方，分为私有仓库和公有仓库。类似git&lt;/p>
&lt;h3 id="12-docker的运行原理">1.2 docker的运行原理&lt;/h3>
&lt;p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问。dockerServer接收到docker-Client的指令，就会执行这个命令。&lt;/p>
&lt;h2 id="一-mac-系统-docker-的安装">一. Mac 系统 docker 的安装&lt;/h2>
&lt;p>1.1 homebrew的cask应支持Docker for Mac,所以可以直接安装 brew cask install docker&lt;/p>
&lt;p>1.2 也可以直接到官网下载，https://download.docker.com/mac/stable/Docker.dmg&lt;/p>
&lt;p>1.3 docker的参考文档：https://docs.docker.com&lt;/p>
&lt;p>1.4 dockerhub查找镜像源地址：https://hub.docker.com&lt;/p>
&lt;h2 id="二-docker的使用">二. docker的使用&lt;/h2>
&lt;h3 id="11-查看版本">1.1 查看版本&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-compose --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-machine --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-查看docker系统信息包括镜像和容器的数量等">1.2 查看docker系统信息（包括镜像和容器的数量等）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-帮助命令">1.3 帮助命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker help
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="14-查看-cpu的状况">1.4 查看 cpu的状况&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stats
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="三-docker的基本命令">三. docker的基本命令&lt;/h2>
&lt;p>镜像相关命令：&lt;/p>
&lt;h3 id="11-查看镜像可用版本nginx为例">1.1 查看镜像可用版本（nginx为例）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker search nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-下载一个镜像">1.2 下载一个镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker pull nginx:latest &lt;span style="color:#75715e">#（：后面跟镜像版本）&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-运行一个nginx服务器">1.3 运行一个nginx服务器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d -p 81:80 --name webserver nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#--name webserver ：容器名称，用来区分容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-p 81:80 ：端口进行映射，将本地的81端口映射到容器内部的80端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-v ～/nginx/html:/usr/share/nginx/html 数据卷挂载ro/rw，将主机项目中的目录挂载到容器的目录下，默认rw只能在宿主机外改变，容器内部不能改变&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-d：设置容器中在后台一直运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-it：使用交互方式运行，进入容器查看内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-P：随机端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-e：环境配置设置&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：后台启动运行，必须要有一个前台进程，docker发现没有应用，就会自动停止&lt;/p>
&lt;p>重点：数据卷挂载分为具名/匿名/指定路径挂载，容器数据卷挂载可以实现数据共享，容器的持久化和同步操作，可以使用docker volume 查看卷的情况，可以使用volumes-from实现多个容器之间的数据共享。&lt;/p>
&lt;h3 id="14-停止nginx服务">1.4 停止nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stop webserver&lt;span style="color:#f92672">(&lt;/span>容器ID&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="15-删除nginx服务">1.5 删除nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm webserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16-启动重启nginx服务">1.6 启动/重启nginx服务&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker start/restart webserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17-列出所有镜像列表包含了-仓库名标签镜像-id创建时间-以及-所占用的空间">1.7 列出所有镜像(列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker images ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;pre>&lt;code>REPOSITORY 镜像的仓库源
TAG 镜像的标签
IMAGE ID 镜像的id
CREATED 镜像的创建时间
SIZE 镜像的大小
&lt;/code>&lt;/pre>
&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-a：列出所有的镜像
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-q：只显示镜像的id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：镜像ID是唯一标识，一个镜像可以对应多个标签&lt;/p>
&lt;h3 id="18-查看镜像容器数据卷所占用的空间">1.8 查看镜像、容器、数据卷所占用的空间&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker system df
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="19-删除镜像">1.9 删除镜像&lt;/h3>
&lt;p>指定镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#f92672">[&lt;/span>镜像名称/镜像短ID/镜像长ID/镜像摘要&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多个镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi 镜像ID 镜像ID 镜像ID
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>全部镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="20-删除docker-images-ls-命令配合-删除所有仓库名为redis的镜像">2.0 删除docker images ls 命令配合 删除所有仓库名为redis的镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images ls -q redis&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="21-查看镜像运行记录">2.1 查看镜像运行记录&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker history 镜像id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>容器相关命令&lt;/p>
&lt;h3 id="11-列出容器">1.1 列出容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker ps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-a：显示所有的容器，包括未运行的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-l：显示最近创建的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-n：列出最近创建的n个容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-q：只显示容器的编号&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-进入容器">1.2 进入容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker exec -it &lt;span style="color:#f92672">[&lt;/span>容器名称&lt;span style="color:#f92672">]&lt;/span> /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker atthch 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>区别：docker exec 进入容器后开启一个新的终端，可以在里面操作；docker attach 进入容器正在执行的终端，不会启动新的进程&lt;/p>
&lt;h3 id="13-退出容器">1.3 退出容器&lt;/h3>
&lt;p>容器停止退回主机&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>容器不停止推出&lt;/p>
&lt;pre>&lt;code>ctrl+p+q
&lt;/code>&lt;/pre>
&lt;h3 id="14-删除容器">1.4 删除容器&lt;/h3>
&lt;p>指定容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#f92672">[&lt;/span>容器id&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多个容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm 容器id 容器id 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有容器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -aq&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker ps -a -q|xargs docker rm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：不能删除正在运行的容器，要删除正在运行的容器需要加 -f 参数，docker rm -f 容器id&lt;/p>
&lt;h3 id="15-启动重启容器">1.5 启动/重启容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker start/restart 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16-停止强制停止容器">1.6 停止/强制停止容器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker stop/kill 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17-查看容器日志">1.7 查看容器日志&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker logs -f -t --tail &lt;span style="color:#ae81ff">100&lt;/span> 容器id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#--tail后面必须加参数条数&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="18-查看容器中的进程信息">1.8 查看容器中的进程信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker top 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="19-查看容器的元数据重要命令">1.9 查看容器的元数据（重要命令）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker inspect 容器id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="20-从容器上拷贝数据到主机上">2.0 从容器上拷贝数据到主机上&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker cp 容器id:容器内路径 主机路径
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四-dockerfile的指令">四. Dockerfile的指令&lt;/h2>
&lt;pre>&lt;code>FROM 基础镜像，一切从这里开始
MAINTAINER 镜像的作者 姓名&amp;lt;邮箱&amp;gt;
RUN 镜像构建需要运行的命令
ADD 步骤，添加内容
WORKDIR 镜像的工作目录
VOLUME 挂载的目录
EXPOST 端口配置
CMD 指定容器启动要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT 指定这个容器启动要运行的命令，可以追加命令
ONBUILD 当构建一个被继承的Dockerfile时会运行
COPY 类似ADD将我们文件拷贝到镜像中
ENV 构建的时候设置环境变量
&lt;/code>&lt;/pre></description></item></channel></rss>