<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=author content="白菜"><meta property="og:url" content="https://blog.baicai.me/article/2024/debian_ufw_docker/"><link rel=canonical href=https://blog.baicai.me/article/2024/debian_ufw_docker/><style type=text/css>body{font-family:monospace}</style><title>解决 UFW 和 Docker 的问题</title>
<meta name=author content="白菜"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href="/css/baicai_custom.css?rnd=1727179300"></head><body><header>============<br>== <a href=https://blog.baicai.me/>白菜</a> ==<br>============<div style=float:right>一个勤奋的代码搬运工!</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>文章</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/about/><b>关于</b></a>.</nav></p></header><main><article><h1>解决 UFW 和 Docker 的问题</h1><b><time>2024.07.11 14:31</time></b>
<a href=/tags/debian>debian</a>
<a href=/tags/linux>linux</a>
<a href=/tags/ufw>ufw</a>
<a href=/tags/docker>docker</a><div><h2 id=问题>问题</h2><p>UFW 是一个 iptables 前端，可以非常方便的管理防火墙的规则。但是当安装了 Docker，UFW 无法管理 Docker 发布出来的端口了。</p><p>具体现象是：</p><ol><li>在一个对外提供服务的服务器上启用了 UFW，并且默认阻止所有未被允许的传入连接。</li><li>运行了一个 Docker 容器，并且使用 <code>-p</code> 选项来把该容器的某个端口发布到服务器的所有 IP 地址上。比如：<code>docker run -d --name httpd -p 0.0.0.0:8080:80 httpd:alpine</code> 将会运行一个 httpd 服务，并且将容器的 <code>80</code> 端口发布到服务器的 <code>8080</code> 端口上。</li><li>UFW 将不会阻止所有对 <code>8080</code> 端口访问的请求，用命令 <code>ufw deny 8080</code> 也无法阻止外部访问这个端口。</li></ol><p>这个问题其实挺严重的，这意味着本来只是为了在内部提供服务的一个端口被暴露在公共网络上。</p><h2 id=解决-ufw-和-docker-的问题>解决 UFW 和 Docker 的问题</h2><h3 id=撤销原先的修改>撤销原先的修改</h3><p>如果已经按照目前网络上搜索到解决方案修改过了，请先修改回来，包括：</p><ol><li>启用 Docker 的 iptables 功能，删除所有类似 <code>--iptables=false</code> 的修改，包括 <code>/etc/docker/daemon.json</code> 配置文件。</li><li>UFW 的默认 <code>FORWARD</code> 规则改回默认的 <code>DROP</code>，而非 <code>ACCEPT</code>。</li><li>删除 UFW 配置文件 <code>/etc/ufw/after.rules</code> 中与 Docker 网络相关的规则。</li><li>如果修改了 Docker 相关的配置文件，重启 Docker。稍后还要修改 UFW 的配置，可以一并重启。</li></ol><p>目前新的解决方案只需要修改一个 UFW 配置文件即可，Docker 的所有配置和选项都保持默认。</p><p>修改 UFW 的配置文件 <code>/etc/ufw/after.rules</code>，在最后添加上如下规则：</p><pre tabindex=0><code>    # BEGIN UFW AND DOCKER
    *filter
    :ufw-user-forward - [0:0]
    :ufw-docker-logging-deny - [0:0]
    :DOCKER-USER - [0:0]
    -A DOCKER-USER -j ufw-user-forward

    -A DOCKER-USER -j RETURN -s 10.0.0.0/8
    -A DOCKER-USER -j RETURN -s 172.16.0.0/12
    -A DOCKER-USER -j RETURN -s 192.168.0.0/16

    -A DOCKER-USER -p udp -m udp --sport 53 --dport 1024:65535 -j RETURN

    -A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
    -A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
    -A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
    -A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
    -A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
    -A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 172.16.0.0/12

    -A DOCKER-USER -j RETURN

    -A ufw-docker-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &#34;[UFW DOCKER BLOCK] &#34;
    -A ufw-docker-logging-deny -j DROP

    COMMIT
    # END UFW AND DOCKER
</code></pre><p>然后重启 UFW，<code>sudo systemctl restart ufw</code>。现在外部就已经无法访问 Docker 发布出来的任何端口了，但是容器内部以及私有网络地址上可以正常互相访问，而且容器也可以正常访问外部的网络。<strong>可能由于某些未知原因，重启 UFW 之后规则也无法生效，请重启服务器。</strong></p><p>如果希望允许外部网络访问 Docker 容器提供的服务，比如有一个容器的服务端口是 <code>80</code>。那就可以用以下命令来允许外部网络访问这个服务：</p><pre tabindex=0><code>    ufw route allow proto tcp from any to any port 80
</code></pre><p>这个命令会允许外部网络访问所有用 Docker 发布出来的并且内部服务端口为 <code>80</code> 的所有服务。</p><p>如果有多个容器的服务端口为 80，但只希望外部网络访问某个特定的容器。比如该容器的私有地址为 <code>172.17.0.2</code>，就用类似下面的命令：</p><pre tabindex=0><code>    ufw route allow proto tcp from any to 172.17.0.2 port 80
</code></pre><p>如果一个容器的服务是 UDP 协议，假如是 DNS 服务，可以用下面的命令来允许外部网络访问所有发布出来的 DNS 服务：</p><pre tabindex=0><code>    ufw route allow proto udp from any to any port 53
</code></pre><p>同样的，如果只针对一个特定的容器，比如 IP 地址为 <code>172.17.0.2</code>：</p><pre tabindex=0><code>    ufw route allow proto udp from any to 172.17.0.2 port 53
</code></pre><h3 id=解释>解释</h3><p>在新增的这段规则中，下面这段规则是为了让私有网络地址可以互相访问。通常情况下，私有网络是比公共网络更信任的。</p><pre tabindex=0><code>    -A DOCKER-USER -j RETURN -s 10.0.0.0/8
    -A DOCKER-USER -j RETURN -s 172.16.0.0/12
    -A DOCKER-USER -j RETURN -s 192.168.0.0/16
</code></pre><p>下面的规则是为了可以用 UFW 来管理外部网络是否允许访问 Docker 容器提供的服务，这样我们就可以在一个地方来管理防火墙的规则了。</p><pre tabindex=0><code>    -A DOCKER-USER -j ufw-user-forward
</code></pre><p>例如，我们要阻止一个 IP 地址为 172.17.0.9 的容器内的所有对外连接，也就是阻止该容器访问外部网络，使用下列命令</p><pre tabindex=0><code>    ufw route deny from 172.17.0.9 to any
</code></pre><p>下面的规则阻止了所有外部网络发起的连接请求，但是允许内部网络访问外部网络。对于 TCP 协议，是阻止了从外部网络主动建立 TCP 连接。对于 UDP，是阻止了所有小于端口 <code>32767</code> 的访问。为什么是这个端口的？由于 UDP 协议是无状态的，无法像 TCP 那样阻止发起建立连接请求的握手信号。在 GNU/Linux 上查看文件 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 可以看到发出 TCP/UDP 数据后，本地源端口的范围，默认为 <code>32768 60999</code>。当从一个运行的容器对外访问一个 UDP 协议的服务时，本地端口将会从这个端口范围里面随机选择一个，服务器将会把数据返回到这个随机端口上。所以，我们可以假定所有容器内部的 UDP 协议的监听端口都小余 <code>32768</code>，不允许外部网络主动连接小余 <code>32768</code> 的 UDP 端口。</p><pre tabindex=0><code>    -A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16
    -A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8
    -A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12
    -A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0/16
    -A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0/8
    -A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0/12

    -A DOCKER-USER -j RETURN
</code></pre><p>如果一个容器在接受数据的时候，端口号没有遵循操作系统的设定，也就是说最小端口号要小余 <code>32768</code>。比如运行了一个 Dnsmasq 的容器，Dnsmasq 用于接受数据的最小端口号默认是 <code>1024</code>。那可以用下面的命令来允许 Dnsmasq 这个容器使用一个更大的端口范围来接受数据。</p><pre tabindex=0><code>    ufw route allow proto udp from any port 53 to any port 1024:65535
</code></pre><p>因为 DNS 是一个非常常见的服务，所以已经有一条规则用于允许使用一个更大的端口范围来接受 DNS 数据包</p><h3 id=选择-ufw-user-forward-而不是-ufw-user-input-的原因>选择 <code>ufw-user-forward</code> 而不是 <code>ufw-user-input</code> 的原因</h3><h4 id=使用-ufw-user-input>使用 <code>ufw-user-input</code></h4><p>优点：</p><p>使用的 UFW 命令比较简单，也比较容易理解</p><p>比如，允许公众网络访问一个已经发布出来的容器端口 <code>8080</code>，使用命令：</p><pre tabindex=0><code>    ufw allow 8080
</code></pre><p>缺点：</p><p>不仅仅是暴露了已经发布的容器端口，也暴露了主机上的端口。</p><p>比如，如果在主机上运行了一个端口为 <code>8080</code> 的服务。命令 <code>ufw allow 8080</code> 允许了公共网络访问这个服务，也允许了访问所有已经发布的容器端口为 <code>8080</code> 的服务。但是我们可能只是希望保留主机上的这个服务，或者是运行在容器里面的服务，而不是两个同时暴露。</p><p>为了避免这个问题，我们可能需要使用类似下面的命令来管理已经发布的容器端口：</p><pre tabindex=0><code>    ufw allow proto tcp from any to 172.16.0.3 port 8080
</code></pre><h4 id=使用-ufw-user-forward>使用 <code>ufw-user-forward</code></h4><p>优点：</p><p>不会因为同一条命令而同时暴露主机和容器里面的服务。</p><p>比如，如果我们希望暴露所有容器端口为 <code>8080</code> 的服务，使用下面的命令：</p><pre tabindex=0><code>    ufw route allow 8080
</code></pre><p>现在公共网络可以访问所有容器端口为 <code>8080</code> 的已经发布的服务，但是运行在主机上的 <code>8080</code> 服务仍然不会被公开。如果我们希望公开主机上的 <code>8080</code> 端口，可以执行下面的命令：</p><pre tabindex=0><code>    ufw allow 8080
</code></pre><h4 id=结论>结论</h4><p>如果我们正在使用老版本，我们可以使用 <code>ufw-user-input</code>。但是要小心避免把不该暴露的服务暴露出去。</p><p>如果正在使用支持 <code>ufw route</code> 命令的新版本，我们最好使用 <code>ufw-user-forward</code>，并且使用 <code>ufw route</code> 来管理与容器相关的防火墙规则。</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/article/2024/fmt_int/>Go语言进制以及进制转换</a></li><li><a href=/article/2024/cmd_sqlite/>Mac终端查看sqlite3数据库</a></li><li><a href=/article/2024/debian_ufw_docker/>解决 UFW 和 Docker 的问题</a></li><li><a href=/article/2024/docker_ports/>docker 映射某个范围内的端口列表</a></li><li><a href=/article/2024/adb_push_pull/>使用adb命令和电脑互传文件</a></li></ul></div></div></aside><footer><p>&copy; 2024 <a href=https://blog.baicai.me/><b>baicai.me</b></a>.
<a href=/links/><b>友情链接</b></a>.
<a href=/index.xml><b>RSS</b></a>.</p></footer></body></html>