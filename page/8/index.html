<!doctype html><html lang=zh-CN><head><meta name=generator content="Hugo 0.145.0"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=author content="白菜"><meta property="og:url" content="https://blog.baicai.me/"><link rel=canonical href=https://blog.baicai.me/><style type=text/css>body{font-family:monospace}</style><title>白菜</title>
<meta name=description content="一个勤奋的代码搬运工!"><meta name=author content="白菜"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href="/css/baicai_custom.css?rnd=1743157893"><link rel=alternate type=application/rss+xml href=/index.xml title=白菜></head><body><header>============<br>== <a href=https://blog.baicai.me/>白菜</a> ==<br>============<div style=float:right>一个勤奋的代码搬运工!</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>文章</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/about/><b>关于</b></a>.</nav></p></header><main><article><h1><a href=https://blog.baicai.me/article/2021/red-alert-2-chronodivide/>网页版红色警戒2-Red Alert 2: Chrono Divide</a></h1><b><time>2021.06.02 19:22</time></b>
<a href=/tags/%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA>多人联机</a>
<a href=/tags/%E7%BA%A2%E8%AD%A62>红警2</a>
<a href=/tags/%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F>网页游戏</a><div><h3 id=在线红警>在线红警</h3><blockquote><p>又是一波人的集体回忆。。。网站高度还原了经典游戏——红色警戒2，原汁原味的画面和音效，仿佛又回到了那个电脑房的年代！</p></blockquote><p>传送门 <a href=https://game.chronodivide.com/>https://game.chronodivide.com/</a></p><h3 id=玩法>玩法</h3><p>网站支持多人在线对战，注册登陆后即可开始！</p></div></article><article><h1><a href=https://blog.baicai.me/article/2021/goproxy/>Goproxy</a></h1><b><time>2021.05.27 11:22</time></b>
<a href=/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB>技术分享</a>
<a href=/tags/golang>Golang</a>
<a href=/tags/goproxy>Goproxy</a><div><h3 id=go-module代理仓库服务>Go Module代理仓库服务</h3><p>七牛云提供的：https://goproxy.cn</p><p>goproxy.io：https://goproxy.io 或 <a href=https://proxy.golang.com.cn>https://proxy.golang.com.cn</a></p><p>百度云BOS提供的：https://goproxy.bj.bcebos.com/</p><p>阿里云提供的：https://mirrors.aliyun.com/goproxy/</p><h3 id=下载-go-镜像golang-downloads-mirrors>下载 Go 镜像（Golang Downloads Mirrors）</h3><p>官网：https://go.dev/</p><p>下载 Go 镜像：https://golang.google.cn/</p><p>下载 Go 镜像：https://gomirrors.org/</p><p>下载 Go 镜像：https://studygolang.com/dl</p></div></article><article><h1><a href=https://blog.baicai.me/article/2021/linux-memory-forensics/>使用开源工具进行 Linux 内存取证</a></h1><b><time>2021.05.26 12:57</time></b>
<a href=/tags/linux>linux</a>
<a href=/tags/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81>内存取证</a>
<a href=/tags/volatility>Volatility</a>
<a href=/tags/lime>LiME</a>
<a href=/tags/insmod>insmod</a><div><blockquote><p>利用 Volatility 找出应用程序、网络连接、内核模块、文件等方面的情况。</p></blockquote><p>计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。</p><p>内存取证是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。</p><p>因此，这篇文章分为两部分：</p><ul><li>第一部分是处理获取物理内存并将其转储到一个文件中。</li><li>第二部分使用 Volatility 从这个内存转储中读取并处理这些信息。</li></ul><p>我在本教程中使用了以下测试系统，不过它可以在任何 Linux 发行版上工作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /etc/redhat-release
</span></span><span style=display:flex><span>Red Hat Enterprise Linux release 8.3 <span style=color:#f92672>(</span>Ootpa<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>$
</span></span><span style=display:flex><span>$ uname -r
</span></span><span style=display:flex><span>4.18.0-240.el8.x86_64
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><pre><code>注意事项： 部分 1 涉及到编译和加载一个内核模块。不要担心：它并不像听起来那么困难。

一些指南：

    按照以下的步骤。
    不要在生产系统或你的主要计算机上尝试任何这些步骤。
    始终使用测试的虚拟机（VM）来尝试，直到你熟悉使用这些工具并理解它们的工作原理为止。
</code></pre><h2 id=安装需要的包>安装需要的包</h2><p>在开始之前安装必要的工具。如果你经常使用基于 Debian 的发行版，可以使用 apt-get 命令。这些包大多数提供了需要的内核信息和工具来编译代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ yum install kernel-headers kernel-devel gcc elfutils-libelf-devel make git libdwarf-tools python2-devel.x86_64-y
</span></span></code></pre></div><h2 id=部分-1使用-lime-获取内存并将其转储到一个文件中>部分 1：使用 LiME 获取内存并将其转储到一个文件中</h2><p>在开始分析内存之前，你需要一个内存转储供你使用。在实际的取证活动中，这可能来自一个被破坏或者被入侵的系统。这些信息通常会被收集和存储来分析入侵是如何发生的及其影响。由于你可能没有可用的内存转储，你可以获取你的测试 VM 的内存转储，并使用它来执行内存取证。</p><p>Linux 内存提取器（LiME）是一个在 Linux 系统上获取内存很常用的工具。使用以下命令获得 LiME：</p><a href=https://blog.baicai.me/article/2021/linux-memory-forensics/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/linux_sed/>使用 sed 命令进行复制、剪切和粘贴</a></h1><b><time>2021.05.24 00:39</time></b>
<a href=/tags/sed>sed</a>
<a href=/tags/linux>linux</a>
<a href=/tags/mac>Mac</a>
<a href=/tags/gnu-sed>GNU sed</a><div><blockquote><p>很少有 Unix 命令像 sed、grep 和 awk 一样出名，它们经常组合在一起，可能是因为它们具有奇怪的名称和强大的文本解析能力。它们还在一些语法和逻辑上有相似之处。虽然它们都能用于文本解析，但都有其特殊性。本文研究 sed 命令，它是一个 流编辑器。</p></blockquote><h3 id=安装-sed>安装 sed</h3><p>如果你使用的是 Linux、BSD 或 macOS，那么它们已经安装了 GNU 的或 BSD 的 sed。这些是原始 sed 命令的独特重新实现。虽然它们很相似，但也有一些细微的差别。本文已经在 Linux 和 NetBSD 版本上进行了测试，所以你可以使用你的计算机上找到的任何 sed，但是对于 BSD sed，你必须使用短选项（例如 -n 而不是 &ndash;quiet）。</p><p>GNU sed 通常被认为是功能最丰富的 sed，因此无论你是否运行 Linux，你可能都想要尝试一下。如果在 Ports 树中找不到 GNU sed（在非 Linux 系统上通常称为 gsed），你可以从 GNU 网站 下载源代码。 安装 GNU sed 的好处是，你可以使用它的额外功能，但是如果需要可移植性，还可以限制它以遵守 sed 的 POSIX 规范。</p><p>MacOS 用户可以在 MacPorts 或 Homebrew 上找到 GNU sed。</p><p>在 Windows 上，你可以通过 Chocolatey 来 安装 GNU sed。</p><a href=https://blog.baicai.me/article/2021/linux_sed/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/swift-basic-syntax/>Swift语法全面解析</a></h1><b><time>2021.05.13 21:31</time></b>
<a href=/tags/swift>swift</a>
<a href=/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80>语法基础</a>
<a href=/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0>编程学习</a>
<a href=/tags/ios>ios</a><div><h3 id=swift介绍>Swift介绍</h3><p>Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。
swift 是一种安全，快速和互动的编程语言。
swift 支持代码预览（playgrounds），这个特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p><p>Swift 通过采用现代编程模式来避免大量常见编程错误：</p><ul><li>变量始终在使用前初始化。</li><li>检查数组索引超出范围的错误。</li><li>检查整数是否溢出。</li><li>可选值确保明确处理 nil 值。</li><li>内存被自动管理。</li><li>错误处理允许从意外故障控制恢复。</li></ul><h3 id=基础部分>基础部分</h3><h4 id=常量和变量>常量和变量</h4><p>声明常量和变量， 常量和变量必须在使用前声明，使用 let 来声明常量，使用 var 来声明变量。
示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> maximumNumberOfLoginAttempts = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> currentLoginAttempt = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 类型注解</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> welcomeMessage: String
</span></span></code></pre></div><h4 id=注释>注释</h4><p>单行注释双正斜杠（//）， 多行注释（/* 多行的 */）。Swift 的多行注释可以嵌套在其它的多行注释之中。
示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 这是一个注释</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 这也是一个注释，
</span></span></span><span style=display:flex><span><span style=color:#75715e>但是是多行的 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 这是第一个多行注释的开头
</span></span></span><span style=display:flex><span><span style=color:#75715e>/* 这是第二个被嵌套的多行注释 */
</span></span></span><span style=display:flex><span><span style=color:#75715e>这是第一个多行注释的结尾 */</span>
</span></span></code></pre></div><h4 id=分号>分号</h4><p>Swift 并不强制要求你在每条语句的结尾处使用分号（;）。
同一行内写多条独立的语句必须用分号分隔。</p><a href=https://blog.baicai.me/article/2021/swift-basic-syntax/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/go_cross_compilling/>使用 Golang 的交叉编译</a></h1><b><time>2021.05.13 14:35</time></b>
<a href=/tags/golang>Golang</a>
<a href=/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0>编程学习</a><div><blockquote><p>在 Linux 上测试软件时，我使用各种架构的服务器，例如 Intel、AMD、Arm 等。当我 分配了一台满足我的测试需求的 Linux 机器[1]，我仍然需要执行许多步骤：</p></blockquote><ul><li>下载并安装必备软件</li><li>验证构建服务器上是否有新的测试软件包</li><li>获取并设置依赖软件包所需的 yum 仓库</li><li>下载并安装新的测试软件包（基于步骤 2）</li><li>获取并设置必需的 SSL 证书</li><li>设置测试环境，获取所需的 Git 仓库，更改配置，重新启动守护进程等</li><li>做其他需要做的事情</li></ul><h3 id=用脚本自动化>用脚本自动化</h3><p>这些步骤非常常规，以至于有必要对其进行自动化并将脚本保存到中央位置（例如文件服务器），在需要时可以在此处下载脚本。为此，我编写了 100-120 行的 Bash shell 脚本，它为我完成了所有配置（包括错误检查）。这个脚本通过以下方式简化了我的工作流程：</p><ul><li>配置新的 Linux 系统（支持测试的架构）</li><li>登录系统并从中央位置下载自动化 shell 脚本</li><li>运行它来配置系统</li><li>开始测试</li></ul><h3 id=学习-go-语言>学习 Go 语言</h3><p>我想学习 Go 语言 有一段时间了，将我心爱的 Shell 脚本转换为 Go 程序似乎是一个很好的项目，可以帮助我入门。它的语法看起来很简单，在尝试了一些测试程序后，我开始着手提高自己的知识并熟悉 Go 标准库。</p><p>我花了一个星期的时间在笔记本电脑上编写 Go 程序。我经常在我的 x86 服务器上测试程序，清除错误并使程序健壮起来，一切都很顺利。</p><p>直到完全转换到 Go 程序前，我继续依赖自己的 shell 脚本。然后，我将二进制文件推送到中央文件服务器上，以便每次配置新服务器时，我要做的就是获取二进制文件，将可执行标志打开，然后运行二进制文件。我对早期的结果很满意：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ wget http://file.example.com/&lt;myuser&gt;/bins/prepnode
</span></span><span style=display:flex><span>$ chmod  +x ./prepnode
</span></span><span style=display:flex><span>$ ./prepnode
</span></span></code></pre></div><p>然后，出现了一个问题</p><a href=https://blog.baicai.me/article/2021/go_cross_compilling/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/linux_screen/>Linux/Mac 使用 GNU Screen 的小技巧</a></h1><b><time>2021.05.13 12:50</time></b>
<a href=/tags/screen>screen</a>
<a href=/tags/linux>linux</a>
<a href=/tags/mac>Mac</a>
<a href=/tags/gnu-screen>GNU Screen</a><div><blockquote><p>学习基本的 GNU Screen 终端复用技术，然后下载我们的终端命令备忘录，以便你能够熟悉常用的快捷方式。</p></blockquote><p>对于一般用户而言，命令行终端窗口可能是令人困惑和神秘的。但随着你对 Linux 终端的进一步了解，你很快就会意识到它的高效和强大。不过，也不需要很长时间，你就会想让终端变得更加高效，除了将更多的终端放到你的终端，还有什么高好的方法能够提升你的终端效率呢？</p><h3 id=终端复用>终端复用</h3><p>终端的许多优点之一是它是一个集中控制的界面。它是一个能让你访问数百个应用程序的窗口，而你与每一个应用程序进行交互所需要的只是一个键盘。但是，现代计算机几乎总是有多余的处理能力，而且现代计算机专家喜欢多任务处理，导致一个窗口处理数百个应用程序的能力是相当有限的。</p><p>解决这一问题的常见答案是终端复用：即将虚拟终端叠放在一起，然后在它们之间移动的能力。通过终端复用器，你保持了集中控制，但是当你进行多任务时，你能够进行终端切换。更好的是，你能够在终端中拆分屏幕，使得在同一时间显示多个屏幕窗口。</p><h3 id=选择合适的复用器>选择合适的复用器</h3><p>一些终端提供类似的功能，有标签式界面和分割式视图，但也有细微的差别。首先，这些终端的功能依赖于图形化的桌面环境。其次，许多图形化的终端功能需要鼠标交互或使用不方便的键盘快捷键。终端复用器的功能在文本控制台上和在图形桌面上一样好用，而且键位绑定是针对常见的终端序列设计的，很方便。</p><p>现有两种流行的复用器：tmux 和 GNU Screen。尽管你与它们互动的方式略有不同，但它们做同样的事情，而且大多具有相同的功能。这篇文章是 GNU Screen 的入门指南。关于 tmux 的相关介绍，请阅读 Kevin Sonney 的 tmux 介绍。</p><h3 id=使用-gnu-screen>使用 GNU Screen</h3><p>GNU Screen 的基本用法很简单，通过 <code>screen</code> 命令启动，你将进入 Screen 会话的第 0 个窗口。在你决定需要一个新的终端提示符前，你可能很难注意到有什么变化。</p><p>当一个终端窗口被某项活动占用（比如，你启动了文本编辑器 <strong>Vim</strong> 或 <strong>Jove</strong> 或者你在处理音视频，或运行批处理任务），你可以新建一个窗口。要打开一个新的窗口，按 <code>Ctrl+A</code>，释放，然后按 <code>c</code>。这将在你现有窗口的基础上创建一个新的窗口。</p><p>你会知道当前你是在一个新的窗口中，因为你的终端除了默认的提示符外，似乎没有任何东西。当然，你的另一个终端仍然存在，它只是躲在新窗口的后面。要遍历打开的窗口，按 <code>Ctrl+A</code>，释放，然后按 <code>n</code>（表示下一个）或按 <code>p</code>（表示上一个）。在只打开两个窗口的情况下， <code>n</code> 和 <code>p</code> 的功能是一样的，但你可以随时打开更多的窗口（<code>Ctrl+A</code>，然后 <code>c</code> ），并在它们之间切换。</p><h3 id=分屏>分屏</h3><p>GNU Screen 的默认行为更像移动设备的屏幕，而不是桌面：你一次只能看到一个窗口。如果你因为喜欢多任务而使用 GNU Screen ，那么只关注一个窗口可能看起来是一种退步。幸运的是，GNU Screen 可以让你把终端分成窗口中的窗口。</p><p>要创建一个水平分割窗口，按 <code>Ctrl+A</code>，然后按 <code>s</code> 。这将把一个窗口置于另一个窗口之上，就像窗格一样。然而，在你告诉它要显示什么之前，分割的空间是没有用途的。因此，在创建一个分割窗后，你可以用 <code>Ctrl+A</code> ，然后用 <code>Tab</code> 移动到分割窗中。一旦进入，使用 <code>Ctrl+A</code> 然后 <code>n</code> 浏览所有可用的窗口，直到你想显示的内容出现在分割窗格中。</p><a href=https://blog.baicai.me/article/2021/linux_screen/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/linux_cron/>使用 cron 调度自动化任务</a></h1><b><time>2021.05.12 18:59</time></b>
<a href=/tags/cron>cron</a>
<a href=/tags/linux>linux</a>
<a href=/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%BB%E5%8A%A1>自动化任务</a><div><blockquote><p>cron 是一个调度守护进程，它以指定的时间间隔执行任务，这些任务称为 corn 作业，主要用于自动执行系统维护或管理任务。例如，你可以设置一个 cron 作业来自动执行重复的任务，比如备份数据库或数据，使用最新的安全补丁更新系统，检查磁盘空间使用情况，发送电子邮件等等。 cron 作业可以按分钟、小时、日、月、星期或它们的任意组合运行。</p></blockquote><h1 id=cron-的一些优点>cron 的一些优点</h1><p>以下是使用 cron 作业的一些优点：</p><pre><code>你可以更好地控制作业的运行时间。例如，你可以精确到分钟、小时、天等。
它消除了为循环任务逻辑而去写代码的需要，当你不再需要执行任务时，可以直接关闭它。
作业在不执行时不会占用内存，因此你可以节省内存分配。
如果一个作业执行失败并由于某种原因退出，它将在适当的时间再次运行。
</code></pre><h1 id=安装-cron-守护进程>安装 cron 守护进程</h1><p>幸运的是，Fedora Linux 预先配置了运行重要的系统任务来保持系统更新，有几个实用程序可以运行任务例如 cron、anacron、at 和 batch 。本文只关注 cron 实用程序的安装。cron 和 cronie 包一起安装，cronie 包也提供 cron 服务。</p><h3 id=要确定软件包是否已经存在使用-rpm-命令>要确定软件包是否已经存在，使用 rpm 命令：</h3><p><code>$ rpm -q cronie Cronie-1.5.2-4.el8.x86_64</code></p><p>如果安装了 cronie ，它将返回 cronie 包的全名。如果你的系统中没有安装，则会显示未安装。</p><h3 id=使用以下命令安装>使用以下命令安装：</h3><p><code>$ dnf install cronie</code></p><h3 id=运行-cron-守护进程>运行 cron 守护进程</h3><p>cron 作业由 crond 服务来执行，它会读取配置文件中的信息。在将作业添加到配置文件之前，必须启动 crond 服务，或者安装它。什么是 crond 呢？crond 是 cron 守护程序的简称。要确定 crond 服务是否正在运行，输入以下命令：</p><a href=https://blog.baicai.me/article/2021/linux_cron/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2021/hello_world/>Hello world</a></h1><b><time>2021.05.11 14:00</time></b>
<a href=/tags/about>about</a><div><h1 id=hello-world>Hello World!</h1><pre><code>^_^
</code></pre></div></article><div><a href=/page/7/>Previous Page</a>
8 of 8</div></main><footer><p>&copy; 2025 <a href=https://blog.baicai.me/><b>baicai.me</b></a>.
<a href=/links/><b>友情链接</b></a>.
<a href=/index.xml><b>RSS</b></a>.</p></footer></body></html>