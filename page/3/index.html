<!doctype html><html lang=zh-CN><head><meta name=generator content="Hugo 0.120.4"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=author content="白菜"><meta property="og:url" content="https://blog.baicai.me/"><link rel=canonical href=https://blog.baicai.me/><style type=text/css>body{font-family:monospace}</style><title>白菜</title>
<meta name=author content="白菜"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href="/css/baicai_custom.css?rnd=1727179300"><link rel=alternate type=application/rss+xml href=/index.xml title=白菜></head><body><header>============<br>== <a href=https://blog.baicai.me/>白菜</a> ==<br>============<div style=float:right>一个勤奋的代码搬运工!</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>文章</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/about/><b>关于</b></a>.</nav></p></header><main><article><h1><a href=https://blog.baicai.me/article/2023/reverse-proxy/>搭建反向代理服务：Telegram Bot Api 反向代理搭建</a></h1><b><time>2023.09.20 12:06</time></b>
<a href=/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB>技术分享</a>
<a href=/tags/nginx>nginx</a>
<a href=/tags/proxy>proxy</a>
<a href=/tags/telegram>telegram</a><div>上面一篇通过nginx和cloudflare workers 搭建的反向代理。
这一篇通过更简单的代码重下搭建个。
通过 Cloudflare Workers 搭建反向代理服务 创建 Cloudflare workers 的步骤都是一样的，代码不一样。
创建一个Worker 在首页选择Workers，若从未创建过则初始化，选择免费套餐，然后创建一个Worker。
编辑Worker内容 进入worker，点击快速编辑，将代码改为下方内容，其中hostname改为你自己的，然后点击保存部署，并可改名为例如cdn的worker。
// 这就是需要代理的网址 const hostname = "https://example.domain" // const hostname = "http://192.168.0.1" // const hostname = "https://your.domain" // const hostname = "https://your.domain/api/path" function handleRequest(request) { let url = new URL(request.url); return fetch(new Request(hostname + url.pathname,request)) } addEventListener("fetch", event => { event.respondWith(handleRequest(event.request)) }) 为域名添加DNS 添加路由，配置
指向步骤1创建的 Worker，到此等待DNS生效即可。
通过 Vercel 搭建反向代理服务 在github中新建个项目 创建一个文件，命名为 vercel.json 文件内容：
{ "routes": [ { "src": "/.
<a href=https://blog.baicai.me/article/2023/reverse-proxy/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/nginx_tgapi_proxy/>Telegram Bot Api 反向代理搭建</a></h1><b><time>2023.09.19 22:28</time></b>
<a href=/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB>技术分享</a>
<a href=/tags/nginx>nginx</a>
<a href=/tags/proxy>proxy</a>
<a href=/tags/telegram>telegram</a><div>由于一些原因，配置epusdt需要使用tg反向代理地址才能使用！
#telegram代理url(大陆地区服务器可使用一台国外服务器做反代tg的url)，如果运行的本来就是境外服务器，则无需填写 tg_proxy= 两种实现方案，根据个人喜好选择使用或发挥
Nginx反代Telegram Api 安装nginx sudo apt update && sudo apt install -y nginx 创建配置文件 nano tgapi.conf 输入一下内容并保存
server { listen 80; server_name tgapi.domain; location / { return 444; } location ~* ^/bot { resolver 8.8.8.8; proxy_buffering off; proxy_pass https://api.telegram.org$request_uri; } } 加载配置 sudo systemctl reload nginx #或 sudo nginx -s reload 测试访问 输入以下命令行,BOT_TOKEN换成自己机器人token。
curl https://tgapi.domain/bot&lt;BOT_TOKEN>/getMe 看的机器人信息，就说明可以使用了。
配置 epusdt telegram代理url epusdt 配置(.env)参考
#telegram代理url(大陆地区服务器可使用一台国外服务器做反代tg的url)，如果运行的本来就是境外服务器，则无需填写 tg_proxy=https://tgapi.domain docker 配置 nginx 参考 docker-compose.
<a href=https://blog.baicai.me/article/2023/nginx_tgapi_proxy/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/oracle_vps_iptables/>甲骨文Vps iptables 开放端口设置</a></h1><b><time>2023.09.18 10:20</time></b>
<a href=/tags/linux>linux</a>
<a href=/tags/vps>vps</a>
<a href=/tags/oracle>oracle</a>
<a href=/tags/iptables>iptables</a><div>在甲骨文的网页后台先开放端口
iptables 开放所有端口 sudo iptables -P INPUT ACCEPT sudo iptables -P FORWARD ACCEPT sudo iptables -P OUTPUT ACCEPT sudo iptables -F Oracle自带的镜像默认设置了Iptable规则，关闭它 sudo apt-get purge netfilter-persistent && sudo reboot 测试端口是否已经开放
附注： 强制删除规则 sudo rm -rf /etc/iptables && sudo reboot 删除oracle-cloud-agent，防止甲骨文监控 snap remove oracle-cloud-agent 检查防火墙服务状态 sudo systemctl status iptables.service sudo systemctl status netfilter-persistent.service 远程检测端口开放状态 nmap ip或域名 附注2(开放指定端口): iptables 开放指定端口 iptables -I INPUT -p tcp --dport 80 -j ACCEPT 中间的 80 为所需要开放的端口，tcp 为传输协议
<a href=https://blog.baicai.me/article/2023/oracle_vps_iptables/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/docker_mtg/>Docker 搭建MTProto协议上网</a></h1><b><time>2023.09.07 18:00</time></b>
<a href=/tags/docker>Docker</a>
<a href=/tags/mtproto>mtproto</a><div>系统环境： Debian系（其他系只需要更换apt为对应系统的软件包管理工具名称即可）
安装Docker 安装Docker相关工具 sudo apt update && sudo apt -y upgrade && sudo apt install -y docker docker.io docker-compose 启动docker sudo systemctl enable docker && sudo systemctl start docker 验证是否安装成功 sudo docker run hello-world mtg v2版本 docker运行 生成密钥 sudo docker pull baicailin/mtg sudo docker run --rm baicailin/mtg generate-secret --hex trade.aliexpress.com #会看到一串ee开头的密钥，形如： eexxx44f3762c8a97d14f89df8c0174726164652e616c69657870726573732e636f6d 写入简单配置 echo "secret = \"把上面一步生成的密钥填进来\"" >config.toml echo "bind-to = \"0.0.0.0:443\"" >>config.toml 运行docker镜像命令 sudo docker run -d -v $PWD/config.
<a href=https://blog.baicai.me/article/2023/docker_mtg/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/docker_golang_alpine_cgo_build/>docker golang:alpine CGO 制作镜像的正确姿势</a></h1><b><time>2023.09.04 23:23</time></b>
<a href=/tags/docker>Docker</a>
<a href=/tags/golang>Golang</a><div>当程序需要引入C/C++库（比如支持Sqlite数据库）的时候，编译环境需要打开CGO，否则打包完成后的程序就不能顺利运行（数据库初始化失败）。
这时就需要安装 build-base 配置编译环境。
参考 Dockerfile 如下：
FROM golang:alpine as builder ENV CGO_ENABLED=1 WORKDIR /app COPY . . RUN apk add --no-cache --update git build-base RUN go mod tidy \ && go build -o api_client_linux ./cmd/api_client/ FROM alpine:latest as runner ENV TZ=Asia/Shanghai RUN apk --no-cache add ca-certificates tzdata libc6-compat libgcc libstdc++ WORKDIR /app COPY --from=builder /app/api_client_linux . VOLUME /app/conf EXPOSE 8080 ENTRYPOINT ["./api_client_linux" ,"-c","/app/conf/config.yaml"] 运行镜像我们也使用 Alpine ，由于 Alpine 极为精简，并没有常用的时区、证书等，会导致不可预料的错误。所以我们需要安装这些东西：
包名 用途 ca-certificates: CA证书，使用TLS tzdata: 时区配置 libc6-compat: C 标准库 libgcc: GCC 相关库，CGO编译程序依赖 libstdc++: C++ 标准库</div></article><article><h1><a href=https://blog.baicai.me/article/2023/blog_20230902/>网站迁移完成</a></h1><b><time>2023.09.02 16:46</time></b>
<a href=/tags/%E7%BD%91%E7%AB%99%E7%BB%B4%E6%8A%A4%E8%AE%B0%E5%BD%95>网站维护记录</a><div>实施：
hugo + github action + git pages + cloudflare
目前通过本地 vscode 写完日志后，直接推送到 github 私有仓库，通过 github action 生成静态内容自动推送到 github pages 仓库，完成部署。
静态内容存放： github pages
域名解析使用： cloudflare
附注：
github pages 自定义域名 解析设置（支持A记录）
https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site</div></article><article><h1><a href=https://blog.baicai.me/article/2023/ssh_proxycommand/>SSH使用ProxyCommand通过代理服务器远程连接其他服务器</a></h1><b><time>2023.08.31 12:12</time></b>
<a href=/tags/proxycommand>ProxyCommand</a>
<a href=/tags/ssh>ssh</a>
<a href=/tags/linux>linux</a><div>OpenSSH的客户端有一个 ProxyCommand 的选项，用于 SSH 客户端与服务器之间的隧道通信(tunneling)。所谓的隧道技术，也称代理技术，是网络通信技术的一个普遍概念，就是把一条信道建立于另外一条信道之上。
SSH 会话基于一个 TCP 连接，如果我们把连接的两个端口各自的出口（也即入口）进行截获，就可以用其它的信道来传输。而且 SSH 仍然认为它用的是和另一端连接一条 TCP 连接。
ProxyCommand 指定一个命令（称为 Proxy），SSH 客户端将通过标准输入输出和这个命令启动后的进程进行正常的 SSH 通信，而 Proxy 连接着 SSH 服务器（一般是一个 Server Proxy，再由该 Server Proxy 连接服务器）。
环境说明
远程服务器的IP地址为 0.0.0.1，代号为X； 另一个远程服务器的IP为 0.0.0.2，代号为Y； 目前本机的IP地址为 0.0.0.3，代号为A，本地可以利用SSH客户端通过密钥或密码连接X和Y； 这里全部使用密钥的方式进行访问，本机 A 与 Y 之间无法进行访问。
本地的 ～/.ssh/config 的配置文件信息如下，通过X连接到Y；
Host X HostName 0.0.0.1 User root Port 22 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_1 Host Y HostName 0.0.0.2 User root Port 22 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_2 Host test HostName 0.
<a href=https://blog.baicai.me/article/2023/ssh_proxycommand/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/urltest-urltest/>检查网络延时测试 URL 汇总，可用于软件测试延时</a></h1><b><time>2023.08.28 23:04</time></b>
<a href=/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB>技术分享</a><div>服务提供者 链接 大陆体验 境外体验 http/https IP Version 备注 Google http://www.gstatic.com/generate_204 5 10 204/204 4+6 Google网络联通性测试地址 Google http://www.google-analytics.com/generate_204 6 10 204/204 4+6 Google网络联通性测试地址 Google http://www.google.com/generate_204 0 10 204/204 4+6 Google网络联通性测试地址 Google http://connectivitycheck.gstatic.com/generate_204 4 10 204/204 4+6 Google网络联通性测试地址 Apple http://captive.apple.com 3 10 200/200 4+6 苹果设备用于检测 Wi-Fi 是否需要认证登陆的链接 Apple http://www.apple.com/library/test/success.html 7 10 200/200 4+6 苹果设备用于检测 Wi-Fi 是否需要认证登陆的链接 MicroSoft http://www.msftconnecttest.com/connecttest.txt 5 10 200/error 4 微软的网络联通性测试地址 Cloudflare http://cp.cloudflare.com/generate_204 4 10 204/204 4+6 Cloudflare的联通性测试地址 Firefox http://detectportal.
<a href=https://blog.baicai.me/article/2023/urltest-urltest/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/hugo_github_action_blog/>Hugo + GitHub Action + Github Pages，搭建博客自动发布</a></h1><b><time>2023.08.13 11:31</time></b>
<a href=/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB>技术分享</a>
<a href=/tags/hugo>hugo</a>
<a href=/tags/github-action>github action</a>
<a href=/tags/bash>bash</a>
<a href=/tags/blog>blog</a><div>我的方案由以下两个核心部分：
博客源仓库，对博客配置及所有文章 .md 源文件进行版本管理，配合 GitHub Action 进行自动化部署，自动生成静态站点推送到 GitHub Pages 博客发布仓库。 GitHub Pages 博客发布仓库，使用 GitHub Pages 实现网站部署，可以通过域名 CNAME 解析使用自定义域名。 使用 Hugo 搭建博客 Hugo 是用 Go 实现的博客工具，采用 Markdown 进行文章编辑，生成静态站点文件，支持丰富的主题配置，也可以通过 js 嵌入像是评论系统等插件，高度定制化。除了 Hugo 外， 还有 Gatsby、Jekyll、Hexo、Ghost 等选择，实现和使用都差不多，可以根据自己的偏好进行选择。
安装 Hugo 我使用的是 macOS，所以使用官方推荐的 homebrew 方式进行 hugo 程序的安装，其他系统可参考官方文档。
brew install hugo 完成后，使用以下命令进行验证(查看版本号)：
hugo version 创建 Hugo 网站 hugo new site blog-demo 配置主题 创建我们的站点后，需要进行主题配置，Hugo 社区有很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。下面我就以我目前在使用的 smol 这个主题为例，演示一下配置流程。
cd blog-demo git clone git@github.com:colorchestra/smol.git themes/smol cd themes/smol rm -rf .
<a href=https://blog.baicai.me/article/2023/hugo_github_action_blog/>Read more...</a></div></article><article><h1><a href=https://blog.baicai.me/article/2023/upgrading-debian-from-bullseye-to-bookworm/>从 Debian 11 升级到 Debian 12</a></h1><b><time>2023.06.13 21:27</time></b>
<a href=/tags/debian>debian</a><div>如果有必要，可以查阅(Debian 12 发行说明)[https://www.debian.org/releases/stable/releasenotes]，内附详细的升级和错误处理指南。
准备工作 一定要备份重要数据！
以下操作需要在 root 用户下完成，请使用 sudo -i 或 su root 切换到 root 用户进行操作
Debian 软件源一般以发行代号如：bullseye、bookworm 引用，但是也可能使用状态名如：stable、unstable、testing 引用。在 Debian 12 稳定版正式发布后，stable 就会从 bullseye 指向 bookworm 了。
检查软件源，确保下面的输出为空，否则请手动更改软件源为 bullseye
cat /etc/apt/sources.list | grep stable 更新 apt 源，替换 bullseye 为 bookworm：
sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list.d/*.list 对于 Debian 12 以后的版本，所有 Debian 可以分发的打包的非自由固件二进制文件（non-free），比如某些驱动，都被转移到 Debian Archive 中的一个新组件，称为非自由固件（non-free-firmware）。如果您从旧版的 Debian 升级，并且需要这些固件二进制文件，您应该更新您系统上的 /etc/apt/sources.list，以使用这个新组件（来源）：
sed -i 's/non-free/non-free non-free-firmware/g' /etc/apt/sources.list 默认的系统 apt 源文件 /etc/apt/sources.list 应该是类似这样的：
<a href=https://blog.baicai.me/article/2023/upgrading-debian-from-bullseye-to-bookworm/>Read more...</a></div></article><div><a href=/page/2/>Previous Page</a>
3 of 8
<a href=/page/4/>Next Page</a></div></main><footer><p>&copy; 2024 <a href=https://blog.baicai.me/><b>baicai.me</b></a>.
<a href=/links/><b>友情链接</b></a>.
<a href=/index.xml><b>RSS</b></a>.</p></footer></body></html>